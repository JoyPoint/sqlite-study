<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<title>SQLite权威指南 - AAuto编程参考资料</title>
<style>
<!--
h1 {
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:240%;
	page-break-after:avoid;
	font-size:22.0pt;
	font-family:"Times New Roman", "serif";
}
h2 {
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:173%;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"Arial", "sans-serif";
}
h3 {
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:173%;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"Times New Roman", "serif";
}
h4 {
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:156%;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Arial", "sans-serif";
}
p.MsoToc1, li.MsoToc1, div.MsoToc1 {
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Times New Roman", "serif";
}
p.MsoToc2, li.MsoToc2, div.MsoToc2 {
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Times New Roman", "serif";
}
p.MsoToc3, li.MsoToc3, div.MsoToc3 {
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Times New Roman", "serif";
}
p.MsoHeader, li.MsoHeader, div.MsoHeader {
	text-align:center;
	layout-grid-mode:char;
	border:none;
	padding:0cm;
	font-size:9.0pt;
	font-family:"Times New Roman", "serif";
}
p.MsoFooter, li.MsoFooter, div.MsoFooter {
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Times New Roman", "serif";
}
p.MsoTitle, li.MsoTitle, div.MsoTitle {
	text-align:center;
	font-size:16.0pt;
	font-family:"Arial", "sans-serif";
	font-weight:bold;
}
a:link, span.MsoHyperlink {
	color:blue;
	text-decoration:underline;
}
a:visited, span.MsoHyperlinkFollowed {
	color:purple;
	text-decoration:underline;
}
p.MsoDocumentMap, li.MsoDocumentMap, div.MsoDocumentMap {
	text-align:justify;
	text-justify:inter-ideograph;
	background:navy;
	font-size:10.5pt;
	font-family:"Times New Roman", "serif";
}
span.3Char {
	font-family:宋体;
	font-weight:bold;
}
span.msoIns {
	text-decoration:underline;
	color:teal;
}
span.msoDel {
	text-decoration:line-through;
	color:red;
}
div.WordSection1 {
	page:WordSection1;
}
-->
</style>
</head>
<body lang=ZH-CN link=blue vlink=purple style='text-justify-trim:punctuation'>
<div class=WordSection1 style='layout-grid:15.6pt'>
  <p class=MsoTitle><a name="_Toc245565730"><span  style='font-size:
22.0pt'>SQLite</span></a><span style='font-size:22.0pt;font-family:宋体'>权威指南</span></p>
  <p align=center style='text-align:center'><span>The
    Definitive Guide to SQLite</span></p>
  <p align=center style='text-align:center'><span
>（内容摘要）</span></p>
  <p><span>Michael Owens <br>
  </span><span>Copyright . 2006 by Michael Owens <br>
  </span><span >本书的示例代码可到</span><span
 style='color:#CC0000'><a href="http://www.apress.com">http://www.apress.com</a></span><span
>下载。</span><br>
  <br>
  AAuto主页：<span style="color:#CC0000"><a href="http://www.aau.cn">http://www.aau.cn</a></span><br>
AAuto论坛 SQLite版：<a href="http://www.aau.cn/forum-52-1.html">http://www.aau.cn/forum-52-1.html</a>  </p>
<h1><span >推荐者的话</span></h1>
  <p><span >最近对</span><span>SQLite</span><span
>很感兴趣，认真学习有一个多月了。</span></p>
  <p><span >学习时基本找不到既好又系统的中文文章，也买不到好的中文书籍，看来</span><span>SQLite</span><span >在国内还是不够流行，这么好的东西，可惜了。</span></p>
  <p><span >以我中等偏下的眼界，《</span><span>The Definitive Guide to SQLite</span><span >》是我所见到的最好的“</span><span>SQLite</span><span >入门</span><span>+</span><span
>大全”了，可惜也是英文的。实在找不到别的，也只好看它了，尽管我英语很不好。</span></p>
  <p><span >由于英语很不好，又因为是打字员出身的干部，所以多年来养成了一个更不好的毛病，就是在不得不看英文资料时总喜欢一边看一边翻，主要是怕下次再看时还是看不懂。看《</span><span>The Definitive Guide to SQLite</span><span >》时这个毛病也没改，当然了，看的时候就是挑着看的，翻的也只是书中的一小部分了。</span></p>
  <p><span >一般情况下看完也就看完了，很少有“下次再看”的机会，这次例外。由于越学越觉着</span><span>SQLite</span><span >好玩，就想向身边的人也介绍一下，就“再看”了。越看越羞愧，本来英语就差，还随看随翻，结果可想而知。但由于没什么动力，也就无意再重新润色了，就这样吧，反正也没什么人看，估计遗害不会太广。</span></p>
  <p><span>SQLite</span><span >是没有版权的，但这本书却是受版权保护的，也不知我这样做是否合法。发到网上也只是想做一个好事，响应</span><span>SQLite</span><span >的共享精神。估计不会有人来告我吧，反正我没钱。另外，我也只翻译了书中很小的一部分，也许根本算不上翻译（不能乱抬高自己），就算是对</span><span>SQLite</span><span >和《</span><span>The
    Definitive Guide to SQLite</span><span >》一书的一个推荐吧，同样对</span><span>SQLite</span><span >感兴趣但又看不懂我的中文的兄弟，强烈建议看原文。感谢</span><span>Richard Hipp</span><span >编出这么好的程序，感谢</span><span>Michael Owens</span><span >写出这么好的书。</span></p>
  <p><span >“空转”只是我的网名之一，网上网下知之者甚少，也就是一起骑车的几个人知道吧。如果本文对您能有一点点帮助，也算是我对</span><span>SQLite</span><span >做了一点贡献吧。本文中带有“空注”的内容是我个人所做的简单说明和忏悔，与原作者无关（以我的翻译水平，估计全文跟原作者都没什么关）。</span></p>
  <p><span >接触</span><span>SQLite</span><span
>时间不长，所以本文难免会有很多错误，不是故意误导大家，是真的水平低。如果有兄弟想对我提出指导，我的邮箱是：</span><span>njgaoyi@yahoo.com.cn</span><span >。如果我没有回信，不是因为不想回，是因为我很少上网，在此先行谢过。</span></p>
  <p><span >分析源程序时，发现每个</span><span>SQLite</span><span >源文件的头部都有这样一段话：</span></p>
  <p><span>The author disclaims copyright to this
    source code.&nbsp; In place of a legal notice, here is a blessing:</span></p>
  <p><span>May you do good and not evil.</span></p>
  <p><span>May you find forgiveness for yourself and
    forgive others.</span></p>
  <p><span>May you share freely, never taking more
    than you give.</span></p>
  <p><span >这几句话我很喜欢，翻译不好，就拿原文出来吧，与大家共勉。</span></p>
  <p><span >空转</span></p>
  <p><span>Ver 1.00: 2009-11-07 </span><span >于南京</span></p>
  <p><span >（如果以后有时间、兴趣，就把翻译过的内容好好修改一下，或者再多翻一些。但愿还有以后的版本）</span></p>
  <br
clear=all style='page-break-before:always'>
  <h1><a name="_Toc245565731"><span >总目录</span></a></h1>
  <p><span >■前言</span></p>
  <p><span >■第</span><span>1</span><span
>章</span> <span>SQLite</span><span
>介绍</span></p>
  <p><span >■第</span><span>2</span><span
>章</span> <span >入门</span></p>
  <p><span >■第</span><span>3</span><span
>章</span> <span >关系模型</span></p>
  <p><span >■第</span><span>4</span><span
>章</span> <span>SQL</span></p>
  <p><span >■第</span><span>5</span><span
>章</span> <span >设计和概念</span></p>
  <p><span >■第</span><span>6</span><span
>章</span> <span >核心</span><span>C API</span></p>
  <p><span >■第</span><span>7</span><span
>章</span> <span >扩充</span><span>C API</span></p>
  <p><span >■第</span><span>8</span><span
>章</span> <span >语言扩展</span></p>
  <p><span >■第</span><span>9</span><span
>章</span> <span>SQLite</span><span
>内核</span></p>
  <p><span >■附录</span><span>A SQL</span><span
>参考</span></p>
  <p><span >■附录</span><span>B C
    API</span><span >参考</span></p>
  <p><span >■附录</span><span>C Codd</span><span
>的</span><span>12</span><span
>条准则</span></p>
  <p><span >■索引</span></p>
  <br
clear=all style='page-break-before:always'>
  <h1><a name="_Toc245565732"><span >目录</span></a></h1>
  <p class=MsoToc1><span>SQLite</span><span >权威指南</span><span>............................................................................................................... </span><span>1</span></p>
  <p class=MsoToc1><span >总目录</span><span>............................................................................................................................. </span><span>2</span></p>
  <p class=MsoToc1><span >目录</span><span>................................................................................................................................. </span><span>3</span></p>
  <p class=MsoToc1><span >前言</span><span>................................................................................................................................. </span><span>1</span></p>
  <p class=MsoToc1><span >第</span><span>1</span><span
>章</span><span>&nbsp; SQLite</span><span
>介绍</span><span>........................................................................................................ </span><span>2</span></p>
  <p class=MsoToc2><span >内嵌式数据库</span><span>............................................................................................................ </span><span>2</span></p>
  <p class=MsoToc2><span >开发者的数据库</span><span>........................................................................................................ </span><span>3</span></p>
  <p class=MsoToc2><span >管理员的数据库</span><span>........................................................................................................ </span><span>3</span></p>
  <p class=MsoToc2><span>SQLite</span><span >的历史</span><span>........................................................................................................... </span><span>3</span></p>
  <p class=MsoToc2><span >谁使用</span><span>SQLite........................................................................................................... </span><span>4</span></p>
  <p class=MsoToc2><span >体系结构</span><span>................................................................................................................... </span><span>4</span></p>
  <p class=MsoToc3><span >接口</span><span>(Interface).................................................................................................... </span><span>5</span></p>
  <p class=MsoToc3><span >编译器</span><span>(Compiler)............................................................................................... </span><span>5</span></p>
  <p class=MsoToc3><span >虚拟机</span><span>(Virtual
    Machine)...................................................................................... </span><span>5</span></p>
  <p class=MsoToc3><span >后端</span><span>(Back-end)................................................................................................... </span><span>6</span></p>
  <p class=MsoToc3><span >工具和测试代码</span><span>(Utilities
    and Test Code)............................................................... </span><span>7</span></p>
  <p class=MsoToc2><span>SQLite</span><span >的特色</span><span>........................................................................................................... </span><span>7</span></p>
  <p class=MsoToc3><span >零配置</span><span>............................................................................................................... </span><span>7</span></p>
  <p class=MsoToc3><span >兼容性</span><span>............................................................................................................... </span><span>7</span></p>
  <p class=MsoToc3><span >紧凑性</span><span>............................................................................................................... </span><span>7</span></p>
  <p class=MsoToc3><span >简单</span><span>................................................................................................................... </span><span>8</span></p>
  <p class=MsoToc3><span >适应性</span><span>............................................................................................................... </span><span>8</span></p>
  <p class=MsoToc3><span >不受拘束的授权</span><span>................................................................................................. </span><span>8</span></p>
  <p class=MsoToc3><span >可靠性</span><span>............................................................................................................... </span><span>8</span></p>
  <p class=MsoToc3><span >易用性</span><span>............................................................................................................... </span><span>8</span></p>
  <p class=MsoToc2><span >性能和限制</span><span>............................................................................................................... </span><span>9</span></p>
  <p class=MsoToc2><span >附加信息</span><span>................................................................................................................... </span><span>9</span></p>
  <p class=MsoToc1><span >第</span><span>2</span><span
>章</span><span>&nbsp; </span><span
>入门</span><span>................................................................................................................. </span><span>10</span></p>
  <p class=MsoToc2><span >从哪得到</span><span>SQLite...................................................................................................... </span><span>10</span></p>
  <p class=MsoToc2><span >在</span><span>Windows</span><span
>上使用</span><span>SQLite........................................................................................ </span><span>10</span></p>
  <p class=MsoToc3><span >获得命令行程序</span><span>............................................................................................... </span><span>10</span></p>
  <p class=MsoToc3><span >获得</span><span>SQLite</span><span
>的动态链接库</span><span>(DLL)....................................................................... </span><span>10</span></p>
  <p class=MsoToc3><span >在</span><span>Windows</span><span
>环境下编译</span><span>SQLite</span><span
>源代码</span><span>.............................................................. </span><span>10</span></p>
  <p class=MsoToc3><span >用</span><span>Microsoft
    Visual C++</span><span >构建</span><span>SQLite
    DLL............................................................ </span><span>11</span></p>
  <p class=MsoToc3><span >用</span><span>Microsoft
    Visual C++</span><span >构建</span><span>SQLite
    CLP............................................................ </span><span>11</span></p>
  <p class=MsoToc2><span >使用</span><span>SQLite</span><span
>数据库</span><span>.................................................................................................. </span><span>11</span></p>
  <p class=MsoToc3><span>Shell</span><span >模式下使用</span><span>CLP........................................................................................ </span><span>11</span></p>
  <p class=MsoToc3><span >在命令行方式下执行</span><span>CLP................................................................................. </span><span>15</span></p>
  <p class=MsoToc2><span >数据库管理</span><span>............................................................................................................. </span><span>15</span></p>
  <p class=MsoToc3><span >创建、备份和删除数据库</span><span>................................................................................. </span><span>15</span></p>
  <p class=MsoToc3><span >获得数据库文件的信息</span><span>..................................................................................... </span><span>16</span></p>
  <p class=MsoToc2><span >其它</span><span>SQLite</span><span
>工具</span><span>..................................................................................................... </span><span>16</span></p>
  <p class=MsoToc1><span >第</span><span>3</span><span
>章</span><span>&nbsp; </span><span
>关系模型</span><span>.......................................................................................................... </span><span>17</span></p>
  <p class=MsoToc1><span >第</span><span>4</span><span
>章</span><span>&nbsp; SQL.................................................................................................................. </span><span>18</span></p>
  <p class=MsoToc2><span >关系模型</span><span>................................................................................................................. </span><span>18</span></p>
  <p class=MsoToc3><span >查询语言</span><span>.......................................................................................................... </span><span>18</span></p>
  <p class=MsoToc3><span>SQL</span><span >的发展</span><span>...................................................................................................... </span><span>18</span></p>
  <p class=MsoToc2><span >示例数据库</span><span>............................................................................................................. </span><span>18</span></p>
  <p class=MsoToc3><span >建立</span><span>................................................................................................................. </span><span>19</span></p>
  <p class=MsoToc3><span >运行示例</span><span>.......................................................................................................... </span><span>19</span></p>
  <p class=MsoToc2><span >语法</span><span>........................................................................................................................ </span><span>19</span></p>
  <p class=MsoToc3><span >命令</span><span>................................................................................................................. </span><span>20</span></p>
  <p class=MsoToc3><span >常量</span><span>................................................................................................................. </span><span>20</span></p>
  <p class=MsoToc3><span >保留字和标识符</span><span>............................................................................................... </span><span>20</span></p>
  <p class=MsoToc3><span >注释</span><span>................................................................................................................. </span><span>20</span></p>
  <p class=MsoToc2><span >创建一个数据库</span><span>...................................................................................................... </span><span>21</span></p>
  <p class=MsoToc3><span >创建表</span><span>............................................................................................................. </span><span>21</span></p>
  <p class=MsoToc3><span >改变表</span><span>............................................................................................................. </span><span>21</span></p>
  <p class=MsoToc2><span >在数据库中查询</span><span>...................................................................................................... </span><span>22</span></p>
  <p class=MsoToc3><span >关系操作</span><span>.......................................................................................................... </span><span>22</span></p>
  <p class=MsoToc3><span >操作管道</span><span>.......................................................................................................... </span><span>23</span></p>
  <p class=MsoToc3><span >过滤</span><span>................................................................................................................. </span><span>23</span></p>
  <p class=MsoToc3><span >限定和排序</span><span>...................................................................................................... </span><span>25</span></p>
  <p class=MsoToc3><span >函数</span><span>(Function)</span><span
>和聚合</span><span>(Aggregate)...................................................................... </span><span>26</span></p>
  <p class=MsoToc3><span >分组</span><span>(Grouping)................................................................................................. </span><span>27</span></p>
  <p class=MsoToc3><span >去掉重复</span><span>.......................................................................................................... </span><span>27</span></p>
  <p class=MsoToc3><span >多表连接</span><span>.......................................................................................................... </span><span>27</span></p>
  <p class=MsoToc3><span >名称和别名</span><span>...................................................................................................... </span><span>28</span></p>
  <p class=MsoToc2><span >修改数据</span><span>................................................................................................................. </span><span>28</span></p>
  <p class=MsoToc3><span >插入记录</span><span>.......................................................................................................... </span><span>28</span></p>
  <p class=MsoToc3><span >修改记录</span><span>.......................................................................................................... </span><span>28</span></p>
  <p class=MsoToc3><span >删除记录</span><span>.......................................................................................................... </span><span>29</span></p>
  <p class=MsoToc2><span >数据完整性</span><span>............................................................................................................. </span><span>29</span></p>
  <p class=MsoToc3><span >实体完整性</span><span>...................................................................................................... </span><span>29</span></p>
  <p class=MsoToc3><span >域完整性</span><span>.......................................................................................................... </span><span>30</span></p>
  <p class=MsoToc3><span >存储类</span><span>(Storage
    Classes)..................................................................................... </span><span>31</span></p>
  <p class=MsoToc3><span >弱类型</span><span>(manifest
    typing)..................................................................................... </span><span>32</span></p>
  <p class=MsoToc3><span >类型亲和性</span><span>(Type
    Affinity)................................................................................. </span><span>33</span></p>
  <p class=MsoToc2><span >事务</span><span>........................................................................................................................ </span><span>35</span></p>
  <p class=MsoToc3><span >事务的范围</span><span>...................................................................................................... </span><span>36</span></p>
  <p class=MsoToc3><span >冲突解决</span><span>.......................................................................................................... </span><span>36</span></p>
  <p class=MsoToc3><span >数据库锁</span><span>.......................................................................................................... </span><span>36</span></p>
  <p class=MsoToc3><span >死锁</span><span>................................................................................................................. </span><span>37</span></p>
  <p class=MsoToc3><span >事务的种类</span><span>...................................................................................................... </span><span>38</span></p>
  <p class=MsoToc2><span >数据库管理</span><span>............................................................................................................. </span><span>38</span></p>
  <p class=MsoToc3><span >视图</span><span>................................................................................................................. </span><span>38</span></p>
  <p class=MsoToc3><span >索引</span><span>................................................................................................................. </span><span>39</span></p>
  <p class=MsoToc3><span >触发器</span><span>............................................................................................................. </span><span>39</span></p>
  <p class=MsoToc3><span >附加</span><span>(Attaching)</span><span
>数据库</span><span>...................................................................................... </span><span>40</span></p>
  <p class=MsoToc3><span >清洁数据库</span><span>...................................................................................................... </span><span>40</span></p>
  <p class=MsoToc3><span >数据库配置</span><span>...................................................................................................... </span><span>40</span></p>
  <p class=MsoToc3><span >系统表</span><span>............................................................................................................. </span><span>42</span></p>
  <p class=MsoToc3><span >查看</span><span>Query</span><span
>的执行</span><span>............................................................................................ </span><span>42</span></p>
  <p class=MsoToc1><span >第</span><span>5</span><span
>章</span><span>&nbsp; </span><span
>设计和概念</span><span>....................................................................................................... </span><span>44</span></p>
  <p class=MsoToc2><span>API......................................................................................................................... </span><span>44</span></p>
  <p class=MsoToc3><span>SQLite</span><span >版本</span><span>3</span><span >的新特性</span><span>..................................................................................... </span><span>44</span></p>
  <p class=MsoToc3><span >主要的数据结构</span><span>............................................................................................... </span><span>45</span></p>
  <p class=MsoToc3><span >核心</span><span>API.......................................................................................................... </span><span>46</span></p>
  <p class=MsoToc3><span >操作控制</span><span>.......................................................................................................... </span><span>52</span></p>
  <p class=MsoToc3><span >扩充</span><span>API.......................................................................................................... </span><span>53</span></p>
  <p class=MsoToc2><span >事务</span><span>........................................................................................................................ </span><span>54</span></p>
  <p class=MsoToc3><span >事务的生命周期</span><span>............................................................................................... </span><span>54</span></p>
  <p class=MsoToc3><span >锁的状态</span><span>.......................................................................................................... </span><span>55</span></p>
  <p class=MsoToc3><span >读事务</span><span>............................................................................................................. </span><span>56</span></p>
  <p class=MsoToc3><span >写事务</span><span>............................................................................................................. </span><span>56</span></p>
  <p class=MsoToc3><span >调整页缓冲区</span><span>................................................................................................... </span><span>58</span></p>
  <p class=MsoToc3><span >等待加锁</span><span>.......................................................................................................... </span><span>59</span></p>
  <p class=MsoToc2><span >编码</span><span>........................................................................................................................ </span><span>60</span></p>
  <p class=MsoToc3><span >使用多个连接</span><span>................................................................................................... </span><span>60</span></p>
  <p class=MsoToc3><span >表锁</span><span>................................................................................................................. </span><span>61</span></p>
  <p class=MsoToc3><span >有趣的临时表</span><span>................................................................................................... </span><span>62</span></p>
  <p class=MsoToc3><span >定案的重要性</span><span>................................................................................................... </span><span>63</span></p>
  <p class=MsoToc3><span >共享缓冲区模式</span><span>............................................................................................... </span><span>63</span></p>
  <p class=MsoToc1><span >第</span><span>6</span><span
>章</span><span>&nbsp; </span><span
>核心</span><span>C API........................................................................................................ </span><span>65</span></p>
  <p class=MsoToc2><span >封装的查询</span><span>............................................................................................................. </span><span>65</span></p>
  <p class=MsoToc3><span >连接和断开连接</span><span>............................................................................................... </span><span>65</span></p>
  <p class=MsoToc3><span >执行</span><span>Query....................................................................................................... </span><span>66</span></p>
  <p class=MsoToc3><span >字符串处理</span><span>...................................................................................................... </span><span>69</span></p>
  <p class=MsoToc3><span>Get Table</span><span style='font-family:
宋体'>查询</span><span>................................................................................................... </span><span>70</span></p>
  <p class=MsoToc2><span >预处理的查询</span><span>.......................................................................................................... </span><span>71</span></p>
  <p class=MsoToc3><span >取记录</span><span>............................................................................................................. </span><span>73</span></p>
  <p class=MsoToc3><span >参数化的查询</span><span>................................................................................................... </span><span>76</span></p>
  <p class=MsoToc2><span >错误和意外</span><span>............................................................................................................. </span><span>76</span></p>
  <p class=MsoToc3><span >处理错误</span><span>.......................................................................................................... </span><span>76</span></p>
  <p class=MsoToc3><span >处理忙状态</span><span>...................................................................................................... </span><span>78</span></p>
  <p class=MsoToc2><span >操作控制</span><span>................................................................................................................. </span><span>78</span></p>
  <p class=MsoToc3><span >提交</span><span>Hook</span><span
>函数</span><span>................................................................................................. </span><span>78</span></p>
  <p class=MsoToc3><span >回卷</span><span>Hook</span><span
>函数</span><span>................................................................................................. </span><span>78</span></p>
  <p class=MsoToc3><span >修改</span><span>Hook</span><span
>函数</span><span>................................................................................................. </span><span>78</span></p>
  <p class=MsoToc3><span >授权函数</span><span>.......................................................................................................... </span><span>79</span></p>
  <p class=MsoToc2><span >线程</span><span>........................................................................................................................ </span><span>84</span></p>
  <p class=MsoToc3><span >共享缓冲区模式</span><span>............................................................................................... </span><span>85</span></p>
  <p class=MsoToc3><span >线程和内存管理</span><span>............................................................................................... </span><span>85</span></p>
  <p class=MsoToc1><span >第</span><span>7</span><span
>章</span><span>&nbsp; </span><span
>扩充</span><span>C API........................................................................................................ </span><span>86</span></p>
  <p class=MsoToc2><span>API......................................................................................................................... </span><span>86</span></p>
  <p class=MsoToc3><span >注册函数</span><span>.......................................................................................................... </span><span>86</span></p>
  <p class=MsoToc3><span >步进函数</span><span>.......................................................................................................... </span><span>86</span></p>
  <p class=MsoToc3><span >返回值</span><span>............................................................................................................. </span><span>86</span></p>
  <p class=MsoToc2><span >函数</span><span>........................................................................................................................ </span><span>86</span></p>
  <p class=MsoToc3><span >返回值</span><span>............................................................................................................. </span><span>86</span></p>
  <p class=MsoToc3><span >一个完整的例子</span><span>............................................................................................... </span><span>86</span></p>
  <p class=MsoToc3><span >一个实际的应用程序</span><span>........................................................................................ </span><span>88</span></p>
  <p class=MsoToc2><span >聚合</span><span>........................................................................................................................ </span><span>88</span></p>
  <p class=MsoToc3><span >一个实际的例子</span><span>............................................................................................... </span><span>88</span></p>
  <p class=MsoToc2><span >排序法</span><span>.................................................................................................................... </span><span>90</span></p>
  <p class=MsoToc3><span >排序法定义</span><span>...................................................................................................... </span><span>90</span></p>
  <p class=MsoToc3><span >一个简单的例子</span><span>............................................................................................... </span><span>90</span></p>
  <p class=MsoToc3><span >按需排序</span><span lang=FR>(Collation
    on Demand)</span><span>......................................................................... </span><span>92</span></p>
  <p class=MsoToc3><span >一个实际的应用程序</span><span>........................................................................................ </span><span>93</span></p>
  <p class=MsoToc1><span >第</span><span>8</span><span
>章</span><span>&nbsp; </span><span
>语言扩展</span><span>........................................................................................................ </span><span>100</span></p>
  <p class=MsoToc1><span >第</span><span>9</span><span
>章</span><span>&nbsp; SQLite</span><span
>内核</span><span>..................................................................................................... </span><span>101</span></p>
  <p class=MsoToc2><span >虚拟数据库引擎</span><span>(VDBE)......................................................................................... </span><span>101</span></p>
  <p class=MsoToc3><span >栈</span><span>(Stack)........................................................................................................ </span><span>103</span></p>
  <p class=MsoToc3><span >程序体</span><span>............................................................................................................ </span><span>103</span></p>
  <p class=MsoToc3><span >程序开始与停止</span><span>.............................................................................................. </span><span>104</span></p>
  <p class=MsoToc3><span >指令的类型</span><span>..................................................................................................... </span><span>105</span></p>
  <p class=MsoToc2><span>B-Tree</span><span >和</span><span>Pager</span><span >模型</span><span>............................................................................................... </span><span>105</span></p>
  <p class=MsoToc3><span >数据库文件格式</span><span>.............................................................................................. </span><span>106</span></p>
  <p class=MsoToc3><span>B-Tree API...................................................................................................... </span><span>109</span></p>
  <p class=MsoToc2><span >编译器</span><span>................................................................................................................... </span><span>111</span></p>
  <p class=MsoToc3><span >分词器</span><span>(Tokenizer)............................................................................................ </span><span>111</span></p>
  <p class=MsoToc3><span >分析器</span><span>(Parser)................................................................................................. </span><span>112</span></p>
  <p class=MsoToc3><span >代码生成器</span><span>(Code
    Generator)............................................................................ </span><span>113</span></p>
  <p class=MsoToc3><span >优化</span><span>............................................................................................................... </span><span>114</span></p>
</div>
<br
clear=all style='page-break-before:always'>
<div class=WordSection2 style='layout-grid:15.6pt'>
  <h1><a name="_Toc245565733"><span >前言</span></a></h1>
  <p><span>2000</span><span >年春天，当我刚开始编写</span><span>SQLite</span><span >时，根本没想到它会在编程社区受到如此强烈的认可。今天，有成百万的</span><span>SQLite</span><span >拷贝在默默地运行，在计算机中，或在不同公司生产的各种各样的小设备中。你可能已经在无意识的情况下使用过</span><span>SQLite</span><span >，在你的手机、</span><span>MP3</span><span >或机顶盒里可能就有</span><span>SQLite</span><span >。在你的计算机里也可能至少会有一个</span><span>SQLite</span><span >的拷贝，它可能来自</span><span>Apple</span><span >的</span><span>Mac
    OS X</span><span >，或者在大多数的</span><span>Linux</span><span
>版本中，或者在</span><span>Windows</span><span
>中安装某个第三方软件时。很多</span><span>Web</span><span
>网站的后台都使用</span><span>SQLite</span><span
>，这要感谢它已经被包含为</span><span>PHP5</span><span
>语言的一部分。</span><span>SQLite</span><span
>也被用于很多航空电子设备、建模和仿真程序、工业控制、智能卡、决策支持包、医药信息系统等。因为没有</span><span>SQLite</span><span >使用的全面报告，所以，肯定还有很多我不知道的</span><span>SQLite</span><span >部署。</span></p>
  <p><span>SQLite</span><span >的普及很大程度上应该归功于</span><span>Michael Owens</span><span >。</span><span>Mike</span><span >在</span><span>The
    Linux Journal (June 2003)</span><span >和</span><span>The C/C++ Users Journal (March 2004)</span><span style='font-family:
宋体'>上的文章吸引了无数程序员。每篇文章发表后，</span><span>SQLite</span><span
>网站的访问量都会显著上升。通过这本书你可以看到</span><span>Mike</span><span
>的才华和他所做的大量工作，相信你不会失望。本书包含了关于</span><span>SQLite</span><span
>所需要了解的所有内容，你应该一直把它放在伸手可及的地方。</span></p>
  <p><span>SQLite</span><span >是自由软件。尽管我是它的架构师和代码的主要编写者，但</span><span>SQLite</span><span >并不是我的程序。</span><span>SQLite</span><span >不属于任何人，也不在版权的保护范围之内。所有曾经为</span><span>SQLite</span><span >项目贡献过代码的人都签署过一个宣誓书将他们的贡献发布到公共域，我把这些宣誓书的原件保存在办公室的保险箱里。我还尽力保证在</span><span>SQLite</span><span >中不使用专利算法，这些预防措施意味着你可以以任何形式使用</span><span>SQLite</span><span >，而不需要付版税、许可证费用或受到其它任何限制。</span></p>
  <p><span>SQLite</span><span >仍然在发展。但我和其他开发者都坚守它的核心价值。我们将保持代码的小规模――核心库不会超过</span><span>250KB</span><span >。我们将保持公共</span><span>API</span><span >和文件格式的向上兼容性。我们将继续保证</span><span>SQLite</span><span >是充分测试的和无</span><span>bug</span><span >的。我们希望你总是能够将新版本的</span><span>SQLite</span><span >放到你老的程序中，既得到它新的特性和优化，又不需要或仅需要很少的代码改动，且不需要做进一步的调试。</span><span>2004</span><span >年，我们将</span><span>SQLite</span><span >从版本</span><span>2</span><span >升</span><span
>级到版本</span><span>3</span><span
>时确实没能保持向上兼容性，但从那以后，我们已经能够达到上述所有目标并准备在将来继续这样做。没有</span><span>SQLite</span><span >版本</span><span>4</span><span
>的计划。</span></p>
  <p><span >真诚希望你觉着</span><span>SQLite</span><span
>是有用的，我代表</span><span>SQLite</span><span
>的所有贡献者保证，使用</span><span>SQLite</span><span
>你会：做出美好的产品，你的产品将会是快速、稳定和易用的。寻求宽恕并宽恕他人。因为你已经免费地得到了</span><span>SQLite</span><span >，也请你免费地给予他人一些东西作为回报。做一回志愿者，贡献出其它的软件项目或找到其它途径来回报。</span></p>
  <p><span>Richard Hipp </span></p>
  <p><span>Charlotte</span><span>, NC</span><span> </span></p>
  <p><span>April 11, 2006 </span></p>
  <br
clear=all style='page-break-before:always'>
  <h1><a name="_Toc245565734"><span >第</span><span>1</span></a><span >章</span><span>&nbsp;
    SQLite</span><span >介绍</span></h1>
  <p><span>SQLite</span><span >是一个开源的、内嵌式的关系型数据库。它最初发布于</span><span>2000</span><span >年，在便携性、易用性、紧凑性、有效性和可靠性方面有突出的表现。</span></p>
  <h2><a name="_Toc245565735"><span style='font-family:黑体'>内嵌式数据库</span></a></h2>
  <p><span>SQLite</span><span >是一个内嵌式的数据库。</span></p>
  <p><span >数据库服务器就在你的程序中，其好处是不需要网络配置和管理。数据库的服务器和客户端运行在同一个进程中。这样可以减少网络访问的消耗，简化数据库管理，使你的程序部署起来更容易。所有需要你做的都已经和你的程序一起编译好了。</span></p>
  <p><span >如图</span><span>1-1</span><span
>所示。一个</span><span>Perl</span><span
>脚本、一个标准</span><span>C/C++</span><span
>程序和一个使用</span><span>PHP</span><span
>编写的</span><span>Apache</span><span
>进程都使用</span><span>SQLite</span><span
>。</span><span>Perl</span><span
>脚本导入</span><span>DBI::SQLite</span><span
>模板，并通过它来访问</span><span>C API</span><span
>。</span><span>PHP</span><span
>采用与</span><span>C</span><span
>相似的方式访问</span><span>C API</span><span
>。总之，它们都需要访问</span><span>C API</span><span
>。尽管它们每个进程中都有独立的数据库服务器，但它们可以操作相同的数据库文件。</span><span>SQLite</span><span >利用操作系统功能来完成数据的同步和加锁。</span></p>
  <p><span><img width=553 height=409
src="Definitive Guide/image001.jpg"></span></p>
  <p><span >图</span><span>1-1 </span><span
>内嵌的主进程中的</span><span>SQLite </span></p>
  <p><span >目前市场上有多种为内嵌应用所设计的关系型数据库产品，如</span><span>Sybase SQL Anywhere</span><span >、</span><span>InterSystems Caché</span><span >、</span><span>Pervasive PSQL</span><span >和微软的</span><span>Jet Engine</span><span >。有些厂家从他们的大型数据库产品翻新出内嵌式的变种，如</span><span>IBM</span><span >的</span><span>DB2
    Everyplace</span><span >、</span><span>Oracle</span><span
>的</span><span>10g</span><span >和微软的</span><span>SQL
    Server Desktop Engine</span><span >。开源的数据库</span><span>MySQL</span><span >和</span><span>Firebird</span><span
>都提供内嵌式的版本。在所有这些产品中，仅有两个是完全开放源代码的且不收许可证费用――</span><span>Firebird</span><span >和</span><span>SQLite</span><span >。在这两个当中，仅有一个是专门为内嵌式应用设计的――</span><span>SQLite</span><span >。</span></p>
  <h2><a name="_Toc245565736"><span style='font-family:黑体'>开发者的数据库</span></a></h2>
  <p><span>SQLite</span><span >具有多方面的特性。它是一个数据库，一个程序库，一个命令行工具，也是一个学习关系型数据库的很好的工具。确实有很多途径可以使用它――内嵌环境、网站、操作系统服务、脚本语言和应用程序。对于程序员来说，</span><span>SQLite</span><span >就象一个数据传送带，提供了一种方便的将应用程序绑定的数据的方法。就象传送带一样，对</span><span>SQLite</span><span >的使用没有终点。</span></p>
  <p><span >除了仅仅作为一个存储容器，</span><span>SQLite</span><span >还可以作为一个单纯的数据处理的工具。如果大小和复杂性合适，使用</span><span>SQLite</span><span >可以很容易地将应用程序所使用的数据结构转化为表，并保存在一个内在数据库中。用此方法，你可以操作互相关联的数据，可以完成很繁重的任务页不必写自己的算法来对数据结构操作和排序。如果你是一个程序员，想像一下在你的程序中自行完成下面</span><span>SQL</span><span >语句所代表的工作需要多少代码：</span></p>
  <p><span>SELECT AVG(z-y) FROM table GROUP BY x</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; HAVING x &gt; MIN(z) OR
    x &lt; MAX(y)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; ORDER BY y DESC LIMIT 10
    OFFSET 3; </span></p>
  <p><span>SQLite</span><span >还是一个很好的学习程序设计的工具，通过它可以研究很多计算机科学的课题。分析器、分词器、虚拟机、</span><span>Btree</span><span >算法、高整缓存、程序体系结构，通过这些内容可以搞清楚很多计算机科学的经典概念。</span><span>SQLite</span><span >的模块化、小型化和简易性，使你可以很容易地专门研究其中的一个问题。</span></p>
  <h2><a name="_Toc245565737"><span style='font-family:黑体'>管理员的数据库</span></a></h2>
  <p><span>SQLite</span><span >不仅是程序员的数据库，它对系统管理员也很有用。它很小、紧凑而精致，就像一些</span><span>Unix</span><span >的常用工具，如</span><span>find</span><span >、</span><span>rsync</span><span
>或</span><span>grep</span><span
>。</span><span>SQLite</span><span
>提供了命令行工具供用户交互操作。</span></p>
  <p><span >另外，对于关系型数据库的初学者来说，</span><span>SQLite</span><span >是一个学习各种关系相关概念的方便的学习工具。它可以很快很容易地安装在各类操作系统中，它的数据库文件可以自由共享页不需要任何转换。它具有关系型数据库的各种特色而又不令人生畏。它的程序和数据库文件仅用</span><span>U</span><span >盘就能传递。</span></p>
  <h2><a name="_Toc245565738"><span>SQLite</span></a><span
style='font-family:黑体'>的历史</span></h2>
  <p><span >从某个角度来说，</span><span>SQLite</span><span >最初的构思是在一条军舰上进行的。</span><span>SQLite</span><span >的作者</span><span>D. Richard Hipp</span><span >当时正在为美国海军编制一种使用在导弹驱逐舰上的程序。那个程序最初是运行在</span><span>Hewlett-Packard Unix (HPUX)</span><span >上，后台使用</span><span>Informix</span><span >数据库。对那个程序来说，</span><span>Informix</span><span >有点儿太强大了。一个有经验的数据库管理员</span><span>(DBA)</span><span >可能需要一整天来对它进行安装和升级，如果没经验，这个工作就可能永远也做不完了。</span></p>
  <p><span>2000</span><span >年一月，</span><span>Hipp</span><span >开始和一个同事讨论关于创建一个简单的内嵌式</span><span>SQL</span><span >数据库的想法，这个数据库将使用</span><span>GNU DBM B-Tree library (gdbm)</span><span >做后台，同时这个数据库将不需要安装和管理支持。后来，当有些空闲时间时，</span><span>Hipp</span><span >就开始实施这项工作，并在</span><span>2000</span><span >年的八月份发布了</span><span>SQLite</span><span >的</span><span>1.0</span><span
>版。</span></p>
  <p><span >按照原定计划，</span><span>SQLite
    1.0</span><span >用</span><span>gdbm</span><span
>来做存储管理。但后来，</span><span>Hipp</span><span
>很快就换成了自己的</span><span>B-tree</span><span
>，以支持事务和记录按主键的存储。随着最初的升级，</span><span>SQLite</span><span
>在功能和用户数上都得到了稳步的发展。在</span><span>2001</span><span
>年中期，很多项目――开源的或商业的――都开始使用</span><span>SQLite</span><span
>。在那以后的几年中，开源社区的其他成员开始为他们喜欢的程序设计语言编写</span><span>SQLite</span><span >扩展。</span><span>SQLite</span><span >的</span><span>ODBC</span><span
>接口可以为</span><span>Perl</span><span
>、</span><span>Python</span><span
>、</span><span>Ruby</span><span
>、</span><span>Java</span><span
>和其它主流的程序设计语言提供支持，这证明了</span><span>SQLite</span><span
>有广阔的应用前景。</span></p>
  <p><span>2004</span><span >年，</span><span>SQLite</span><span >从版本</span><span>2</span><span >升</span><span
>级到版本</span><span>3</span><span
>，这是一次大升级。主要目的是增加内置的对</span><span>UTF-8</span><span
>、</span><span>UTF-16</span><span
>及用户定义字符集的支持。</span><span>While 3.0 was
    originally slated for release in summer 2005, America Online provided the
    necessary funding to see that it was completed by July 2004. </span><span
>除国际化功能外，版本</span><span>3</span><span
>的其它新特性包括：经过修补的</span><span>C API</span><span
>，更紧凑的数据库文件格式</span><span>(</span><span
>比原来节省</span><span>25%</span><span
>的空间</span><span>)</span><span
>，弱类型，大二进制对象</span><span>(BLOB)</span><span
>的支持，</span><span>64-bit</span><span
>的</span><span>ROWID</span><span
>，</span><span>autovacuum</span><span
>和改进了的并发控制。尽管增加了这一系列新特性，版本</span><span>3</span><span
>的运行库仍然小于</span><span>240K</span><span
>字节。</span><span>Another improvement in
    version 3 was a good code cleanup―revisiting and rewriting, or otherwise
    throwing out extraneous stuff accumulated in the 2.x series. </span></p>
  <p><span>SQLite</span><span >持续增长并始终坚持其最初的设计目标：简单、弹性、紧凑、速度和彻底的易用。本书出版时，</span><span>SQLite</span><span >已经增加了</span><span>CHECK</span><span >约束，下面就要增加外键约束，再下面呢？</span></p>
  <h2><a name="_Toc245565739"><span style='font-family:黑体'>谁使用</span><span>SQLite</span></a><span> </span></h2>
  <p><span >当前，</span><span>SQLite</span><span
>已经被多种软件和产品所使用。它被用在</span><span>Apple</span><span
>的</span><span>Mac OS X</span><span
>操作系统中，被用作其</span><span>CoreData</span><span
>应用程序架构的一部分。它还应用于</span><span>Safari</span><span
>的</span><span>Web</span><span
>浏览器、</span><span>Mail.app</span><span
>的电子邮件程序、</span><span>RSS</span><span
>的管理、</span><span>Apple</span><span
>的</span><span>Aperture</span><span
>照片软件。</span><span> </span></p>
  <p><span >尽管</span><span>SQLite</span><span
>很少做广告，但它还是被用在了多种消费类产品中。</span></p>
  <h2><a name="_Toc245565740"><span style='font-family:黑体'>体系结构</span></a></h2>
  <p><span>SQLite</span><span >拥有一个精致的、模块化的体系结构，并引进了一些独特的方法进行关系型数据库的管理。它由被组织在</span><span>3</span><span >个子系统中的</span><span>8</span><span
>个独立的模块组成，如图</span><span>1-2</span><span
>所示。这个模型将查询过程划分为几个不连续的任务，就像在流水线上工作一样。在体系结构栈的顶部编译查询语句，在中部执行它，在底部处理操作系统的存储和接口。</span></p>
  <p><span><img width=554 height=345
src="Definitive Guide/image002.jpg"></span></p>
  <p><span >图</span><span>1-2 SQLite</span><span
>的体系结构</span></p>
  <h3><a name="_Toc245565741"><span >接口</span><span>(Interface)</span></a></h3>
  <p><span >接口由</span><span>SQLite
    C API</span><span >组成，也就是说不管是程序、脚本语言还是库文件，最终都是通过它与</span><span>SQLite</span><span >交互的</span><span>(</span><span >我们经常使用的</span><span>ODBC/JDBC</span><span
>最后也会转化为相应</span><span>C API</span><span
>的调用</span><span>)</span><span
>。</span></p>
  <h3><a name="_Toc245565742"><span >编译器</span><span>(Compiler)</span></a></h3>
  <p><span >编译过程从分词器</span><span>(Tokenizer)</span><span >和分析器</span><span>(Parser)</span><span >开始。它们协作处理文本形式的结构化查询</span><span>(Structured Query Language, SQL)</span><span style='font-family:
宋体'>语句，分析其语法有效性，转化为底层能更方便处理的层次数据结构――语法树，然后把语法树传给代码生成器</span><span>(code
    generator)</span><span >进行处理。</span><span>SQLite</span><span
>分词器的代码是手工编写的，分析器代码是由</span><span>SQLite</span><span
>定制的分析器生成器</span><span>(</span><span
>称为</span><span>Lemon)</span><span
>生成的。</span><span>The Lemon parser generator
    is designed for high performance and takes special precautions to guard against
    memory leaks. </span><span >一旦</span><span>SQL</span><span
>语句被分解为串值并组织到语法树中，分析器就将该树下传给代码生成器进行处理。而代码生成器根据它生成一种</span><span>SQLite</span><span >专用的汇编代码，最后由虚拟机</span><span>(Virtual Machine)</span><span >执行。</span><span> </span></p>
  <h3><a name="_Toc245565743"><span >虚拟机</span><span>(Virtual Machine)</span></a></h3>
  <p><span >架构中最核心的部分是虚拟机，或者叫做虚拟数据库引擎</span><span>(Virtual DataBase Engine,VDBE)</span><span >。它和</span><span>Java</span><span >虚拟机相似，解释执行字节代码。</span><span>VDBE</span><span >的字节代码</span><span>(</span><span >称为虚拟机语言</span><span>)</span><span
>由</span><span>128</span><span
>个操作码</span><span>(opcodes)</span><span
>构成，主要是进行数据库操作。它的每一条指令或者用来完成特定的数据库操作</span><span>(</span><span >比如打开一个表的游标、开始一个事务等</span><span>)</span><span >，或者为完成这些操作做准备。总之，所有的这些指令都是为了满足</span><span>SQL</span><span >命令的要求。</span><span>VDBE</span><span >的指令集能满足任何复杂</span><span>SQL</span><span >命令的要求。所有的</span><span>SQLite SQL</span><span >语句――从选择和修改记录到创建表、视图和索引――都是首先编译成此种虚拟机语言，组成一个独立程序，定义如何完成给定的命令。例如，在</span><span>SQLite</span><span >的</span><span>CLP</span><span
>中执行下面语句：</span></p>
  <p><span>sqlite&gt; .m col</span></p>
  <p><span>sqlite&gt; .h on</span></p>
  <p><span>sqlite&gt; .w 4 15 3 3 3 10 3</span></p>
  <p><span>sqlite&gt; explain SELECT name FROM
    episodes LIMIT 10;</span></p>
  <p><span>SQLite</span><span >会显示编译后的</span><span>VDBE</span><span >汇编程序，如列表</span><span>1-1</span><span >所示。</span></p>
  <p><span >列表</span><span>1-1 VDBE</span><span
>汇编程序</span></p>
  <p><span>addr&nbsp;
    opcode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    p1&nbsp;&nbsp; p2&nbsp;&nbsp; p3&nbsp;&nbsp;
    p4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    p5&nbsp;&nbsp;&nbsp; comment</span></p>
  <p><span>----&nbsp;
    ---------------&nbsp; ---&nbsp; ---&nbsp; ---&nbsp; ---------------&nbsp;
    ----&nbsp; ----------</span></p>
  <p><span>0&nbsp;&nbsp;&nbsp;&nbsp;
    Trace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>1&nbsp; &nbsp;&nbsp;&nbsp;Integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    10&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>2&nbsp;&nbsp;&nbsp;&nbsp;
    MustBeInt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>3&nbsp;&nbsp;&nbsp;&nbsp;
    IfZero&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    1&nbsp;&nbsp;&nbsp; 13&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>4&nbsp;&nbsp;&nbsp;&nbsp;
    Goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 14&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>5&nbsp;&nbsp;&nbsp;&nbsp;
    OpenRead&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; &nbsp;2&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;
    3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>6&nbsp;&nbsp;&nbsp;&nbsp;
    Rewind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>7&nbsp;&nbsp;&nbsp;&nbsp;
    Column&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;
    2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>8&nbsp;&nbsp;&nbsp;&nbsp;
    ResultRow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;
    1&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>9&nbsp;&nbsp;&nbsp;&nbsp;
    AddImm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    1&nbsp;&nbsp;&nbsp; -1&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp;&nbsp;00</span></p>
  <p><span>10&nbsp;&nbsp;&nbsp;
    IfZero&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    1&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>11&nbsp;&nbsp;&nbsp;
    Next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    01</span></p>
  <p><span>12&nbsp;&nbsp;&nbsp;
    Close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>13&nbsp;&nbsp;&nbsp;
    Halt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>14&nbsp;&nbsp;&nbsp;
    Transaction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>15&nbsp;&nbsp;&nbsp;
    VerifyCookie&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 40&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>16&nbsp;&nbsp;&nbsp;
    TableLock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    2&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    episodes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00</span></p>
  <p><span>17&nbsp;&nbsp;&nbsp;
    Goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span >程序由</span><span>17</span><span
>条指令组成。通过对给定的操作数完成特别的操作，这些指令将会返回</span><span>episodes</span><span
>表前</span><span>10</span><span
>个记录的</span><span>name</span><span
>字段的值。</span><span>episodes</span><span
>表是本书示例数据库的一部分。</span></p>
  <p><span >从多个方面都可以看出，</span><span>VDBE</span><span >是</span><span>SQLite</span><span
>的核心：它上面的各模块都是用于创建</span><span>VDBE</span><span
>程序，它下面的各模块都是用于执行</span><span>VDBE</span><span
>程序，每次执行一条指令。</span></p>
  <h3><a name="_Toc245565744"><span >后端</span><span>(Back-end)</span></a></h3>
  <p><span >后端由</span><span>B-tree</span><span
>、页缓冲</span><span>(page cache</span><span
>，</span><span>pager)</span><span
>和操作系统接口</span><span>(</span><span
>即系统调用</span><span>)</span><span
>构成。</span><span>B-tree</span><span
>和</span><span>page cache</span><span
>共同对数据进行管理。它们操作的是数据库页，这些页具有相同的大小，就像集装箱。页里面的“货物”是表示信息的大量</span><span>bit</span><span >，这些信息包括记录、字段和索引入口等。</span><span>B-tree</span><span >和</span><span>pager</span><span
>都不知道信息的具体内容，它们只负责“运输”这些页，页不关心这些“集装箱”里面是什么。</span></p>
  <p><span>B-tree</span><span >的主要功能就是索引，它维护着各个页之间的复杂的关系，便于快速找到所需数据。它把页组织成树型的结构</span><span>(</span><span >这是它名称的由来</span><span>)</span><span >，这种树是为查询而高度优化了的。</span><span>Page</span><span >为</span><span>B-tree</span><span
>服务，为它提供页。</span><span>Pager</span><span
>的主要作用就是通过</span><span>OS</span><span
>接口在</span><span>B-tree</span><span
>和磁盘之间传递页。磁盘操作是计算机到目前为止所必须做的最慢的事情。所以，</span><span>pager </span><span >尽力提高速度，其方法是把经常使用的页存放到内存当中的页缓冲区里，从而尽量减少操作磁盘的次数。它使用特殊的算法来预测下面要使用哪些页，从而使</span><span>B-tree</span><span >能够更快地工作。</span><span> </span></p>
  <h3><a name="_Toc245565745"><span >工具和测试代码</span><span>(Utilities and Test Code)</span></a></h3>
  <p><span >工具模块中包含各种各样的实用功能，还有一些如内存分配、字符串比较、</span><span>Unicode</span><span >转换之类的公共服务也在工具模块中。这个模块就是一个包罗万象的工具箱，很多其它模块都需要调用和共享它。</span></p>
  <p><span >测试模块中包含了无数的回归测试语句，用来检查数据库代码的每个细微角落。这个模块是</span><span>SQLite</span><span >性能如此可靠的原因之一。</span></p>
  <h2><a name="_Toc245565746"><span>SQLite</span></a><span
style='font-family:黑体'>的特色</span></h2>
  <p><span >尽管</span><span>SQLite</span><span
>是如此之小，却提供了如此之多的特色和性能。它支持</span><span>ANSI
    SQL92</span><span >的一个大子集</span><span>(</span><span
>包括事务、视图、检查约束、关联子查询和复合查询等</span><span>)</span><span
>，还支持其它很多关系型数据库的特色，如触发器、索引、自动增长字段和</span><span>LIMIT/OFFSET</span><span >子句等。</span><span>SQLite</span><span >还有很多独特的特色，如内在数据库、动态类型和冲突解决</span><span>(</span><span >下面解释</span><span>)</span><span
>。</span></p>
  <p><span >如本章开始时所述，在</span><span>SQLite</span><span >的观念和实现中，都遵循着一系列指导原则。下面就来详述这些原则。</span></p>
  <h3><a name="_Toc245565747"><span >零配置</span></a></h3>
  <p><span >从</span><span>SQLite</span><span
>的设计之始，就没准备在应用时使用</span><span>DBA</span><span
>。配置和管理</span><span>SQLite</span><span
>就像得到它一样简单。</span><span>SQLite</span><span
>包含了正好适合于一个程序员的脑筋的特色。</span></p>
  <h3><a name="_Toc245565748"><span >兼容性</span></a></h3>
  <p><span>SQLite</span><span >在设计时特别注意了兼容性。它可以编译运行在</span><span>Windows</span><span >、</span><span>Linux</span><span
>、</span><span>BSD</span><span
>、</span><span>Mac OS X</span><span
>及商用的</span><span>Unix </span><span
>系统如</span><span>Solaris</span><span
>、</span><span>HPUX</span><span
>和</span><span>AIX</span><span
>，还可以应用于很多嵌入式平台如</span><span>QNX</span><span
>、</span><span>VxWorks</span><span
>、</span><span>Symbian</span><span
>、</span><span>Palm OS</span><span
>和</span><span>Windows CE</span><span
>。它可以无缝地工作在</span><span>16-bit</span><span
>、</span><span>32-bit</span><span
>和</span><span>64-bit</span><span
>体系结构中并且能同时适应字节的大端格式和小端格式。</span><span>SQLite</span><span
>的兼容性并不只表现在代码上，还表现在其数据库文件上。</span><span>SQLite</span><span
>的数据库文件在其所支持的所有操作系统、硬件体系结构和字节顺序上都是二进制一致的。你可以在</span><span>Sun SPARC</span><span >工作站上创建一个</span><span>SQLite</span><span >数据库然后在</span><span>Mac</span><span >或</span><span>Windows</span><span
>的机器上――甚至移动电话上――使用它，而不需要做任何转换和修改。此外，</span><span>SQLite</span><span >数据库可以支撑</span><span>2TB</span><span >的数据量</span><span>(</span><span
>受操作系统限制</span><span>)</span><span
>，还内置地同时支持</span><span>UTF-8</span><span
>和</span><span>UTF-16</span><span
>编码。</span></p>
  <h3><a name="_Toc245565749"><span >紧凑性</span></a></h3>
  <p><span>SQLite</span><span >的设计可以说是功能齐全但体积很小：</span><span>1</span><span >个头文件，</span><span>1</span><span
>个库，不需要扩展的数据库服务。所有的东西，包括客户端、服务器和虚拟机等，都被打包在</span><span>1/4</span><span >兆大小之内。如果在编译时去掉一些不需要的特性，程序库可以缩小至</span><span>170KB (</span><span >在</span><span>x86</span><span
>硬件平台上使用</span><span>GNU C</span><span
>进行编译</span><span>)</span><span
>。此外，还有一个</span><span>SQLite</span><span
>的私有版本，大小是</span><span>69KB</span><span
>，可以运行在智能卡上</span><span>(</span><span
>参“附加信息”一节</span><span>)</span><span
>。</span></p>
  <p><span >空注：我下载的</span><span>DLL</span><span
>有</span><span>500</span><span
>多</span><span>KB</span><span
>。</span></p>
  <h3><a name="_Toc245565750"><span >简单</span></a></h3>
  <p><span >作为程序库，</span><span>SQLite</span><span
>的</span><span>API</span><span
>可以算是最简单最易用的了。</span><span>SQLite</span><span
>既有很好的文档又很容易望文知意。</span><span> </span></p>
  <h3><a name="_Toc245565751"><span >适应性</span></a></h3>
  <p><span>SQLite</span><span >的几个特性使其成为一个适应性极强的数据库。作为一个内嵌式的数据库，</span><span>SQLite</span><span >在以下两个方面都做得最好：强有力而可伸缩的关系型数据库前端，简单而紧凑的</span><span>B-tree</span><span >后端。</span><span> </span></p>
  <h3><a name="_Toc245565752"><span >不受拘束的授权</span></a></h3>
  <p><span>SQLite</span><span >的全部代码都在公共域中，不需要授权。</span><span>SQLite</span><span >的任何一部分都没有附加版权要求。所有曾经为</span><span>SQLite</span><span >项目贡献过代码的人都签署过一个宣誓书将他们的贡献发布到公共域。也就是说，无论你如何使用</span><span>SQLite</span><span >的代码都不会有法律方面的限制。你可以修改、合并、发布、出售或将这些代码用于任何目的，商业和中非商业的，不需要支付任何费用，不会受到任何限制。</span></p>
  <h3><a name="_Toc245565753"><span >可靠性</span></a></h3>
  <p><span>SQLite</span><span >的源代码不但免费，还编写得很好。</span><span>SQLite</span><span >源代码包含大约</span><span>30000</span><span >行标准</span><span>C</span><span
>代码，它是干净的、模块化的和完好注释的。</span><span>SQLite</span><span
>源代码易理解、易定制。</span><span> </span></p>
  <p><span>SQLite</span><span >的核心软件</span><span>(</span><span >库和工具</span><span>)</span><span
>由约</span><span>30000</span><span
>行代码组成，但分发的程序中还包含有超过</span><span>30000</span><span
>行的回归测试代码，它们覆盖了</span><span>97%</span><span
>的核心代码。也就是说，超过一半的</span><span>SQLite</span><span
>项目代码是专门用于回归测试的，也就是说，差不多每写一行功能代码，都要写一行测试代码对它进行测试。</span></p>
  <h3><a name="_Toc245565754"><span >易用性</span></a></h3>
  <p><span>SQLite</span><span >还提供一些独特的功能来提高易用性，包括动态类型、冲突解决和“附加”多个数据库到一个连接的能力。</span></p>
  <h2><a name="_Toc245565755"><span style='font-family:黑体'>性能和限制</span></a></h2>
  <p><span>SQLite</span><span >是一个快速数据库。但“快速”这个词本身是一个主观的和不明确的词。诚实地讲，有些事情</span><span>SQLite</span><span >能比其它数据库做得快，也有些事情不能。这么说吧，利用</span><span>SQLite</span><span >提供的配置参数，</span><span>SQLite</span><span >是足够快速和高效的。跟大多数其它数据库一样，</span><span>SQLite</span><span >使用</span><span>B-tree</span><span
>处理索引，使用</span><span>B+tree</span><span
>处理表数据。因此，在对单表进行查询时，</span><span>SQLite</span><span
>要快于</span><span>(</span><span
>或至少相当于</span><span>)</span><span
>其它数据库的速度。</span></p>
  <p><span >在一些情况下</span><span>SQLite</span><span
>可能不如大型数据库快，但大多数这些情况是可理解的。</span><span>SQLite</span><span
>是一个内嵌式的数据库，设计用于中小规模的应用程序。这些限制是符合设计目的的。很多新用户错误地假设使用</span><span>SQLite</span><span >可以代替大型关系型数据库，这有时行，但有时不行，依赖于你准备用</span><span>SQLite</span><span >来做什么。一般情况下，</span><span>SQLite</span><span >在三个主要的方面具有局限性：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >并发。</span><span> </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >数据库大小。</span><span> </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >网络。</span></p>
  <p><span >尽管</span><span>SQLite</span><span
>做得已经很好了，但仍有部分特性未能实现，包括：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >外键约束</span><br>
    <span >空注：</span><span>SQLite</span><span
>的最新版本</span><span>3.6.19</span><span >好像已经支持了。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >完整的触发器支持。</span><span> </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >完整的</span><span>ALTER
    TABLE</span><span >支持。</span><span> </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >事务嵌套。</span><span> </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>RIGHT</span><span >和</span><span>FULL OUTER JOIN</span><span >。</span><span> </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >可修改视图。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>GRANT</span><span >和</span><span>REVOKE</span><span >。</span></p>
  <h2><a name="_Toc245565756"><span style='font-family:黑体'>附加信息</span></a></h2>
  <p><span>SQLite</span><span >网站有丰富的信息，包括官方文档、邮件列表、</span><span>Wiki</span><span >和其它的一般信息，它的网址是</span><span>www.sqlite.org</span><span >。</span><span>SQLite</span><span >社区也是很有帮助的，你可能从邮件列表中找到任何你所需要的东西。另外，</span><span>SQLite</span><span >的作者提供了</span><span>SQLite</span><span >的专业培训和支持，包括定制程序</span><span>(</span><span >如移植到嵌入式平台</span><span>)</span><span >和增强的</span><span>SQLite</span><span
>版本，这些版本包括内置了加密功能的版本和为嵌入式应用优化的极小化版本。更多的信息可以从</span><span>www.hwaci.com/sw/sqlite/prosupport.html</span><span
>中找到。</span></p>
  <br
clear=all style='page-break-before:always'>
  <h1><a name="_Toc245565757"><span >第</span><span>2</span></a><span >章</span><span>&nbsp; </span><span >入门</span></h1>
  <p><span >无论您使用何种操作系统，</span><span>SQLite</span><span >都很容易上手。对大多数用户，安装</span><span>SQLite</span><span >并创建一个新的数据库不会超过</span><span>5</span><span >分钟，且不需要任何经验。</span></p>
  <p><span >空注：本章我只看了</span><span>Windows</span><span >操作系统下使用</span><span>VC</span><span >的内容。</span></p>
  <h2><a name="_Toc245565758"><span style='font-family:黑体'>从哪得到</span><span>SQLite</span></a></h2>
  <p><span>SQLite</span><span >网站</span><span>(www.sqlite.org)</span><span >同时提供</span><span>SQLite</span><span >的已编译版本和源程序。编译版本可同时适用于</span><span>Windows</span><span >和</span><span>Linux</span><span
>。</span></p>
  <p><span >有几种形式的二进制包供选择，以适应</span><span>SQLite</span><span >的不同使用方式。包括：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >静态链接的命令行程序</span><span>(CLP)</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>SQLite</span><span >动态链接库</span><span>(DLL)</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>Tcl</span><span >扩展</span></p>
  <p><span>SQLite</span><span >源代码以两种形式提供，以适应不同的平台。一种为了在</span><span>Windows</span><span >下编译，另一种为了在</span><span>POSIX</span><span >平台</span><span>(</span><span
>如</span><span>Linux, BSD, and Solaris)</span><span
>下编译，这两种形式下源代码本身是没有差别的。</span><span> </span></p>
  <h2><a name="_Toc245565759"><span style='font-family:黑体'>在</span><span>Windows</span></a><span style='font-family:黑体'>上使用</span><span>SQLite</span></h2>
  <p><span >无论你是作为终端用户还是作为程序员来使用</span><span>SQLite</span><span >，</span><span>SQLite</span><span
>都可以很容易地安装在</span><span>Windows</span><span
>环境下。本节我们将讨论所有相关的内容――安装二进制包或在最普通的编译环境下使用源代码。</span></p>
  <h3><a name="_Toc245565760"><span >获得命令行程序</span></a></h3>
  <p><span>SQLite</span><span >命令行程序</span><span>(CLP)</span><span >是开始使用</span><span>SQLite</span><span >的一个比较好的选择。</span></p>
  <p><span >略，参原文。</span></p>
  <h3><a name="_Toc245565761"><span >获得</span><span>SQLite</span></a><span >的动态链接库</span><span>(DLL)</span></h3>
  <p><span>SQLite</span><span >的</span><span>DLL</span><span >文件供编译好的程序动态连接</span><span>SQLite</span><span >。大多数使用</span><span>SQLite</span><span >的软件都会拥有自己的</span><span>SQLite DLL</span><span >拷贝并随软件自动安装。</span></p>
  <h3><a name="_Toc245565762"><span >在</span><span>Windows</span></a><span >环境下编译</span><span>SQLite</span><span >源代码</span></h3>
  <p><span >在</span><span>Windows</span><span
>环境下编译</span><span>SQLite</span><span
>源代码是很简单的。根据你所使用的编译器和你要做什么，有几种方法来编译</span><span>SQLite</span><span >。最常见的环境是</span><span>Microsoft Visual C++</span><span >或</span><span>MinGW</span><span >，本节都会加以介绍。关于使用其它编译器编译</span><span>SQLite</span><span >的内容，可参考</span><span>SQLite Wiki (www.sqlite.org/cvstrac/wiki?p=HowToCompile)</span><span
>。</span></p>
  <h3><a name="_Toc245565763"><span >用</span><span>Microsoft Visual C++</span></a><span >构建</span><span>SQLite DLL</span></h3>
  <p><span >通过以下步聚，可使用源代码，在</span><span>Visual C++</span><span >上构建</span><span>SQLite DLL</span><span >：</span></p>
  <p><span>1. </span><span >启动</span><span>Visual Studio</span><span >。在解包的</span><span>SQLite</span><span >源程序目录中创建一个新的</span><span>DLL</span><span >“空”项目。</span></p>
  <p><span >高：不同版本操作略有不同，不详细解释了。</span></p>
  <p><span>2. </span><span >将全部</span><span>SQLite</span><span >源文件加入到项目中来。包括所有的</span><span>.c</span><span >文件和</span><span>.h</span><span
>文件。除了：</span></p>
  <p><span>shell.c</span><span style='font-family:
宋体'>：该文件包括</span><span>main()</span><span >函数，用于创建</span><span>CLP</span><span >可执行程序。</span></p>
  <p><span>tclsqlite.c</span><span style='font-family:
宋体'>：该文件用于</span><span>TCL</span><span >支持。</span></p>
  <p><span >空注：我使用的版本</span><span>(sqlite-source-3_6_18.zip)</span><span >有些函数有重复定义，还得去掉两个文件，不知会引起什么后果，它们是</span><span>fts3.c</span><span >和</span><span>fts3_tokenizer.c</span><span
>。</span></p>
  <p><span>3. </span><span >执行构建</span><span>(Build)</span><span >命令，</span><span>OK</span><span >。</span></p>
  <p><span >还可以选择构建线程完全的</span><span>DLL</span><span >或发布</span><span> (Release) </span><span >版的</span><span>DLL</span><span
>，参原文。</span></p>
  <h3><a name="_Toc245565764"><span >用</span><span>Microsoft Visual C++</span></a><span >构建</span><span>SQLite CLP</span></h3>
  <p><span >方法基本同上。</span></p>
  <p><span >创建项目时选择</span><span>Win32
    Console Application</span><span >，添加文件时把</span><span>shell.c</span><span >也加上，即可。</span></p>
  <h2><a name="_Toc245565765"><span style='font-family:黑体'>使用</span><span>SQLite</span></a><span style='font-family:黑体'>数据库</span></h2>
  <p><span>SQLite</span><span >的</span><span>CLP</span><span >是使用和管理</span><span>SQLite</span><span >数据库最常用的方法。</span></p>
  <p><span >它可运行于多种平台，学会使用</span><span>CLP</span><span >，可以保证你永远有一个通用和熟悉的途径来管理你的数据库。</span><span>CLP</span><span >其实是两个程序。它可以运行在命令行模式下完成各种数据库管理任务，也可以运行在</span><span>Shell</span><span >模式下，以交互的方式执行查询操作。</span></p>
  <h3><a name="_Toc245565766"><span>Shell</span></a><span
>模式下使用</span><span>CLP</span></h3>
  <p><span >运行</span><span>DOS shell</span><span
>，进入工作目录，在命令行上键入</span><span>sqlite3</span><span
>命令，命令后跟随一个可选的数据库文件名。如果在命令行上不指定数据库名，</span><span>SQLite</span><span >将会使用一个内存数据库，其内容在退出</span><span>CLP</span><span >时将会丢失。</span></p>
  <p><span>CLP</span><span >以交互形式运行，你可以在其上执行查询、获得</span><span>schema</span><span >信息、导入</span><span>/</span><span >导出数据和执行其它各种各样的数据库任务。</span><span>CLP</span><span >认为你输入的任何语句都是一个查询命令</span><span>(query)</span><span >，除非命令是以点</span><span>(.)</span><span >开始，这些命令用于特殊操作。键入</span><span>.help</span><span >或</span><span>.h</span><span
>可以得到这些操作的完整列表。键入</span><span>.exit </span><span
>或</span><span>.e</span><span
>退出</span><span>CLP</span><span
>。</span></p>
  <p><span >让我们从创建一个称为</span><span>test.db</span><span >的数据库开始。在</span><span>DOS shell</span><span >下键入：</span></p>
  <p><span>sqlite3 test.db</span></p>
  <p><span >尽管我们提供了数据库名，但如果这个数据库并不存在，</span><span>SQLite</span><span >并不会真正地创建它。</span><span>SQLite</span><span >会等到你真正地向其中增加了数据库对象之后才创建它，比如在其中创建了表或视图。这样做的原因是给你机会在将数据库写到外部文件之前对数据库做一些永久性的设置，如页的大小等。有些设置，如页大小、字符集</span><span>(UTF-8</span><span >或</span><span>UTF-16)</span><span
>等，一旦数据库创建之后就不能再修改了。这个中间期是你能改它们的唯一机会。我们采用默认设置，因此，要将数据库写到磁盘，我们仅需要在其中创建一个表。输入如下语句：</span></p>
  <p><span>sqlite&gt; create table test (id integer
    primary key, value text); </span></p>
  <p><span >现在你有了一个称为</span><span>test.db</span><span >的数据库文件，其中包含一个表</span><span>test</span><span >，该表包含两个字段。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >一个称为</span><span>id</span><span
>的主键字段</span><span>,</span><span
>它带有自动增长属性。无论何时你定义一个整型主键字段，</span><span>SQLite </span><span >都会对该字段应用自动增长属性。</span><span> </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >一个简单的称为</span><span>value</span><span
>的文本字段。</span></p>
  <p><span >向表中插入几行数据：</span></p>
  <p><span>sqlite&gt; insert into test (value)
    values('eenie'); </span></p>
  <p><span>sqlite&gt; insert into test (value)
    values('meenie'); </span></p>
  <p><span>sqlite&gt; insert into test (value)
    values('miny'); </span></p>
  <p><span>sqlite&gt; insert into test (value)
    values('mo'); </span></p>
  <p><span >将插入的数据取回：</span></p>
  <p><span  style='color:#CC0000'>sqlite&gt; .mode col </span></p>
  <p><span  style='color:#CC0000'>sqlite&gt; .headers
    on </span></p>
  <p><span>sqlite&gt; SELECT * FROM test; </span></p>
  <p><span >系统显示：</span></p>
  <p><span>id value </span></p>
  <p><span>1 eenie </span></p>
  <p><span>2 meenie </span></p>
  <p><span>3 miny </span></p>
  <p><span>4 mo </span></p>
  <p><span>SELECT</span><span >语句前的两个命令</span><span>(.headers and .mode)</span><span >用于改进输出的格式。可以看到</span><span>SQLite</span><span >为</span><span>id</span><span
>字段赋予了连接的整数值，而这些值我们在</span><span>INSERT</span><span
>语句中并没的提供。对于自动增长的字段，你可能会关心最后插入的一条记录该字段的取值，此值可以用</span><span>SQL</span><span >函数</span><span 
style='color:#CC0000'>last_insert_rowid()</span><span >得到。</span></p>
  <p><span>sqlite&gt; select last_insert_rowid(); </span></p>
  <p><span>last_insert_rowid() </span></p>
  <p><span>4 </span></p>
  <p><span >在退出</span><span>CLP</span><span
>之前，让我们来为数据库创建一个索引和一个视图，后面的内容中将会用到它们。</span></p>
  <p><span>sqlite&gt; create index test_idx on test
    (value); </span></p>
  <p><span>sqlite&gt; create view schema as select *
    from sqlite_master; </span></p>
  <p><span >使用</span><span>.exit</span><span
>命令退出</span><span>CLP</span><span
>。</span></p>
  <p><span>sqlite&gt; .exit </span></p>
  <p><span>C:\Temp&gt; </span></p>
  <h4><span style='font-family:黑体'>获得数据库的</span><span>Schema</span><span
style='font-family:黑体'>信息</span></h4>
  <p><span >有几个</span><span>shell</span><span
>命令用于获得有关数据库内容的信息。你可以键入命令</span><span>.tables
    [pattern]</span><span >来得到所有表和视图的列表，其中</span><span>[pattern]</span><span >可以是任何类</span><span>SQL</span><span >的操作符。执行上述命令会返回符合条件的所有表和视图，如果没有</span><span>pattern</span><span >项，返回所有表和视图。</span></p>
  <p><span>sqlite&gt; .tables </span></p>
  <p><span>schema test </span></p>
  <p><span >可以看到我们创建的表</span><span>test</span><span >和视图</span><span>schema</span><span
>。同样的，要显示一个表的索引，可以键入命令</span><span>.indices
    [table name]</span><span >：</span></p>
  <p><span>sqlite&gt; .indices test </span></p>
  <p><span>test_idx </span></p>
  <p><span >可以看到我们为表</span><span>test</span><span >所创建的名为</span><span>test_idx</span><span >的索引。使用</span><span>.schema [table name]</span><span >可以得到一个表或视图的定义</span><span>(DDL)</span><span >语句。如果没提供表名，则返回所有数据库对象</span><span>(</span><span >包括</span><span>table</span><span
>、</span><span>indexe</span><span
>、</span><span>view</span><span
>和</span><span>index)</span><span
>的定义语句：</span></p>
  <p><span>sqlite&gt; .schema test </span></p>
  <p><span>CREATE TABLE test (id integer primary key,
    value text); </span></p>
  <p><span>CREATE INDEX test_idx on test (value); </span></p>
  <p><span>sqlite&gt; .schema </span></p>
  <p><span>CREATE TABLE test (id integer primary key,
    value text); </span></p>
  <p><span>CREATE VIEW schema as select * from
    sqlite_master; </span></p>
  <p><span>CREATE INDEX test_idx on test (value); </span></p>
  <p><span >更详细的</span><span>schema</span><span
>信息可以通过</span><span>SQLite</span><span
>唯一的一个系统视图</span><span>sqlite_master</span><span
>得到。这个视图是一个系统目录，它的结构如表</span><span>2-1</span><span
>所示。</span></p>
  <p><span >表</span><span>2-1 sqlite_master</span><span
>表结构</span></p>
  <table border=1 cellspacing=0 cellpadding=0>
    <tr>
      <td width=48 valign=top><p align=center style='text-align:center'><span
  >编号</span></p></td>
      <td width=108 valign=top><p align=center style='text-align:center'><span
  >字段</span></p></td>
      <td width=405 valign=top><p align=center style='text-align:center'><span
  >说明</span></p></td>
    </tr>
    <tr>
      <td width=48 valign=top><p><span>1</span></p></td>
      <td width=108 valign=top><p><span>type</span></p></td>
      <td width=405 valign=top><p><span >值为</span><span>&quot;table&quot;</span><span
  >、</span><span> &quot;index&quot;</span><span
  >、</span><span> &quot;trigger&quot;</span><span
  >或</span><span>&quot;view&quot;</span><span
  >之一。</span></p></td>
    </tr>
    <tr>
      <td width=48 valign=top><p><span>2</span></p></td>
      <td width=108 valign=top><p><span>name</span></p></td>
      <td width=405 valign=top><p><span >对象名称，值为字符串。</span></p></td>
    </tr>
    <tr>
      <td width=48 valign=top><p><span>3</span></p></td>
      <td width=108 valign=top><p><span>tbl_name</span></p></td>
      <td width=405 valign=top><p><span >如果是表或视图对象，此字段值与字段</span><span>2</span><span >相同。如果是索引或触发器对象，此字段值为与其相关的表名。</span></p></td>
    </tr>
    <tr>
      <td width=48 valign=top><p><span>4</span></p></td>
      <td width=108 valign=top><p><span>rootpage</span></p></td>
      <td width=405 valign=top><p><span >对触发器或视图对象，此字段值为</span><span>0</span><span >。对表或索引对象，此字段值为其根页的编号。</span></p></td>
    </tr>
    <tr>
      <td width=48 valign=top><p><span>5</span></p></td>
      <td width=108 valign=top><p><span>SQL</span></p></td>
      <td width=405 valign=top><p><span >字符串，创建此对象时所使用的</span><span>SQL</span><span >语句。</span></p></td>
    </tr>
  </table>
  <p><span >查询当前数据库的</span><span>sqlite_master</span><span >表，返回：</span></p>
  <p><span>sqlite&gt; .mode col </span></p>
  <p><span>sqlite&gt; .headers on </span></p>
  <p><span>sqlite&gt; select type, name, tbl_name, sql
    from sqlite_master order by type; </span></p>
  <p><span>type &nbsp;&nbsp;name
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbl_name &nbsp;&nbsp;sql</span></p>
  <p><span>---------</span></p>
  <p><span>index &nbsp;test_idx
    &nbsp;&nbsp;test &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CREATE INDEX test_idx on
    test (value)</span></p>
  <p><span>table &nbsp;test &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CREATE TABLE test (id integer primary</span></p>
  <p><span>view &nbsp;&nbsp;schema
    &nbsp;&nbsp;&nbsp;&nbsp;schema &nbsp;&nbsp;&nbsp;&nbsp;CREATE VIEW schema as
    select * from s</span></p>
  <p><span >■</span><span>Tip</span><span
>：使用向上的箭头键可以回滚到前面输入过的命令。</span><span> </span></p>
  <h4><span style='font-family:黑体'>数据导出</span></h4>
  <p><span >可以使用</span><span>.dump</span><span
>命令将数据库导出为</span><span>SQL</span><span
>格式的文件。不使用任何参数，</span><span>.dump</span><span
>将导出整个数据库。如果提供参数，</span><span>CLP</span><span
>把参数理解为表名或视图名。</span></p>
  <p><span>sqlite&gt; .output file.sql </span></p>
  <p><span>sqlite&gt; .dump </span></p>
  <p><span>sqlite&gt; .output stdout </span></p>
  <h4><span style='font-family:黑体'>数据导入</span></h4>
  <p><span >有两种方法可以导入数据，用哪种方法决定于要导入的文件的格式。如果文件由</span><span>SQL</span><span >语句构成，可以使用</span><span
 style='color:#CC0000'>.read</span><span >命令导入</span><span>(</span><span >执行</span><span>)</span><span
>文件。如果文件是由逗号或其它定界符分隔的值</span><span>(comma-separated
    values, CSV)</span><span >组成，可使用</span><span 
style='color:#CC0000'>.import </span><span>[file][table]</span><span
>命令。此命令将解析指定的文件并尝试将数据插入到指定的表中。</span></p>
  <p><span>sqlite&gt; .show</span></p>
  <p><span>echo: off </span></p>
  <p><span>explain: off </span></p>
  <p><span>headers: on</span></p>
  <p><span>mode: column </span></p>
  <p><span>nullvalue: &quot;&quot; </span></p>
  <p><span>output: stdout </span></p>
  <p><span>separator: &quot;|&quot; </span></p>
  <p><span>width: </span></p>
  <p><span>.read</span><span >命令用来导入由</span><span>.dump</span><span >命令创建的文件。如果要使用前面作为备份文件所导出的</span><span>file.sql</span><span >，需要先移除已经存在的数据库对象</span><span>(test</span><span >表和</span><span>schema</span><span
>视图</span><span>)</span><span
>，然后用下面方法导入：</span></p>
  <p><span>sqlite&gt; drop table test; </span></p>
  <p><span>sqlite&gt; drop view schema; </span></p>
  <p><span>sqlite&gt; .read file.sql</span></p>
  <h4><span style='font-family:黑体'>格式化</span></h4>
  <p><span>CLP</span><span >提供了几个格式化选项命令。最简单的是</span><span
 style='color:#CC0000'>.echo</span><span>, </span><span
>如果设置</span><span>.echo on</span><span
>，则新输入的命令在执行前都会回显，默认值是</span><span>off</span><span
>。</span><span  style='color:#CC0000'>.headers</span><span
>设置为</span><span>on</span><span
>时，查询结果显示时带有字段名。当遇到</span><span>NULL</span><span
>值时，如果需要以一个字符串来显示，使用</span><span 
style='color:#CC0000'>.nullvalue</span><span >命令设置，如：</span></p>
  <p><span>sqlite&gt; .nullvalue NULL</span></p>
  <p><span >默认情况下使用空串。如果要改变</span><span>CLP</span><span >的</span><span>shell</span><span
>提示符，使用</span><span  style='color:#CC0000'>.prompt</span><span> [value]</span><span >，如：</span></p>
  <p><span>sqlite&gt; .prompt 'sqlite3&gt; '</span></p>
  <p><span>sqlite3&gt;</span></p>
  <p><span>.mode</span><span >命令可以设置结果数据的几种输出格式。可选的格式为</span><span>csv</span><span >、</span><span>column</span><span
>、</span><span>html</span><span
>、</span><span>insert</span><span
>、</span><span>line</span><span
>、</span><span>list</span><span
>、</span><span>tabs</span><span
>和</span><span>tcl</span><span
>。默认值是</span><span>list</span><span
>，在此模式下显示结果时列间以默认的分隔符分隔。如果你想以</span><span>CSV</span><span
>格式输出一个表的数据，可如下操作：</span></p>
  <p><span>sqlite3&gt; .output file.csv </span></p>
  <p><span>sqlite3&gt; .separator ,</span></p>
  <p><span>sqlite3&gt; select * from test;</span></p>
  <p><span>sqlite3&gt; .output stdout</span></p>
  <p><span >文件</span><span>file.csv</span><span
>的内容为：</span></p>
  <p><span>1,eenie</span></p>
  <p><span>2,meenie</span></p>
  <p><span>3,miny</span></p>
  <p><span>4,mo</span></p>
  <p><span >因为有一个</span><span>CSV</span><span
>模式，所以下面的命令会得到相似的结果：</span></p>
  <p><span>sqlite3&gt; .output file.csv </span></p>
  <p><span>sqlite3&gt; .mode csv</span></p>
  <p><span>sqlite3&gt; select * from test;</span></p>
  <p><span>sqlite3&gt; .output stdout</span></p>
  <h3><a name="_Toc245565767"><span >在命令行方式下执行</span><span>CLP</span></a><span> </span></h3>
  <p><span >在</span><span>DOS</span><span
>或</span><span>UNIX</span><span
>的命令行方式下，直接执行</span><span>SQLite</span><span
>的数据库操作。</span></p>
  <h2><a name="_Toc245565768"><span style='font-family:黑体'>数据库管理</span></a></h2>
  <p><span >所有的数据库管理任务都可以在</span><span>shell</span><span >和命令行模式下完成。</span></p>
  <h3><a name="_Toc245565769"><span >创建、备份和删除数据库</span></a></h3>
  <p><span >数据库的备份有两种方法。第</span><span>1</span><span >种是使用</span><span>.dump</span><span
>，可得到</span><span>SQL</span><span
>格式的文件。在命令行方式下可如下做：</span></p>
  <p><span>sqlite3 test.db .dump &gt; test.sql</span></p>
  <p><span >在</span><span>CLP</span><span
>中可如下做：</span></p>
  <p><span>sqlite&gt; .output file.sql</span></p>
  <p><span>sqlite&gt; .dump</span></p>
  <p><span>sqlite&gt; .exit</span></p>
  <p><span >相应地，导入一个</span><span>SQL</span><span >格式备份的数据库可如下做：</span></p>
  <p><span>sqlite3 test.db &lt; test.sql</span></p>
  <p><span >此处假设</span><span>test.db</span><span
>不存在。如果它存在，则或许会因为数据库中有同名的对象而出错。</span></p>
  <p><span >可以用复制的方法得到一个二进制的数据库文件拷贝。但也许在复制之前你想先抽空</span><span>(vacuum)</span><span >它，也就是释放数据库文件中未使用的空间，以得到一个更小的数据库文件。可操作如下：</span></p>
  <p><span>sqlite3 test.db VACUUM</span></p>
  <p><span>cp test.db test.backup</span></p>
  <p><span >一般情况下，二进制的备份如不</span><span>SQL</span><span >备份兼容性好。尽管</span><span>SQLite</span><span >有很好的向上兼容性和各操作系统间文件格式的一致性，但如果想要将备份文件保留很长时间，还是</span><span>SQL</span><span >格式保险一些。</span></p>
  <p><span >当一个数据库你不想再用时，简单地从操作系统中将其文件删除就行了。</span></p>
  <h3><a name="_Toc245565770"><span >获得数据库文件的信息</span></a></h3>
  <p><span >按前文所述，获得数据库信息的主要途径是使用</span><span>sqlite_master</span><span >视图，它提供一个数据库所包含的所有对象的细节信息。</span></p>
  <p><span >如果你想获得关于物理的数据库结构信息，可以使用一个称为</span><span>SQLite Analyzer</span><span >的工具，它可以在</span><span>SQLite</span><span >网站上下载得到。</span><span>SQLite Analyzer</span><span >可以提供磁盘</span><span>SQLite</span><span >数据库的详细技术信息。</span></p>
  <p><span>(</span><span >输出结果略</span><span>)</span></p>
  <h2><a name="_Toc245565771"><span style='font-family:黑体'>其它</span><span>SQLite</span></a><span style='font-family:黑体'>工具</span></h2>
  <p><span >有很多其它开源的或商业的程序可工作于</span><span>SQLite</span><span >，其中具有优秀图形化界面且跨平台的有：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>SQLite Database Browser
    (http://sqlitebrowser.sourceforge.net) </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>SQLite</span><span> Control Center</span><span> (http://bobmanc.home.comcast.net/sqlitecc.html) </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>SQLiteManager (www.sqlabs.net/sqlitemanager.php) </span></p>
  <br
clear=all style='page-break-before:always'>
  <h1><a name="_Toc245565772"><span >第</span><span>3</span></a><span >章</span><span>&nbsp; </span><span >关系模型</span></h1>
  <p><span>SQL</span><span >具有非常实用的外观和非常理论化的内涵，这个内涵就是关系模型。关系模型早于</span><span>SQL</span><span >出现并对</span><span>SQL</span><span
>的出现提出了需求。</span><span>SQL</span><span
>的原动力不在语言本身，而是深藏在关系模型的概念当中。这些概念构成了</span><span>SQL</span><span >设计和操作的基础。</span></p>
  <p><span >空注：数据库基本理论，参考其它书吧。</span></p>
  <br
clear=all style='page-break-before:always'>
  <h1><a name="_Toc245565773"><span >第</span><span>4</span></a><span >章</span><span>&nbsp;
    SQL</span></h1>
  <p><span >本章介绍</span><span>SQL</span><span
>的基本内容和</span><span>SQLite</span><span
>的特殊实现。本章内容的编排假设你没有</span><span>SQL</span><span
>和关系模型的基础知识。如果你是</span><span>SQL</span><span
>新手，</span><span>SQLite</span><span
>将带你进入关系模型的精彩世界。</span></p>
  <p><span >空注：使用过很多种数据库，所以本章只关注</span><span>SQLite</span><span >与其它</span><span>DBMS</span><span >不同的地方，如弱类型什么的。</span></p>
  <h2><a name="_Toc245565774"><span style='font-family:黑体'>关系模型</span></a></h2>
  <p><span >如第</span><span>3</span><span
>章所述，</span><span>SQL</span><span
>是关系模型的产物，关系模型是由</span><span>E. F. Codd</span><span
>在</span><span>1969</span><span
>年提出的。关系模型要求关系型数据库能够提供一种查询语言，几年后，</span><span>SQL</span><span
>应运而生。</span></p>
  <p><span >关系模型由三部分构成：表单</span><span>(form)</span><span >、功能</span><span>(function)</span><span >和一致性</span><span>(consistency)</span><span >。表单表示信息的结构。在关系模型中只使用一种单独的数据结构来表达所有信息，这种结构称为关系</span><span>(relation</span><span >，在</span><span>SQL</span><span >中被称为表、</span><span>table)</span><span >。关系由多个元组</span><span>(tuples</span><span >，在</span><span>SQL</span><span >中被称为行、记录、</span><span>rows)</span><span >构成，每个元组又由多个属性</span><span>(attributes</span><span >，在</span><span>SQL</span><span >中被称为列、字段、</span><span>columns)</span><span >构成。</span></p>
  <h3><a name="_Toc245565775"><span >查询语言</span></a></h3>
  <p><span >查询语言将外部世界和数据的逻辑表现联系在一起，并使它们能够交互。它提供了取数据和修改数据的途径，是关系模型的动态部分。</span></p>
  <h3><a name="_Toc245565776"><span>SQL</span></a><span
>的发展</span></h3>
  <p><span >第一个被采用的此类查询语言可能是在</span><span>IBM</span><span >的</span><span>System
    R</span><span >当中。</span><span>System R</span><span
>是一个关系型数据库的研究项目，此项目直接派生出了</span><span>Codd</span><span
>的论文。这个语言开始时被称作</span><span>SEQUEL</span><span
>，是</span><span>“Structured English Query
    Language”</span><span >的缩写。后来被缩短为</span><span>SQL</span><span
>，或</span><span>“Structured Query Language”</span><span
>。</span></p>
  <h2><a name="_Toc245565777"><span style='font-family:黑体'>示例数据库</span></a></h2>
  <p><span >示例数据库在本章和后面的章节中将会用到，其中存储了</span><span>Seinfeld</span><span >所有</span><span>episode(</span><span >约</span><span>180</span><span >个</span><span>)</span><span
>的食品</span><span>(</span><span
>约</span><span>412</span><span
>种</span><span>)</span><span style='font-family:
宋体'>。数据库中的表如图</span><span>4-1</span><span >所示。</span></p>
  <p><span><img width=553 height=94
src="Definitive Guide/image003.jpg"></span></p>
  <p><span >图</span><span>4-1 Seinfeld</span><span
>食品数据库</span></p>
  <p><span >数据库的</span><span>schema</span><span
>定义如下：</span></p>
  <p><span>create table episodes (</span></p>
  <p><span>&nbsp;&nbsp;id integer primary key, </span></p>
  <p><span>&nbsp; season int, </span></p>
  <p><span>&nbsp; name text ); </span></p>
  <p><span>create table foods(</span></p>
  <p><span>&nbsp; id integer primary key,</span></p>
  <p><span>&nbsp; type_id integer, </span></p>
  <p><span>&nbsp; name text );</span></p>
  <p><span>create table food_types(</span></p>
  <p><span>&nbsp; id integer primary key, </span></p>
  <p><span>&nbsp; name text );</span></p>
  <p><span>&nbsp; create table foods_episodes(</span></p>
  <p><span>&nbsp; food_id integer, </span></p>
  <p><span>&nbsp; episode_id integer );</span></p>
  <p><span >主表是</span><span>foods</span><span
>。</span><span>foods</span><span
>中的每条记录代表一种食品，其名称存储于</span><span>name</span><span
>字段。</span><span>type_id</span><span
>参照</span><span>food_types</span><span
>，</span><span>food_types</span><span
>表存储了食品的分类</span><span>(</span><span
>如烘烤食品、饮品、垃圾食品等</span><span>)</span><span
>。</span><span>foods_episodes</span><span
>表是</span><span>foods</span><span
>和</span><span>episodes</span><span
>的关联表。</span></p>
  <h3><a name="_Toc245565778"><span >建立</span></a></h3>
  <p><span >示例数据库文件可在随书的</span><span>zip</span><span >文件中找到。</span><span> </span></p>
  <h3><a name="_Toc245565779"><span >运行示例</span></a></h3>
  <p><span >为了您的方便，本章的所有</span><span>SQL</span><span >示例都保存在随书</span><span>zip</span><span >文件根目录的</span><span>sql.sql</span><span >文件中。</span></p>
  <p><span >对于长</span><span>SQL</span><span
>语句，一个方便的执行方法是将其复制到一个单独的文本文件，如</span><span>test.sql</span><span
>中，然后执行：</span></p>
  <p><span>sqlite3 foods.db &lt; test.sql </span></p>
  <p><span >为了增加输出的易读性，你应用把下面内容包含在文件中：</span></p>
  <p><span>.echo on </span></p>
  <p><span>.mode col </span></p>
  <p><span>.headers on </span></p>
  <p><span>.nullvalue NULL </span></p>
  <h2><a name="_Toc245565780"><span style='font-family:黑体'>语法</span></a></h2>
  <p><span>SQL</span><span >的语法很像自然语言。每个语句都是一个祈使句，以动词开头，表示所要做的动作。后面跟的是主题和谓词，如图</span><span>4-2</span><span >所示。</span></p>
  <p><span><img width=270 height=61
src="Definitive Guide/image004.jpg"></span></p>
  <p><span >图</span><span> 4-2 </span><span
>一般的</span><span>SQL</span><span
>语法结构</span></p>
  <h3><a name="_Toc245565781"><span >命令</span></a></h3>
  <p><span>SQL</span><span >由命令组成，每个命令以分号</span><span>(;)</span><span >结束。如下面是</span><span>3</span><span >个独立的命令：</span></p>
  <p><span>SELECT id, name FROM foods;</span></p>
  <p><span>INSERT INTO foods VALUES (NULL,
    'Whataburger');</span></p>
  <p><span>DELETE FROM foods WHERE id=413;</span></p>
  <h3><a name="_Toc245565782"><span >常量</span></a></h3>
  <p><span >也称为</span><span>Literals</span><span
>，表示确切的值，有</span><span>3</span><span
>种：字符串常量、数据常量和二进制常量。字符串常量如：</span></p>
  <p><span>'Jerry' </span></p>
  <p><span>'Newman' </span></p>
  <p><span>'JujyFruit' </span></p>
  <p><span >字符串值用单引号</span><span>(')</span><span >括起来，如果字符串中本身包含单引号，需要双写。如“</span><span>Kenny’s chicken</span><span >”需要写成：</span></p>
  <p><span>'Kenny''s chicken' </span></p>
  <p><span >数字常量有整数、十进制数和科学记数法表示的数，如：</span></p>
  <p><span>-1 </span></p>
  <p><span>3.142 </span></p>
  <p><span>6.0221415E23</span></p>
  <p><span >二进制值用如</span><span>x'0000'</span><span
>的表示法，其中每个数据是一个</span><span>16</span><span
>进制数。二进制值必须由两个两个的</span><span>16</span><span
>进制数</span><span>(8 bits)</span><span
>组成，如：</span></p>
  <p><span>x'01'</span></p>
  <p><span>X'0fff'</span></p>
  <p><span>x'0F0EFF'</span></p>
  <p><span>X'0f0effab'</span></p>
  <h3><a name="_Toc245565783"><span >保留字和标识符</span></a></h3>
  <p><span >保留字由</span><span>SQL</span><span
>保留用做特殊的用途，如</span><span>SELECT</span><span
>、</span><span>UPDATE</span><span
>、</span><span>INSERT</span><span
>、</span><span>CREATE</span><span
>、</span><span>DROP</span><span
>和</span><span>BEGIN</span><span
>等。标识符指明数据库里的具体对象，如表或索引。保留字预定义，不能用做标识符。</span><span>SQL</span><span >不区分大小写，下面是相同的语句：</span></p>
  <p><span>SELECT * from foo;</span></p>
  <p><span>SeLeCt * FrOm FOO;</span></p>
  <p><span >为清楚起见，本章中保留字都用大写，标识符都用小写。</span></p>
  <p><span >但是，</span><span>SQLite</span><span
>对字符串的值是大小写敏感的。</span></p>
  <h3><a name="_Toc245565784"><span >注释</span></a></h3>
  <p><span>SQL</span><span >中单行注释用双减号开始，多行注释采用</span><span>C</span><span >风格的</span><span>/*
    */</span><span >形式。</span></p>
  <h2><a name="_Toc245565785"><span style='font-family:黑体'>创建一个数据库</span></a></h2>
  <p><span >数据库中所有的工作都围绕表进行。表由行和列组成，看起来简单，但其实并非如此。表跟其它所有的概念有关，涉及本章的大部分篇幅。在此我们用</span><span>2</span><span >分钟的时间给出一个预览。</span></p>
  <h3><a name="_Toc245565786"><span >创建表</span></a></h3>
  <p><span >在</span><span>SQL</span><span
>中，创建和删除数据库对象的语句一般被称为数据定义语言</span><span>(data
    definition language</span><span >，</span><span> DDL)</span><span >，操作这些对象中数据的语句称为数据操作语言</span><span>(data manipulation language</span><span >，</span><span>DML)</span><span >。创建表的语句属于</span><span>DDL</span><span >，用</span><span>CREATE
    TABLE</span><span >命令，如下定义：</span></p>
  <p><span>CREATE [TEMP] TABLE table_name
    (column_definitions [, constraints]); </span></p>
  <p><span >用</span><span>TEMP</span><span
>或</span><span>TEMPORARY</span><span
>保留字声明的表为临时表，只存活于当前会话，一旦连接断开，就会被自动删除。</span></p>
  <p><span >中括号表示可选项。</span></p>
  <p><span >另外，竖线表示在多个中选一，如：</span></p>
  <p><span>CREATE [TEMP|TEMPORARY] TABLE … ; </span></p>
  <p><span >如果没有指明创建临时表，则创建的是基本表，将会在数据库中持久存在。</span></p>
  <p><span >数据库中还有其它类型的表，如系统表和视图，现在先不介绍。</span></p>
  <p><span>CREATE TABLE</span><span style='font-family:
宋体'>命令至少需要一个表名和一个字段名。命令中</span><span>table_name</span><span
>表示表名，必须与其它所有的标识符不同。</span><span>column_definitions</span><span
>表示一个用逗号分隔的字段列表。每个字段定义包括一个名称、一个域和一个逗号分隔的字段约束表。“域”一般情况下是一个类型，与编程语言中的数据类型同名，指明存储在该列的数据的类型。在</span><span>SQLite</span><span >中有</span><span>5</span><span
>种本地类型：</span><span>INTEGER</span><span
>、</span><span>REAL</span><span
>、</span><span>TEXT</span><span
>、</span><span>BLOB</span><span
>和</span><span>NULL</span><span
>，所有这些域将在本章后面的“存储类”一节中介绍。“约束”用来控制什么样的值可以存储在表中或特定的字段中。例如，你可以用</span><span>UNIQUE</span><span >约束来规定所有记录中某个字段的值要各不相同。约束将会在“数据完整性”一节中介绍。</span></p>
  <p><span >在字段列表后面，可以跟随一个附加的字段约束，如下例：</span></p>
  <p><span>CREATE TABLE contacts ( id INTEGER PRIMARY
    KEY, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; name TEXT NOT NULL
    COLLATE NOCASE, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; phone TEXT NOT NULL
    DEFAULT 'UNKNOWN', </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; UNIQUE (name,phone) ); </span></p>
  <h3><a name="_Toc245565787"><span >改变表</span></a></h3>
  <p><span >你可以用</span><span>ALTER
    TABLE</span><span >命令改变表的结构。</span><span>SQLite</span><span
>版的</span><span>ALTER TABLE</span><span
>命令既可以改变表名，也可以增加字段。一般格式为：</span></p>
  <p><span>ALTER TABLE table { RENAME TO name | ADD
    COLUMN column_def }</span></p>
  <p><span >注意这里又出现了新的符号</span><span>{}</span><span >。花括号括起来一个选项列表，必须从各选项中选择一个。此处，我们或者</span><span>ALTER TABLE table RENAME…</span><span >，或者</span><span>ALTERTABLE table ADD COLUMN…</span><span >。</span><span>That is, you can either rename the table using the RENAME clause, or
    add a column with the ADDCOLUMN clause. To rename a table, you simply provide
    the new name given by name. If you add a column, the column definition, denoted
    by column_def, follows the form in the CREATE TABLE statement. It is a name,
    followed by an optional domain and list of constraints. </span><span
>例如：</span></p>
  <p><span>sqlite&gt; ALTER TABLE contacts </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; ADD COLUMN email TEXT
    NOT NULL DEFAULT '' COLLATE NOCASE; </span></p>
  <p><span>sqlite&gt; .schema contacts </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; CREATE TABLE contacts (
    id INTEGER PRIMARY KEY, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; name TEXT NOT NULL
    COLLATE NOCASE, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; phone TEXT NOT NULL
    DEFAULT 'UNKNOWN', </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; email TEXT NOT NULL
    DEFAULT '' COLLATE NOCASE, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; UNIQUE (name,phone) ); </span></p>
  <p><span >显示了当前的表定义。</span></p>
  <p><span >表还可以由</span><span>SELECT</span><span
>语句创建，你可以在创建表结构的同时创建数据。这种特别的</span><span>CREATE
    TABLE</span><span >语句将在“插入记录”一节中介绍。</span></p>
  <h2><a name="_Toc245565788"><span style='font-family:黑体'>在数据库中查询</span></a></h2>
  <p><span>SELECT</span><span >是</span><span>SQL</span><span >命令中最大最复杂的命令。</span><span>SELECT</span><span >的很多操作都来源于关系代数。</span></p>
  <h3><a name="_Toc245565789"><span >关系操作</span></a></h3>
  <p><span>SELECT</span><span >中使用</span><span>3</span><span >大类</span><span>13</span><span
>种关系操作：</span></p>
  <p><span>. </span><span >基本的操作</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Restriction(</span><span
>限制</span><span>)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Projection </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Cartesian Product(</span><span
>笛卡尔积</span><span>)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Union(</span><span
>联合</span><span>)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Difference(</span><span
>差</span><span>)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Rename(</span><span
>重命名</span><span>)</span></p>
  <p><span>. </span><span >附加的操作</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Intersection(</span><span
>交叉</span><span>)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Natural Join(</span><span
>自然连接</span><span>)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Assign(</span><span
>指派</span><span> OR </span><span
>赋值</span><span>)</span></p>
  <p><span>. </span><span >扩展的操作</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Generalized Projection </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Left Outer Join </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Right Outer Join </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; . Full Outer Join </span></p>
  <p><span >基本的关系操作，除重命名外，在集合论中都有相应的理论基础。附加操作是为了方便，</span> <span >它们可以用基本操作来完成，一般情况下，附加操作可以作为常用基本操作序列的快捷方式。扩展操作为基本操作和附加操作增加特性。</span><span> </span></p>
  <p><span>ANSI SQL</span><span style='font-family:
宋体'>的</span><span>SELECT</span><span >可以完成上述所有的关系操作。这些操作覆盖了</span><span>Codd</span><span >最初定义的所有关系运算符，只有一个例外――</span><span>divide</span><span >。</span><span>SQLite</span><span
>支持</span><span>ANSI SQL</span><span
>中除</span><span>right</span><span
>和</span><span>full outer join</span><span
>之外的所有操作</span><span>(</span><span
>这些操作可用其它间接的方法完成</span><span>)</span><span
>。</span></p>
  <h3><a name="_Toc245565790"><span >操作管道</span></a></h3>
  <p><span >从语法上来说，</span><span>SELECT</span><span
>命令用一系列子句将很多关系操作组合在一起。每个子句代表一种特定的关系操作。几乎所有这些子句都是可选的，你可以只选你所需要的操作。</span></p>
  <p><span>SELECT</span><span >是一个很大的命令。下面是</span><span>SELECT</span><span >的一个简单形式：</span></p>
  <p><span>SELECT DISTINCT heading FROM tables WHERE
    predicate </span></p>
  <p><span>GROUP BY columns HAVING predicate </span></p>
  <p><span>ORDER BY columns LIMIT count,offset; </span></p>
  <p><span >每个保留字――</span><span>DISTINCT</span><span
>、</span><span>FROM</span><span
>、</span><span>WHERE</span><span
>和</span><span>HAVING</span><span
>――都是一个单独的子句。每个子句由保留字和跟随的参数构成。</span></p>
  <p><span >表</span><span>4-1 SELECT</span><span
>的子句</span></p>
  <table border=1 cellspacing=0 cellpadding=0>
    <tr>
      <td width=84 valign=top><p align=center style='text-align:center'><span
  >编号</span></p></td>
      <td width=108 valign=top><p align=center style='text-align:center'><span
  >子句</span></p></td>
      <td width=120 valign=top><p align=center style='text-align:center'><span
  >操作</span></p></td>
      <td width=240 valign=top><p align=center style='text-align:center'><span
  >输入</span></p></td>
    </tr>
    <tr>
      <td width=84 valign=top><p><span>1</span></p></td>
      <td width=108 valign=top><p><span>FROM</span></p></td>
      <td width=120 valign=top><p><span>Join</span></p></td>
      <td width=240 valign=top><p><span>List of tables</span></p></td>
    </tr>
    <tr>
      <td width=84 valign=top><p><span>2</span></p></td>
      <td width=108 valign=top><p><span>WHERE</span></p></td>
      <td width=120 valign=top><p><span>Restriction</span></p></td>
      <td width=240 valign=top><p><span>Logical predicate</span></p></td>
    </tr>
    <tr>
      <td width=84 valign=top><p><span>3</span></p></td>
      <td width=108 valign=top><p><span>ORDER BY</span></p></td>
      <td width=120 valign=top>&nbsp;</td>
      <td width=240 valign=top><p><span>List of columns</span></p></td>
    </tr>
    <tr>
      <td width=84 valign=top><p><span>4</span></p></td>
      <td width=108 valign=top><p><span>GROUP BY</span></p></td>
      <td width=120 valign=top><p><span>Restriction</span></p></td>
      <td width=240 valign=top><p><span>List of columns</span></p></td>
    </tr>
    <tr>
      <td width=84 valign=top><p><span>5</span></p></td>
      <td width=108 valign=top><p><span>HAVING</span></p></td>
      <td width=120 valign=top><p><span>Restriction</span></p></td>
      <td width=240 valign=top><p><span>Logical predicate</span></p></td>
    </tr>
    <tr>
      <td width=84 valign=top><p><span>6</span></p></td>
      <td width=108 valign=top><p><span>SELECT</span></p></td>
      <td width=120 valign=top><p><span>Restriction</span></p></td>
      <td width=240 valign=top><p><span>List of columns or expressions</span></p></td>
    </tr>
    <tr>
      <td width=84 valign=top><p><span>7</span></p></td>
      <td width=108 valign=top><p><span>DISTINCT</span></p></td>
      <td width=120 valign=top><p><span>Restriction</span></p></td>
      <td width=240 valign=top><p><span>List of columns</span></p></td>
    </tr>
    <tr>
      <td width=84 valign=top><p><span>8</span></p></td>
      <td width=108 valign=top><p><span>LIMIT</span></p></td>
      <td width=120 valign=top><p><span>Restriction</span></p></td>
      <td width=240 valign=top><p><span>Integer value</span></p></td>
    </tr>
    <tr>
      <td width=84 valign=top><p><span>9</span></p></td>
      <td width=108 valign=top><p><span>OFFSET</span></p></td>
      <td width=120 valign=top><p><span>Restriction</span></p></td>
      <td width=240 valign=top><p><span>Integer value</span></p></td>
    </tr>
  </table>
  <p><span><img width=553 height=147
src="Definitive Guide/image005.jpg"></span></p>
  <p><span >图</span><span>4-3 SELECT
    phases</span></p>
  <h3><a name="_Toc245565791"><span >过滤</span></a></h3>
  <p><span >如果</span><span>SELECT</span><span
>是</span><span>SQL</span><span
>中最复杂的命令，那么</span><span>WHERE</span><span
>就是</span><span>SELECT</span><span
>中最复杂的子句。</span></p>
  <h4><span style='font-family:黑体'>值</span></h4>
  <p><span >“值”可以按它们所属的域</span><span>(</span><span >或类型</span><span>)</span><span
>来分类，如数字值</span><span>(1, 2, 3, etc.)</span><span
>或字符串值</span><span>(“Jujy-Fruit”)</span><span
>。值可以表现为文字的值</span><span>(1, 2, 3 or
    “JujyFruit”)</span><span >、变量</span><span>(</span><span
>一般是如</span><span>foods.name</span><span
>的列名</span><span>)</span><span
>、表达式</span><span>(3+2/5)</span><span
>或函数的结果</span><span>(COUNT(foods.name))</span><span
>值。</span></p>
  <h4><span style='font-family:黑体'>操作符</span></h4>
  <p><span >操作符使用一个或多个值做为输入并产生一个新值做为输出。这所以叫“操作符”是因为它完成某种操作并产生某种结果。二目操作符操作两个输入值</span><span>(</span><span >或称操作数</span><span>)</span><span
>，三目操作符操作三个操作数，单目操作符操作一个操作数，等等。</span></p>
  <p><span><img width=449 height=138
src="Definitive Guide/image006.jpg"></span></p>
  <p><span >图</span><span>4-7 </span><span
>单目、二目和三目操作符</span></p>
  <h4><span style='font-family:黑体'>二目操作符</span></h4>
  <p><span >二目操作符是最常用的</span><span>SQL</span><span >操作符。表</span><span>4-2</span><span
>列出了</span><span>SQLite</span><span
>所支持的二目操作符。表中按优先级从高到低的次序排列，同色的一组中具有相同的优先级，圆括号可以覆盖原有的优先级。</span></p>
  <p><span >表</span><span>4-2</span><span
>二目操作符</span></p>
  <table border=1 cellspacing=0 cellpadding=0>
    <tr>
      <td width=182 valign=top><p align=center style='text-align:center'><span
  >操作符</span></p></td>
      <td width=189 valign=top><p align=center style='text-align:center'><span
  >类型</span></p></td>
      <td width=180 valign=top><p align=center style='text-align:center'><span
  >作用</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>||</span></p></td>
      <td width=189 valign=top><p><span>String</span></p></td>
      <td width=180 valign=top><p><span>Concatenation</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>*</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Arithmetic</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>Multiply</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>/</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Arithmetic</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>Divide</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>%</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Arithmetic</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>Modulus</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>+</span></p></td>
      <td width=189 valign=top><p><span>Arithmetic</span></p></td>
      <td width=180 valign=top><p><span>Add</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span >C</span></p></td>
      <td width=189 valign=top><p><span>Arithmetic</span></p></td>
      <td width=180 valign=top><p><span>Subtract</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>&lt;&lt;&nbsp;</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Bitwise</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>Right shift</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>&gt;&gt;&nbsp;</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Bitwise</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>Left shift</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>&amp;</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Logical</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>And</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>|</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Logical</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>Or</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>&lt;&nbsp;</span></p></td>
      <td width=189 valign=top><p><span>Relational</span></p></td>
      <td width=180 valign=top><p><span>Less than</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>&lt;=</span></p></td>
      <td width=189 valign=top><p><span>Relational</span></p></td>
      <td width=180 valign=top><p><span>Less than or equal to</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>&gt;&nbsp;</span></p></td>
      <td width=189 valign=top><p><span>Relational</span></p></td>
      <td width=180 valign=top><p><span>Greater than</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>&gt;=</span></p></td>
      <td width=189 valign=top><p><span>Relational</span></p></td>
      <td width=180 valign=top><p><span>Greater than or equal to</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>=</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Relational</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>Equal to</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>==</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Relational</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>Equal to</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>&lt;&gt;&nbsp;</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Relational</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>Not equal to</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>!=</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Relational</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>Not equal to</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>IN</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Logical</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>In</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>AND</span></p></td>
      <td width=189 valign=top><p><span>Logical</span></p></td>
      <td width=180 valign=top><p><span>And</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>OR</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Logical</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>Or</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>LIKE</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Relational</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>String matching</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top bgcolor="#E0E0E0"><p><span>GLOB</span></p></td>
      <td width=189 valign=top bgcolor="#E0E0E0"><p><span>Relational</span></p></td>
      <td width=180 valign=top bgcolor="#E0E0E0"><p><span>Filename matching</span></p></td>
    </tr>
  </table>
  <h4><span>LIKE</span><span style='font-family:黑体'>操作符</span></h4>
  <p><span >一个很有用的关系操作符是</span><span>LIKE</span><span >。</span><span>LIKE</span><span
>的作用与相等</span><span>(=)</span><span
>很像，但却是通过一个模板来进行字符串匹配。例如，要查询所有名称以字符“</span><span>J</span><span >”开始的食品，可使用如下语句：</span></p>
  <p><span>sqlite&gt; SELECT id, name FROM foods WHERE
    name LIKE 'J%'; </span></p>
  <p><span>id name </span></p>
  <p><span>156 Juice box </span></p>
  <p><span>236 Juicy Fruit Gum </span></p>
  <p><span>243 Jello with Bananas </span></p>
  <p><span>244 JujyFruit </span></p>
  <p><span>245 Junior Mints </span></p>
  <p><span>370 Jambalaya </span></p>
  <p><span >模板中的百分号</span><span>(%)</span><span
>可与任意</span><span>0</span><span
>到多个字符匹配。下划线</span><span>(_)</span><span
>可与任意单个字符匹配。</span></p>
  <p><span>sqlite&gt; SELECT id, name FROM foods WHERE
    name LIKE '%ac%P%'; </span></p>
  <p><span>id name </span></p>
  <p><span>127 Guacamole Dip </span></p>
  <p><span>168 Peach Schnapps </span></p>
  <p><span>198 Mackinaw Peaches </span></p>
  <p><span >另一个有用的窍门是使用</span><span>NOT</span><span >：</span></p>
  <p><span>sqlite&gt; SELECT id, name FROM foods </span></p>
  <p><span>WHERE name like '%ac%P%' AND name NOT LIKE
    '%Sch%' </span></p>
  <p><span>id name </span></p>
  <p><span>38 Pie (Blackberry) Pie </span></p>
  <p><span>127 Guacamole Dip </span></p>
  <p><span>198 Mackinaw peaches </span></p>
  <h3><a name="_Toc245565792"><span >限定和排序</span></a></h3>
  <p><span >可以用</span><span>LIMIT</span><span
>和</span><span>OFFSET</span><span
>保留字限定结果集的大小和范围。</span><span>LIMIT</span><span
>指定返回记录的最大数量。</span><span>OFFSET</span><span
>指定偏移的记录数。例如，下面的命令返回</span><span>food_types</span><span
>表中</span><span>id</span><span
>排第</span><span>2</span><span
>的记录：</span></p>
  <p><span>SELECT * FROM food_types LIMIT 1 OFFSET 1
    ORDER BY id; </span></p>
  <p><span >保留字</span><span>OFFSET</span><span
>在结果集中跳过一行</span><span>(Bakery)</span><span
>，保留字</span><span>LIMIT</span><span
>限制最多返回一行</span><span>(Cereal)</span><span
>。</span></p>
  <p><span >上面语句中还有一个</span><span>ORDER BY</span><span >子句，它使记录集在返回之前按一个或多个字段的值排序。例如：</span></p>
  <p><span>sqlite&gt; SELECT * FROM foods WHERE name
    LIKE 'B%' </span></p>
  <p><span>ORDER BY type_id DESC, name LIMIT 10; </span></p>
  <p><span>id type_id name </span></p>
  <p><span>382 15 Baked Beans </span></p>
  <p><span>383 15 Baked Potato w/Sour </span></p>
  <p><span>384 15 Big Salad </span></p>
  <p><span>385 15 Broccoli </span></p>
  <p><span>362 14 Bouillabaisse </span></p>
  <p><span>328 12 BLT </span></p>
  <p><span>327 12 Bacon Club (no turke</span></p>
  <p><span>326 12 Bologna</span></p>
  <p><span>329 12 Brisket Sandwich</span></p>
  <p><span>274 10 Bacon</span></p>
  <h3><a name="_Toc245565793"><span >函数</span><span>(Function)</span></a><span >和聚合</span><span>(Aggregate)</span></h3>
  <p><span>SQLite</span><span >提供了多种内置的函数和聚合，可以用在不同的子句中。函数的种类包括：数学函数，如</span><span>ABS()</span><span >计算绝对值；字符串格式函数，如</span><span>UPPER()</span><span >和</span><span>LOWER()</span><span
>，它们将字符串的值转化为大写或小写。例如：</span></p>
  <p><span>sqlite&gt; SELECT UPPER('hello newman'),
    LENGTH('hello newman'), ABS(-12); </span></p>
  <p><span>UPPER('hello newman') LENGTH('hello
    newman') ABS(-12) </span></p>
  <p><span>HELLO NEWMAN 12 12 </span></p>
  <p><span >函数名是不分大小写的</span><span>(</span><span >或</span><span>upper()</span><span
>和</span><span>UPPER()</span><span
>是同一个函数</span><span>)</span><span
>。函数可以接受字段值作为参数：</span></p>
  <p><span>sqlite&gt; SELECT id, UPPER(name), LENGTH(name)
    FROM foods </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE
    type_id=1 LIMIT 10; </span></p>
  <p><span>id UPPER(name) LENGTH(name) </span></p>
  <p><span>-----------</span></p>
  <p><span>1 BAGELS 6 </span></p>
  <p><span>2 BAGELS, RAISIN 14 </span></p>
  <p><span>3 BAVARIAN CREAM PIE 18 </span></p>
  <p><span>4 BEAR CLAWS 10 </span></p>
  <p><span>5 BLACK AND WHITE COOKIES 23 </span></p>
  <p><span>6 BREAD (WITH NUTS) 17 </span></p>
  <p><span>7 BUTTERFINGERS 13 </span></p>
  <p><span>8 CARROT CAKE 11 </span></p>
  <p><span>9 CHIPS AHOY COOKIES 18 </span></p>
  <p><span>10 CHOCOLATE BOBKA 15 </span></p>
  <p><span >因为函数可以是任意表达式的一部分，所以函数也可以用在</span><span>WHERE</span><span >子句中：</span></p>
  <p><span>sqlite&gt; SELECT id, UPPER(name),
    LENGTH(name) FROM foods</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE
    LENGTH(name) &lt; 5 LIMIT 5; </span></p>
  <p><span>id upper(name) length(name) </span></p>
  <p><span>36PIE 3 </span></p>
  <p><span>48 BRAN 4 </span></p>
  <p><span>56KIX 3 </span></p>
  <p><span>57 LIFE 4 </span></p>
  <p><span>80 DUCK 4 </span></p>
  <p><span >聚合是一类特殊的函数，它从一组记录中计算聚合值。标准的聚合函数包括</span><span>SUM()</span><span >、</span><span>AVG()</span><span
>、</span><span>COUNT()</span><span
>、</span><span>MIN()</span><span
>和</span><span>MAX()</span><span
>。例如，要得到烘烤食品</span><span>(type_id=1)</span><span
>的数量，可使用如下语句：</span></p>
  <p><span>sqlite&gt; SELECT COUNT(*) FROM foods WHERE
    type_id=1; </span></p>
  <p><span>count </span></p>
  <p><span>47 </span></p>
  <h3><a name="_Toc245565794"><span >分组</span><span>(Grouping)</span></a></h3>
  <p><span >聚合的精华部分是分组。聚合不只是能够计算整个结果集的聚合值，你还可以把结果集分成多个组，然后计算每个组的聚合值。这些都可以在一步当中完成，方法就是使用</span><span>GROUP BY</span><span >子句，如：</span></p>
  <p><span>sqlite&gt; SELECT type_id FROM foods GROUP
    BY type_id; </span></p>
  <p><span>type_id </span></p>
  <p><span>1 </span></p>
  <p><span>2 </span></p>
  <p><span>3 </span></p>
  <p><span>. </span></p>
  <p><span>. </span></p>
  <p><span>. </span></p>
  <p><span>15 </span></p>
  <h3><a name="_Toc245565795"><span >去掉重复</span></a></h3>
  <p><span >操作管道中的下一个限制是</span><span>DISTINCT</span><span >。</span><span>DISTINCT</span><span >处理</span><span>SELECT</span><span >的结果并过滤掉其中重复的行。例如，你想从</span><span>foods</span><span >表中取得所有不同的</span><span>type_id</span><span >值：</span></p>
  <p><span>sqlite&gt; SELECT DISTINCT type_id FROM
    foods; </span></p>
  <p><span>type_id </span></p>
  <p><span>1 </span></p>
  <p><span>2 </span></p>
  <p><span>3 </span></p>
  <p><span>. </span></p>
  <p><span>. </span></p>
  <p><span>. </span></p>
  <p><span>15 </span></p>
  <h3><a name="_Toc245565796"><span >多表连接</span></a></h3>
  <p><span >连接</span><span>(join)</span><span
>是</span><span>SELECT</span><span
>命令的第一个操作，它产生初始的信息，供语句的其它部分过滤和处理。连接的结果是一个合成的关系</span><span>(</span><span >或表</span><span>)</span><span
>，它是</span><span>SELECT</span><span
>后继操作的输入。</span></p>
  <p><span >也许从一个例子开始是最简单的。</span><span> </span></p>
  <p><span>sqlite&gt; SELECT foods.name,
    food_types.name</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM foods,
    food_types </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE
    foods.type_id=food_types.id LIMIT 10;</span></p>
  <p><span>name name </span></p>
  <p><span>Bagels Bakery</span></p>
  <p><span>Bagels, raisin Bakery</span></p>
  <p><span>Bavarian Cream Pie Bakery</span></p>
  <p><span>Bear Claws Bakery</span></p>
  <p><span>Black and White cookies Bakery</span></p>
  <p><span>Bread (with nuts) Bakery</span></p>
  <p><span>Butterfingers Bakery</span></p>
  <p><span>Carrot Cake Bakery</span></p>
  <p><span>Chips Ahoy Cookies Bakery</span></p>
  <p><span>Chocolate Bobka Bakery</span></p>
  <h3><a name="_Toc245565797"><span >名称和别名</span></a></h3>
  <p><span >当把多个表连接在一起时，字段可能重名。</span></p>
  <p><span>SELECT B.name FROM A JOIN B USING (a); </span></p>
  <h2><a name="_Toc245565798"><span style='font-family:黑体'>修改数据</span></a></h2>
  <p><span >跟</span><span>SELECT</span><span
>命令相比，用于修改数据的语句就太简单太容易理解了。有</span><span>3</span><span
>个</span><span>DML</span><span
>语句用于修改数据――</span><span>INSERT</span><span
>、</span><span>UPDATE</span><span
>和</span><span>DELETE</span><span
>。</span></p>
  <h3><a name="_Toc245565799"><span >插入记录</span></a></h3>
  <p><span >使用</span><span>INSERT</span><span
>命令向表中插入记录。使用</span><span>INSERT</span><span
>命令可以一次插入</span><span>1</span><span
>条记录，也可以使用</span><span>SELECT</span><span
>命令一次插入多条记录。</span><span>INSERT</span><span
>语句的一般格式为：</span></p>
  <p><span>INSERT INTO table (column_list) VALUES
    (value_list); </span></p>
  <p><span>Table</span><span >指明数据插入到哪个表中。</span><span>column_list</span><span >是用逗号分隔的字段名表，这些字段必须是表中存在的。</span><span>value_list</span><span >是用逗号分隔的值表，这些值与</span><span>column_list</span><span >中的字段一一对应。例如，下面语句向</span><span>foods</span><span >表插入数据：</span></p>
  <p><span>sqlite&gt; INSERT INTO foods (name,
    type_id) VALUES ('Cinnamon Bobka', 1); </span></p>
  <h3><a name="_Toc245565800"><span >修改记录</span></a></h3>
  <p><span>UPDATE</span><span >命令用于修改一个表中的记录。</span><span>UPDATE</span><span >命令可以修改一个表中一行或多行中的一个或多个字段。</span><span>UPDATE</span><span >语句的一般格式为：</span></p>
  <p><span>UPDATE table SET update_list WHERE
    predicate; </span></p>
  <p><span>update_list</span><span style='font-family:
宋体'>是一个或多个“字段赋值”的列表，字段赋值的格式为</span><span>column_name=value</span><span
>。</span><span>WHERE</span><span
>子句的用法与</span><span>SELECT</span><span
>语句相同，确定需要进行修改的记录。如：</span></p>
  <p><span>UPDATE foods SET name='CHOCOLATE BOBKA'</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; WHERE name='Chocolate
    Bobka';</span></p>
  <p><span>SELECT * FROM foods WHERE name LIKE
    'CHOCOLATE%';</span></p>
  <p><span>id type_ name </span></p>
  <p><span>10 1 CHOCOLATE BOBKA </span></p>
  <p><span>11 1 Chocolate Eclairs </span></p>
  <p><span>12 1 Chocolate Cream Pie </span></p>
  <p><span>222 9 Chocolates, box of </span></p>
  <p><span>223 9 Chocolate Chip Mint </span></p>
  <p><span>224 9 Chocolate Covered Cherries </span></p>
  <h3><a name="_Toc245565801"><span >删除记录</span></a></h3>
  <p><span>DELETE</span><span >用于删除一个表中的记录。</span><span>DELETE</span><span >语句的一般格式为：</span></p>
  <p><span>DELETE FROM table WHERE predicate; </span></p>
  <p><span >同样，</span><span>WHERE</span><span
>子句的用法与</span><span>SELECT</span><span
>语句相同，确定需要被删除的记录。如：</span></p>
  <p><span>DELETE FROM foods WHERE name='CHOCOLATE
    BOBKA'; </span></p>
  <h2><a name="_Toc245565802"><span style='font-family:黑体'>数据完整性</span></a></h2>
  <p><span >数据完整性用于定义和保护表内部或表之间数据的关系。有四种完整性：域完整性、实体完整性、参照完整性和用户定义完整性。</span><span> </span></p>
  <h3><a name="_Toc245565803"><span >实体完整性</span></a></h3>
  <h4><span style='font-family:黑体'>唯一约束</span></h4>
  <p><span >因为唯一</span><span>(UNIQUE)</span><span
>约束是主键的基础，所以先介绍它。一个唯一约束要求一个字段或一组字段的所有值互不相同，或者说唯一。如果你试图插入一个重复值，或将一个值改成一个已存在的值，数据库将引发一个约束非法，并取消操作。唯一约束可以在字段级或表级定义。</span><span> </span></p>
  <p><span>NULL</span><span >和</span><span>UNIQUE</span><span >：</span></p>
  <p><span >问题：如果一个字段已经声明为</span><span>UNIQUE</span><span >，可以向这个字段插入多少个</span><span>NULL</span><span >值？</span></p>
  <p><span >回答：与数据库的种类有关。</span><span>PostgreSQL</span><span >和</span><span>Oracle</span><span >可以插入多个。</span><span>Informix</span><span >和</span><span>Microsoft SQL Server</span><span >只能一个。</span><span>DB2</span><span >、</span><span>SQL
    Anywhere</span><span >和</span><span>Borland
    Inter-Base</span><span >不能。</span><span>SQLite</span><span
>采用了与</span><span>PostgreSQL</span><span
>和</span><span>Oracle</span><span
>相同的解决方案。</span></p>
  <p><span >另一个困扰大家的关于</span><span>NULL</span><span >的经典问题是：两个</span><span>NULL</span><span >值是否相等？你没有足够的信息来证明它们相等，但也没有足够的信息证明它们不等。</span><span>SQLite</span><span >的观点是假设所有的</span><span>NULL</span><span >都是不同的。所以你可以向唯一字段中插入任意多个</span><span>NULL</span><span >值。</span></p>
  <h4><span style='font-family:黑体'>主键约束</span></h4>
  <p><span >在</span><span>SQLite</span><span
>中，当你定义一个表时总要确定一个主键，不管你自己有没有定义。这个字段是一个</span><span>64-bit</span><span >整型字段，称为</span><span>ROWID</span><span >。它还有两个别名――</span><span>_ROWID_</span><span >和</span><span>OID</span><span
>，用这两个别名同样可以取到它的值。它的默认取值按照增序自动生成。</span><span>SQLite</span><span
>为主键字段提供自动增长特性。</span></p>
  <h3><a name="_Toc245565804"><span >域完整性</span></a></h3>
  <h4><span style='font-family:黑体'>默认值</span></h4>
  <p><span >保留字</span><span>DEFAULT</span><span
>为字段提供一个默认值。如果用</span><span>INSERT</span><span
>语句插入记录时没有为该定做指定值，则为它赋默认值。</span><span>DEFAULT</span><span
>不是一个约束</span><span>(constraint)</span><span
>，因为它没有强制任何事情。这所以把它归为域完整性，是因为它提供了处理</span><span>NULL</span><span >值的一个策略。如果一个字段没有指定默认址，在插入时也没有为该字段指定值，</span><span>SQLite</span><span >将向该字段插入一个</span><span>NULL</span><span >。例如，</span><span>contacts.name</span><span
>字段有一个默认值</span><span>'UNKNOWN'</span><span
>，请看下面例子：</span></p>
  <p><span>sqlite&gt; INSERT INTO contacts (name)
    VALUES ('Jerry');</span></p>
  <p><span>sqlite&gt; SELECT * FROM contacts;</span></p>
  <p><span>id name phone </span></p>
  <p><span>Jerry UNKNOWN </span></p>
  <p><span>DEFAULT</span><span style='font-family:
宋体'>还可以接受</span><span>3</span><span >种预定义格式的</span><span>ANSI/ISO</span><span >预定字用于生成日期和时间值。</span><span>CURRENT_TIME</span><span >将会生成</span><span>ANSI/ISO</span><span >格式</span><span>(HH:MM:SS)</span><span >的当前时间。</span><span>CURRENT_DATE</span><span >会生成当前日期</span><span>(</span><span >格式为</span><span>YYYY-MM-DD)</span><span
>。</span><span>CURRENT_TIMESTAMP</span><span
>会生成一个日期时间的组合</span><span>(</span><span
>格式为</span><span>YYYY-MM-DD HH:MM:SS)</span><span
>。例如：</span></p>
  <p><span>CREATE TABLE times ( id int,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; date NOT NULL DEFAULT
    CURRENT_DATE, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; time NOT NULL DEFAULT
    CURRENT_TIME, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; timestamp NOT NULL
    DEFAULT CURRENT_TIMESTAMP );</span></p>
  <p><span>INSERT INTO times(1);</span></p>
  <p><span>INSERT INTO times(2);</span></p>
  <p><span>SELECT * FROMS times;</span></p>
  <p><span>id date time timestamp </span></p>
  <p><span>1 2006-03-15 23:30:25 2006-03-15 23:30:25 </span></p>
  <p><span>2 2006-03-15 23:30:40 2006-03-15 23:30:40 </span></p>
  <h4><span>NOT NULL</span><span style='font-family:黑体'>约束</span></h4>
  <h4><span>CHECK</span><span style='font-family:黑体'>约束</span></h4>
  <h4><span style='font-family:黑体'>排序法</span><span>(Collation)</span></h4>
  <p><span >排序法定义如何唯一地确定文本的值。排序法主要用于规定文本值如何进行比较。不同的排序法有不同的比较方法。例如，某种排序法是大小写不敏感的，于是</span><span>'JujyFruit'</span><span >和</span><span>'JUJYFRUIT'</span><span >被认为是相等的。另外一个排序法或许是大小写敏感的，这时上面两个字符串就不相等了。</span></p>
  <p><span>SQLite</span><span >有</span><span>3</span><span >种内置的排序法。默认为</span><span>BINARY</span><span >，它使用一个</span><span>C</span><span >函数</span><span>memcmp()</span><span
>来对文本进行逐字节的比较。这很适合于大多数西方语言，如英语。</span><span>NOCASE</span><span
>对</span><span>26</span><span
>个字母是大小写不敏感的。</span><span>Finally there is
    REVERSE, which is the reverse of the BINARY collation. REVERSE is more for
    testing (and perhaps illustration) than anything else. </span></p>
  <p><span>SQLite C API</span><span style='font-family:
宋体'>提供了一种创建定制排序法的手段，详见第</span><span>7</span><span style='font-family:
宋体'>章。</span></p>
  <h3><a name="_Toc245565805"><span >存储类</span><span>(Storage Classes)</span></a></h3>
  <p><span >如前文所述，</span><span>SQLite</span><span
>在处理数据类型时与其它的数据库不同。区别在于它所支持的类型以及这些类型是如何存储、比较、强化</span><span>(enforc)</span><span >和指派</span><span>(assign)</span><span >。下面各节介绍</span><span>SQLite</span><span >处理数据类型的独特方法和它与域完整性的关系。</span></p>
  <p><span >对于数据类型，</span><span>SQLite</span><span
>的域完整性被称为域亲和性</span><span>(affinity)</span><span
>更合适。在</span><span>SQLite</span><span
>中，它被称为类型亲和性</span><span>(type affinity)</span><span
>。为了理解类型亲和性，你必须先要理解存储类和弱类型</span><span>(manifest
    typing)</span><span >。</span></p>
  <p><span>SQLite</span><span >有</span><span>5</span><span >个原始的数据类型，被称为存储类。存储类这个词表明了一个值在磁盘上存储的格式，其实就是类型或数据类型的同义词。这</span><span>5</span><span >个存储类在表</span><span>4-6</span><span
>中描述。</span></p>
  <p><span >表</span><span> 4-6 SQLite</span><span
>存储类</span></p>
  <table border=1 cellspacing=0 cellpadding=0>
    <tr>
      <td width=96 valign=top><p align=center style='text-align:center'><span
  >名称</span></p></td>
      <td width=465 valign=top><p align=center style='text-align:center'><span
  >说明</span></p></td>
    </tr>
    <tr>
      <td width=96 valign=top><p><span>INTEGER</span></p></td>
      <td width=465 valign=top><p><span >整数值是全数字</span><span>(</span><span >包括正和负</span><span>)</span><span
  >。整数可以是</span><span>1, 2, 3, 4, 6</span><span
  >或</span><span> 8</span><span
  >字节。整数的最大范围</span><span>(8 bytes)</span><span
  >是</span><span>{-9223372036854775808, 0, +9223372036854775807}</span><span
  >。</span><span>SQLite</span><span
  >根据数字的值自动控制整数所占的字节数。</span></p>
        <p><span >空注：参可变长整数的概念。</span></p></td>
    </tr>
    <tr>
      <td width=96 valign=top><p><span>REAL</span></p></td>
      <td width=465 valign=top><p><span >实数是</span><span>10</span><span
  >进制的数值。</span><span>SQLite</span><span
  >使用</span><span>8</span><span
  >字节的符点数来存储实数。</span></p></td>
    </tr>
    <tr>
      <td width=96 valign=top><p><span>TEXT</span></p></td>
      <td width=465 valign=top><p><span >文本</span><span>(TEXT)</span><span
  >是字符数据。</span><span>SQLite</span><span
  >支持几种字符编码，包括</span><span>UTF-8</span><span
  >和</span><span>UTF-16</span><span
  >。字符串的大小没有限制。</span></p></td>
    </tr>
    <tr>
      <td width=96 valign=top><p><span>BLOB</span></p></td>
      <td width=465 valign=top><p><span >二进制大对象</span><span>(BLOB)</span><span >是任意类型的数据。</span><span>BLOB</span><span >的大小没有限制。</span></p></td>
    </tr>
    <tr>
      <td width=96 valign=top><p><span>NULL</span></p></td>
      <td width=465 valign=top><p><span>NULL</span><span >表示没有值。</span><span>SQLite</span><span >具有对</span><span>NULL</span><span >的完全支持。</span></p></td>
    </tr>
  </table>
  <p><span>SQLite</span><span >通过值的表示法来判断其类型，下面就是</span><span>SQLite</span><span >的推理方法：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>SQL</span><span >语句中用单引号或双引号括起来的文字被指派为</span><span>TEXT</span><span >。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >如果文字是未用引号括起来的数据，并且没有小数点和指数，被指派为</span><span>INTEGER</span><span >。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >如果文字是未用引号括起来的数据，并且带有小数点或指数，被指派为</span><span>REAL</span><span >。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >用</span><span>NULL</span><span
>说明的值被指派为</span><span>NULL</span><span
>存储类。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >如果一个值的格式为</span><span>X'ABCD'</span><span
>，其中</span><span>ABCD</span><span
>为</span><span>16</span><span
>进制数字，则该值被指派为</span><span>BLOB</span><span
>。</span><span>X</span><span style='font-family:
宋体'>前缀大小写皆可。</span></p>
  <p><span>SQL</span><span >函数</span><span>typeof()</span><span >根据值的表示法返回其存储类。使用这个函数，下面</span><span>SQL</span><span >语句返回的结果为：</span></p>
  <p><span>sqlite&gt; select typeof(3.14),
    typeof('3.14'), typeof(314), typeof(x'3142'), typeof(NULL); </span></p>
  <p><span>typeof(3.14)&nbsp;&nbsp; typeof('3.14')&nbsp; typeof(314)&nbsp;&nbsp;&nbsp; typeof(x'3142')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typeof(NULL) </span></p>
  <p><span>real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null </span></p>
  <p><span>SQLite</span><span >单独的一个字段可能包含不同存储类的值。请看下面的示例：</span></p>
  <p><span>sqlite&gt; DROP TABLE domain;</span></p>
  <p><span>sqlite&gt; CREATE TABLE domain(x);</span></p>
  <p><span>sqlite&gt; INSERT INTO domain VALUES
    (3.142);</span></p>
  <p><span>sqlite&gt; INSERT INTO domain VALUES
    ('3.142');</span></p>
  <p><span>sqlite&gt; INSERT INTO domain VALUES
    (3142);</span></p>
  <p><span>sqlite&gt; INSERT INTO domain VALUES
    (x'3142');</span></p>
  <p><span>sqlite&gt; INSERT INTO domain VALUES
    (NULL);</span></p>
  <p><span>sqlite&gt; SELECT ROWID, x, typeof(x) FROM
    domain;</span></p>
  <p><span >返回结果为：</span></p>
  <p><span>rowid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typeof(x)</span></p>
  <p><span>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.142&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real </span></p>
  <p><span>2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.142&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text </span></p>
  <p><span>3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3142
    &nbsp;&nbsp;&nbsp;&nbsp; integer </span></p>
  <p><span>4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1B
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blob </span></p>
  <p><span>5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL
    &nbsp;&nbsp;&nbsp; null </span></p>
  <p><span >这带来一些问题。这种字段中的值如何存储和比较？如何对一个包含了</span><span>INTEGER</span><span >、</span><span>REAL</span><span
>、</span><span>TEXT</span><span
>、</span><span>BLOB</span><span
>和</span><span>NULL</span><span
>值的字段排序？一个整数和一个</span><span>BLOB</span><span
>如何比较？哪个更大？它们能相等吗？</span></p>
  <p><span >答案是：具有不同存储类的值可以存储在同一个字段中。可以被排序，因为这些值可以相互比较。有完善定义的规则来做这件事。不同存储类的值可以通过它们各自类的“类值”进行排序，定义如下：</span></p>
  <p><span>1. NULL</span><span style='font-family:
宋体'>存储类具有最低的类值。一个具有</span><span>NULL</span><span style='font-family:
宋体'>存储类的值比所有其它值都小</span><span>(</span><span >包括其它具有</span><span>NULL</span><span >存储类的值</span><span>)</span><span >。在</span><span>NULL</span><span
>值之间，没有特别的可排序值。</span></p>
  <p><span>2. INTEGER</span><span style='font-family:
宋体'>或</span><span>REAL</span><span >存储类值高于</span><span>NULL</span><span >，它们的类值相等。</span><span>INTEGER</span><span >值和</span><span>REAL</span><span >值通过其数值进行比较。</span></p>
  <p><span>3. TEXT</span><span style='font-family:
宋体'>存储类的值比</span><span>INTEGER</span><span >和</span><span>REAL</span><span >高。数值永远比字符串的值低。当两个</span><span>TEXT</span><span >值进行比较时，其值大小由“排序法”决定。</span></p>
  <p><span>4. BLOB</span><span style='font-family:
宋体'>存储类具有最高的类值。具有</span><span>BLOB</span><span style='font-family:
宋体'>类的值大于其它所有类的值。</span><span>BLOB</span><span style='font-family:
宋体'>值之间在比较时使用</span><span>C</span><span >函数</span><span>memcmp()</span><span >。</span></p>
  <p><span >所以，当</span><span>SQLite</span><span
>对一个字段进行排序时，首先按存储类排序，然后再进行类内的排序</span> <span>(NULL</span><span
>类内部各值不必排序</span><span>) </span><span
>。下面的</span><span>SQL</span><span
>说明了存储类值的不同：</span></p>
  <p><span>sqlite&gt; SELECT 3 &lt; 3.142, 3.142 &lt;
    '3.142', '3.142' &lt; x'3000', x'3000' &lt; x'3001'; </span></p>
  <p><span >返回：</span></p>
  <p><span>3 &lt; 3.142&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.142
    &lt; '3.142'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '3.142'
    &lt; x'3000'&nbsp;&nbsp;&nbsp;&nbsp; x'3000' &lt; x'3001' </span></p>
  <p><span>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 </span></p>
  <h3><a name="_Toc245565806"><span >弱类型</span><span>(manifest typing)</span></a></h3>
  <p><span>SQLite</span><span >使用弱类型。</span></p>
  <p><span >看下面的表：</span></p>
  <p><span>CREATE TABLE foo( x integer,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; y text, z real ); </span></p>
  <p><span >向该表插入一条记录：</span></p>
  <p><span>INSERT INTO foo VALUES ('1', '1', '1'); </span></p>
  <p><span >当</span><span>SQLite</span><span
>创建这条记录时，</span><span>x</span><span
>、</span><span>y</span><span style='font-family:
宋体'>和</span><span>z</span><span >这</span><span>3</span><span >个字段中存储的是什么类型呢？答案是</span><span>INTEGER, TEXT</span><span >和</span><span>REAL</span><span >。</span></p>
  <p><span >再看下面例子：</span></p>
  <p><span>CREATE TABLE foo(x, y, z); </span></p>
  <p><span >现在执行同样的插入语句：</span></p>
  <p><span>INSERT INTO foo VALUES ('1', '1', '1'); </span></p>
  <p><span >现在，</span><span>x</span><span
>、</span><span>y</span><span style='font-family:
宋体'>和</span><span>z</span><span >中存储的是什么类型呢？答案是</span><span>TEXT</span><span >、</span><span>TEXT</span><span
>和</span><span>TEXT</span><span
>。</span></p>
  <p><span >那么，是否</span><span>SQLite</span><span
>的字段类型默认为</span><span>TEXT</span><span
>呢？再看，还是第</span><span>2</span><span
>个表，执行如下插入语句：</span></p>
  <p><span>INSERT INTO foo VALUES (1, 1.0, x'10'); </span></p>
  <p><span >现在，</span><span>x</span><span
>、</span><span>y</span><span style='font-family:
宋体'>和</span><span>z</span><span >中存储的是什么类型呢？答案是</span><span>INTEGER</span><span >、</span><span>REAL</span><span
>和</span><span>BLOB</span><span
>。</span></p>
  <p><span >如果你愿意，可以为</span><span>SQLite</span><span >的字段定义类型，这看起来跟其它数据库一样。但这不是必须的，你可以尽管违反类型定义。这是因为在任何情况下，</span><span>SQLite</span><span >都可以接受一个值并推断它的类型。</span></p>
  <p><span >总之，</span><span>SQLite</span><span
>的弱类型可表示为：</span><span>1)</span><span
>字段可以有类型，</span><span>2)</span><span
>类型可以通过值来推断。类型亲和性介绍这两个规定如何相互关联。所谓类型亲和性就是在强类型</span><span>(strict typing)</span><span >和动态类型</span><span>(dynamic typing)</span><span >之间的平衡艺术。</span></p>
  <h3><a name="_Toc245565807"><span >类型亲和性</span><span>(Type Affinity)</span></a></h3>
  <p><span >在</span><span>SQLite</span><span
>中，字段没有类型或域。当给一个字段声明了类型，该字段实际上仅仅具有了该类型的新和性。声明类型和类型亲和性是两回事。类型亲和性预定</span><span>SQLite</span><span >用什么存储类在字段中存储值。在存储一个给定的值时到底</span><span>SQLite</span><span >会在该字段中用什么存储类决定于值的存储类和字段亲和性的结合。我们先来介绍一下字段如何获得它的亲和性。</span></p>
  <h4><span style='font-family:黑体'>字段类型和亲和性</span></h4>
  <p><span >首先，每个字段都具有一种亲和性。共有四种亲和性：</span><span>NUMERIC</span><span >、</span><span>INTEGER</span><span
>、</span><span>TEXT</span><span
>和</span><span>NONE</span><span
>。一个字段的亲和性由它预声明的类型决定。所以，当你为字段声明了类型，从根本上说是为字段指定了亲和性。</span><span>SQLite</span><span >按下面的规则为字段指派亲和性：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >默认的，一个字段默认的亲和性是</span><span>NUMERIC</span><span >。如果一个字段不是</span><span>INTEGER</span><span >、</span><span>TEXT</span><span
>或</span><span>NONE</span><span
>的，那它自动地被指派为</span><span>NUMERIC</span><span
>亲和性。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >如果为字段声明的类型中包含了</span><span>'INT'(</span><span >无论大小写</span><span>)</span><span >，该字段被指派为</span><span>INTEGER</span><span >亲和性。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >如果为字段声明的类型中包含了</span><span>'CHAR'</span><span >、</span><span>'CLOB'</span><span
>或</span><span>'TEXT'(</span><span
>无论大小写</span><span>)</span><span
>，该字段被指派为</span><span>TEXT</span><span
>亲和性。如</span><span>'VARCHAR'</span><span
>包含了</span><span>'CHAR'</span><span
>，所以被指派为</span><span>TEXT</span><span
>亲和性。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >如果为字段声明的类型中包含了</span><span>'BLOB'(</span><span >无论大小写</span><span>)</span><span >，或者没有为该字段声明类型，该字段被指派为</span><span>NONE</span><span >亲和性。</span></p>
  <p><span >注意：如果没有为字段声明类型，该字段的亲和性为</span><span>NONE</span><span >，在这种情况下，所有的值都将以它们本身的</span><span>(</span><span >或从它们的表示法中推断的</span><span>)</span><span >存储类存储。如果你暂时还不确定要往一个字段里放什么内容，或准备将来修改，用</span><span>NONE</span><span >亲和性是一个好的选择。但</span><span>SQLite</span><span >默认的亲和性是</span><span>NUMERIC</span><span >。例如，如果为一定字段声明了类型</span><span>JUJYFRUIT</span><span >，该字段的亲和性不是</span><span>NONE</span><span >，因为</span><span>SQLite</span><span
>不认识这种类型，会给它指派默认的</span><span>NUMERIC</span><span
>亲和性。所以，与其用一个不认识的类型最终得到</span><span>NUMERIC</span><span
>亲和性，还不如不为它指定类型，从而使它得到</span><span>NONE</span><span
>亲和性。</span></p>
  <h4><span style='font-family:黑体'>亲和性和存储</span></h4>
  <p><span >亲和性对值如何存储到字段有影响，规则如下：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >一个</span><span>NUMERIC</span><span
>字段可能包括所有</span><span>5</span><span
>种存储类。一个</span><span>NUMERIC</span><span
>字段具有数字存储类的偏好</span><span>(INTEGER</span><span
>和</span><span>REAL)</span><span
>。当一个</span><span>TEXT</span><span
>值被插入到一个</span><span>NUMERIC</span><span
>字段，将会试图将其转化为</span><span>INTEGER</span><span
>存储类；如果转化失败，将会试图将其转化为</span><span>REAL</span><span
>存储类；如果还是失败，将会用</span><span>TEXT</span><span
>存储类来存储。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >一个</span><span>INTEGER</span><span
>字段的处理很像</span><span>NUMERIC</span><span
>字段。一个</span><span>INTEGER</span><span
>字段会将</span><span>REAL</span><span
>值按</span><span>REAL</span><span
>存储类存储。也就是说，如果这个</span><span>REAL</span><span
>值没有小数部分，就会被转化为</span><span>INTEGER</span><span
>存储类。</span><span>INTEGER</span><span
>字段将会试着将</span><span>TEXT</span><span
>值按</span><span>REAL</span><span
>存储；如果转化失败，将会试图将其转化为</span><span>INTEGER</span><span
>存储类；如果还是失败，将会用</span><span>TEXT</span><span
>存储类来存储。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >一个</span><span>TEXT</span><span
>字段将会把所有的</span><span>INTEGER</span><span
>或</span><span>REAL</span><span
>值转化为</span><span>TEXT</span><span
>。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >一个</span><span>NONE</span><span
>字段不试图做任何类型转化。所有值按它们本身的存储类存储。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >没有字段试图向</span><span>NULL</span><span
>或</span><span>BLOB</span><span
>值转化――如无论用什么亲和性。</span><span>NULL</span><span
>和</span><span>BLOB</span><span
>值永远都按本来的方式存储在所有字段。</span></p>
  <p><span >这些规则初看起来比较复杂，但总的设计目标很简单，就是：如果你需要，</span><span>SQLite</span><span >会尽量模仿其它的关系型数据库。也就是说，如果你将</span><span>SQLite</span><span >看成是一个传统数据库，类型亲和性将会按你的期望来存储值。如果你声明了一个</span><span>INTEGER</span><span >字段，并向里面放一个整数，就会按整数来存储。如果你声明了一个具有</span><span>TEXT, CHAR</span><span >或</span><span>VARCHAR</span><span >类型的字段并向里放一个整数，整数将会转化为</span><span>TEXT</span><span >。可是，如果你不遵守这些规定，</span><span>SQLite</span><span >也会找到办法来存储你的值。</span></p>
  <h4><span style='font-family:黑体'>亲和性的运行</span></h4>
  <p><span >让我们看一些例子来了解亲和性是如何工作的：</span></p>
  <p><span>sqlite&gt; CREATE TABLE domain(i int, n
    numeric, t text, b blob);</span></p>
  <p><span>sqlite&gt; INSERT INTO domain VALUES
    (3.142,3.142,3.142,3.142);</span></p>
  <p><span>sqlite&gt; INSERT INTO domain VALUES
    ('3.142','3.142','3.142','3.142');</span></p>
  <p><span>sqlite&gt; INSERT INTO domain VALUES
    (3142,3142,3142,3142);</span></p>
  <p><span>sqlite&gt; INSERT INTO domain VALUES
    (x'3142',x'3142',x'3142',x'3142');</span></p>
  <p><span>sqlite&gt; INSERT INTO domain VALUES
    (null,null,null,null);</span></p>
  <p><span>sqlite&gt; SELECT ROWID,typeof(i),typeof(n),typeof(t),typeof(b)
    FROM domain;</span></p>
  <p><span >返回：</span></p>
  <p><span>rowid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typeof(i)&nbsp; typeof(n) typeof(t)&nbsp; typeof(b)</span></p>
  <p><span>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real </span></p>
  <p><span>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text </span></p>
  <p><span>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp; text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer </span></p>
  <p><span>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blob </span></p>
  <p><span>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null </span></p>
  <p><span >下面的</span><span>SQL</span><span
>说明存储类的排序情况：</span></p>
  <p><span>sqlite&gt; SELECT ROWID, b, typeof(b) FROM
    domain ORDER BY b; </span></p>
  <p><span >返回：</span></p>
  <p><span>rowid b typeof(b) </span></p>
  <p><span>5 NULL null </span></p>
  <p><span>1 3.142 real </span></p>
  <p><span>3 3142 integer </span></p>
  <p><span>2 3.142 text </span></p>
  <p><span>4 1B blob </span></p>
  <p><span>sqlite&gt; SELECT ROWID, b, typeof(b),
    b&lt;1000 FROM domain ORDER BY b; </span></p>
  <p><span >返回：</span></p>
  <p><span>rowid b typeof(b) b&lt;1000 </span></p>
  <p><span>NULL null NULL </span></p>
  <p><span>1 3.142 real 1</span></p>
  <p><span>3 3142 integer 1</span></p>
  <p><span>2 3.142 text 0</span></p>
  <p><span>4 1B blob 0</span></p>
  <h4><span style='font-family:黑体'>存储类和类型转换</span></h4>
  <p><span >关于存储类，需要关注的另一件事是：存储类有时会影响到值如何进行比较。特别是</span><span>SQLite</span><span >有时在进行比较之前，会将值在数字存储类</span><span>(INTEGER</span><span >和</span><span>REAL)</span><span >和</span><span>TEXT</span><span
>之间进行转换。为进行二进制的比较，遵循如下规则：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >当一个字段值与一个表达式的结果进行比较，字段的亲和性会在比较之前应用于表达式的结果。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >当两个字段值进行比较，如果一个字段拥有</span><span>INTEGER</span><span >或</span><span>NUMERIC</span><span
>亲和性而另一个没有，</span><span>NUMERIC</span><span
>亲和性会应用于非</span><span>NUMERIC</span><span
>字段的</span><span>TEXT</span><span
>值。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >当两个表达式进行比较，</span><span>SQLite</span><span
>不做任何转换。如果两个表达式有相似的存储类，则直接按它们的值进行比较；否则按类值进行比较。</span></p>
  <p><span >请看下面例子：</span></p>
  <p><span>sqlite&gt; select
    ROWID,b,typeof(i),i&gt;'2.9' from domain ORDER BY b; </span></p>
  <p><span>rowid b typeof(i i&gt;'2.9' </span></p>
  <p><span>5 NULL null NULL </span></p>
  <p><span>1 3.142 real 1</span></p>
  <p><span>3 3142 integer 1</span></p>
  <p><span>2 3.142 real 1</span></p>
  <p><span>4 1B blob 1 </span></p>
  <h4><span style='font-family:黑体'>也算是“强类型</span><span>(STRICT TYPING)</span><span
style='font-family:黑体'>”</span></h4>
  <p><span >如果你需要比类型亲和性更强的域完整性，可以使用</span><span>CHECK</span><span >约束。你可以使用一个单独的内置函数和一个</span><span>CHECK</span><span >约束来实现一个“假的”强类型。</span><span> </span></p>
  <h2><a name="_Toc245565808"><span style='font-family:黑体'>事务</span></a></h2>
  <p><span >事务定义了一组</span><span>SQL</span><span
>命令的边界，这组命令或者作为一个整体被全部执行，或者都不执行。事务的典型实例是转帐。</span></p>
  <h3><a name="_Toc245565809"><span >事务的范围</span></a></h3>
  <p><span >事务由</span><span>3</span><span
>个命令控制：</span><span>BEGIN</span><span
>、</span><span>COMMIT</span><span
>和</span><span>ROLLBACK</span><span
>。</span><span>BEGIN</span><span
>开始一个事务，之后的所有操作都可以取消。</span><span>COMMIT</span><span
>使</span><span>BEGIN</span><span
>后的所有命令得到确认；而</span><span>ROLLBACK</span><span
>还原</span><span>BEGIN</span><span
>之后的所有操作。如：</span></p>
  <p><span>sqlite&gt; BEGIN;</span></p>
  <p><span>sqlite&gt; DELETE FROM foods;</span></p>
  <p><span>sqlite&gt; ROLLBACK;</span></p>
  <p><span>sqlite&gt; SELECT COUNT(*) FROM foods;</span></p>
  <p><span>COUNT(*)</span></p>
  <p><span>412</span></p>
  <p><span >上面开始了一个事务，先删除了</span><span>foods</span><span >表的所有行，但是又用</span><span>ROLLBACK</span><span >进行了回卷。再执行</span><span>SELECT</span><span >时发现表中没发生任何改变。</span></p>
  <p><span>SQLite</span><span >默认情况下，每条</span><span>SQL</span><span >语句自成事务</span><span>(</span><span >自动提交模式</span><span>)</span><span
>。</span></p>
  <h3><a name="_Toc245565810"><span >冲突解决</span></a></h3>
  <p><span >如前所述，违反约束会导致事务的非法结束。大多数数据库</span><span>(</span><span >管理系统</span><span>)</span><span
>都是简单地将前面所做的修改全部取消。</span></p>
  <p><span>SQLite</span><span >有其独特的方法来处理约束违反</span><span>(</span><span >或说从约束违反中恢复</span><span>)</span><span >，被称为冲突解决。</span></p>
  <p><span >如：</span></p>
  <p><span>sqlite&gt; UPDATE foods SET id=800-id; </span></p>
  <p><span>SQL error: PRIMARY KEY must be unique </span></p>
  <p><span>SQLite</span><span >提供</span><span>5</span><span >种冲突解决方案：</span><span>REPLACE</span><span >、</span><span>IGNORE</span><span
>、</span><span>FAIL</span><span
>、</span><span>ABORT</span><span
>和</span><span>ROLLBACK</span><span
>。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>REPLACE: </span><span >当发违反了唯一完整性，</span><span>SQLite</span><span >将造成这种违反的记录删除，替代以新插入或修改的新记录，</span><span>SQL</span><span >继续执行，不报错。</span><span> </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>IGNORE </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>FAIL </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>ABORT </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>ROLLBACK </span></p>
  <h3><a name="_Toc245565811"><span >数据库锁</span></a></h3>
  <p><span >在</span><span>SQLite</span><span
>中，锁和事务是紧密联系的。为了有效地使用事务，需要了解一些关于如何加锁的知识。</span></p>
  <p><span>SQLite</span><span >采用粗放型的锁。当一个连接要写数据库，所有其它的连接被锁住，直到写连接结束了它的事务。</span><span>SQLite</span><span >有一个加锁表，来帮助不同的写数据库都能够在最后一刻再加锁，以保证最大的并发性。</span></p>
  <p><span>SQLite</span><span >使用锁逐步上升机制，为了写数据库，连接需要逐级地获得排它锁。</span><span>SQLite</span><span >有</span><span>5</span><span
>个不同的锁状态：未加锁</span><span>(UNLOCKED)</span><span
>、共享</span><span>(SHARED)</span><span
>、保留</span><span>(RESERVED)</span><span
>、未决</span><span>(PENDING)</span><span
>和排它</span><span>(EXCLUSIVE)</span><span
>。每个数据库连接在同一时刻只能处于其中一个状态。每种状态</span><span>(</span><span
>未加锁状态除外</span><span>)</span><span
>都有一种锁与之对应。</span></p>
  <p><span >最初的状态是未加锁状态，在此状态下，连接还没有存取数据库。当连接到了一个数据库，甚至已经用</span><span>BEGIN</span><span >开始了一个事务时，连接都还处于未加锁状态。</span></p>
  <p><span >未加锁状态的下一个状态是共享状态。为了能够从数据库中读</span><span>(</span><span >不写</span><span>)</span><span
>数据，连接必须首先进入共享状态，也就是说首先要获得一个共享锁。多个连接可以同时获得并保持共享锁，也就是说多个连接可以同时从同一个数据库中读数据。但哪怕只有一个共享锁还没有释放，也不允许任何连接写数据库。</span></p>
  <p><span >如果一个连接想要写数据库，它必须首先获得一个保留锁。一个数据库上同时只能有一个保留锁。保留锁可以与共享锁共存，保留锁是写数据库的第</span><span>1</span><span >阶段。保留锁即不阻止其它拥有共享锁的连接继续读数据库，也不阻止其它连接获得新的共享锁。</span></p>
  <p><span >一旦一个连接获得了保留锁，它就可以开始处理数据库修改操作了，尽管这些修改只能在缓冲区中进行，而不是实际地写到磁盘。对读出内容所做的修改保存在内存缓冲区中。</span></p>
  <p><span >当连接想要提交修改</span><span>(</span><span >或事务</span><span>)</span><span
>时，需要将保留锁提升为排它锁。为了得到排它锁，还必须首先将保留锁提升为未决锁。获得未决锁之后，其它连接就不能再获得新的共享锁了，但已经拥有共享锁的连接仍然可以继续正常读数据库。此时，拥有未决锁的连接等待其它拥有共享锁的连接完成工作并释放其共享锁。</span></p>
  <p><span >一旦所有其它共享锁都被释放，拥有未决锁的连接就可以将其锁提升至排它锁，此时就可以自由地对数据库进行修改了。所有以前对缓冲区所做的修改都会被写到数据库文件。</span></p>
  <h3><a name="_Toc245565812"><span >死锁</span></a></h3>
  <p><span >为什么需要了解锁的机制呢？为了避免死锁。</span></p>
  <p><span >考虑下面表</span><span>4-7</span><span
>所假设的情况。两个连接――</span><span>A</span><span
>和</span><span>B</span><span style='font-family:
宋体'>――同时但完全独立地工作于同一个数据库。</span><span>A</span><span style='font-family:
宋体'>执行第</span><span>1</span><span >条命令，</span><span>B</span><span >执行第</span><span>2</span><span
>、</span><span>3</span><span style='font-family:
宋体'>条，等等。</span></p>
  <p><span >表</span><span>4-7 </span><span
>一个死锁的假设情况</span></p>
  <table border=1 cellspacing=0 cellpadding=0>
    <tr>
      <td width=277 valign=top><p align=center style='text-align:center'><span>A</span><span
  >连接</span></p></td>
      <td width=275 valign=top><p align=center style='text-align:center'><span>B</span><span
  >连接</span></p></td>
    </tr>
    <tr>
      <td width=277 valign=top><p><span>sqlite&gt; BEGIN;</span></p></td>
      <td width=275 valign=top>&nbsp;</td>
    </tr>
    <tr>
      <td width=277 valign=top>&nbsp;</td>
      <td width=275 valign=top><p><span>sqlite&gt; BEGIN;</span></p></td>
    </tr>
    <tr>
      <td width=277 valign=top>&nbsp;</td>
      <td width=275 valign=top><p><span>sqlite&gt; INSERT INTO foo VALUES ('x');</span></p></td>
    </tr>
    <tr>
      <td width=277 valign=top><p><span>sqlite&gt; SELECT * FROM foo;</span></p></td>
      <td width=275 valign=top>&nbsp;</td>
    </tr>
    <tr>
      <td width=277 valign=top>&nbsp;</td>
      <td width=275 valign=top><p><span>sqlite&gt; COMMIT;</span></p></td>
    </tr>
    <tr>
      <td width=277 valign=top>&nbsp;</td>
      <td width=275 valign=top><p><span>SQL error: database is locked</span></p></td>
    </tr>
    <tr>
      <td width=277 valign=top><p><span>sqlite&gt; INSERT INTO foo VALUES ('x');</span></p></td>
      <td width=275 valign=top>&nbsp;</td>
    </tr>
    <tr>
      <td width=277 valign=top><p><span>SQL error: database is locked</span></p></td>
      <td width=275 valign=top>&nbsp;</td>
    </tr>
  </table>
  <p><span >两个连接都在死锁中结束。</span><span>B</span><span >首先尝试写数据库，也就拥有了一个未决锁。</span><span>A</span><span >再试图写，但当其</span><span>INSERT</span><span >语句试图将共享锁提升为保留锁时失败。</span></p>
  <p><span >为了讨论的方便，假设连接</span><span>A</span><span >和</span><span>B</span><span
>都一直等待数据库可写。那么此时，其它的连接甚至都不能够再读数据库了，因为</span><span>B</span><span >拥有未决锁</span><span>(</span><span
>它能阻止其它连接获得共享锁</span><span>)</span><span
>。那么时此，不仅</span><span>A</span><span
>和</span><span>B</span><span style='font-family:
宋体'>不能工作，其它所有进程都不能再操作此数据库了。</span></p>
  <p><span >如果避免此情况呢？当然不能让</span><span>A</span><span >和</span><span>B</span><span
>通过谈判解决，因为它们甚至不知道彼此的存在。答案是采用正确的事务类型来完成工作。</span></p>
  <h3><a name="_Toc245565813"><span >事务的种类</span></a></h3>
  <p><span>SQLite</span><span >有三种不同的事务，使用不同的锁状态。事务可以开始于：</span><span>DEFERRED</span><span >、</span><span>MMEDIATE</span><span >或</span><span>EXCLUSIVE</span><span >。事务类型在</span><span>BEGIN</span><span >命令中指定：</span></p>
  <p><span>BEGIN [ DEFERRED | IMMEDIATE | EXCLUSIVE ]
    TRANSACTION; </span></p>
  <p><span >一个</span><span>DEFERRED</span><span
>事务不获取任何锁</span><span>(</span><span
>直到它需要锁的时候</span><span>)</span><span
>，</span><span>BEGIN</span><span
>语句本身也不会做什么事情</span><span>――</span><span
>它开始于</span><span>UNLOCK</span><span
>状态。默认情况下就是这样的，如果仅仅用</span><span>BEGIN</span><span
>开始一个事务，那么事务就是</span><span>DEFERRED</span><span
>的，同时它不会获取任何锁；当对数据库进行第一次读操作时，它会获取</span><span>SHARED</span><span
>锁；同样，当进行第一次写操作时，它会获取</span><span>RESERVED</span><span
>锁。</span></p>
  <p><span >由</span><span>BEGIN</span><span
>开始的</span><span>IMMEDIATE</span><span
>事务会尝试获取</span><span>RESERVED</span><span
>锁。如果成功，</span><span>BEGIN IMMEDIATE</span><span
>保证没有别的连接可以写数据库。但是，别的连接可以对数据库进行读操作；但是，</span><span>RESERVED</span><span >锁会阻止其它连接的</span><span>BEGIN IMMEDIATE</span><span >或者</span><span>BEGIN EXCLUSIVE</span><span >命令，当其它连接执行上述命令时，会返回</span><span>SQLITE_BUSY</span><span >错误。这时你就可以对数据库进行修改操作了，但是你还不能提交，当你</span><span>COMMIT</span><span >时，会返回</span><span>SQLITE_BUSY</span><span >错误，这意味着还有其它的读事务没有完成，得等它们执行完后才能提交事务。</span></p>
  <p><span>EXCLUSIVE</span><span style='font-family:
宋体'>事务会试着获取对数据库的</span><span>EXCLUSIVE</span><span style='font-family:
宋体'>锁。这与</span><span>IMMEDIATE</span><span >类似，但是一旦成功，</span><span>EXCLUSIVE</span><span >事务保证没有其它的连接，所以就可对数据库进行读写操作了。</span></p>
  <p><span >上节那个例子的问题在于两个连接最终都想写数据库，但是它们都没有放弃各自原来的锁，最终，</span><span>SHARED</span><span >锁导致了问题的出现。如果两个连接都以</span><span>BEGIN IMMEDIATE</span><span >开始事务，那么死锁就不会发生。在这种情况下，在同一时刻只能有一个连接进入</span><span>BEGIN IMMEDIATE</span><span >，其它的连接就得等待。</span><span>BEGIN IMMEDIATE</span><span >和</span><span>BEGIN EXCLUSIVE</span><span >通常被写事务使用。就像同步机制一样，它防止了死锁的产生。</span></p>
  <p><span >基本的准则是：如果你正在使用的数据库没有其它的连接，用</span><span>BEGIN</span><span >就足够了。但是，如果你使用的数据库有其它的连接也会对数据库进行写操作，就得使用</span><span>BEGIN IMMEDIATE</span><span >或</span><span>BEGIN EXCLUSIVE</span><span >开始你的事务。</span></p>
  <h2><a name="_Toc245565814"><span style='font-family:黑体'>数据库管理</span></a></h2>
  <p><span >数据库管理用于控制数据库如何操作。从</span><span>SQL</span><span >的角度，数据库管理包括一些主题如会视图</span><span>(view)</span><span >、触发器</span><span>(trigger)</span><span >和索引</span><span>(indexe)</span><span >。另外，</span><span>SQLite</span><span >包括自己一些独特的管理，如数据库</span><span>pragma</span><span >，可以用来配置数据库参数。</span></p>
  <h3><a name="_Toc245565815"><span >视图</span></a></h3>
  <h4><span style='font-family:黑体'>物化的视图</span></h4>
  <p><span >在关系模型中称为数据可修改的视图。</span></p>
  <h3><a name="_Toc245565816"><span >索引</span></a></h3>
  <h4><span style='font-family:黑体'>索引的利用</span></h4>
  <p><span >理解索引何时被利用及何时不被利用是重要的。</span><span>SQLite</span><span >有明确的条件来决定是否使用索引。如果可能，在</span><span>WHERE</span><span >子名中有下列表达式时，</span><span>SQLite</span><span >将使用单字段索引：</span></p>
  <p><span>column {=|&gt;|&gt;=|&lt;=|&lt;} expression </span></p>
  <p><span>expression {=|&gt;|&gt;=|&lt;=|&lt;} column </span></p>
  <p><span>column IN (expression-list) </span></p>
  <p><span>column IN (subquery) </span></p>
  <p><span >多字段索引的使用有很明确的条件。这最好用例子来说。假设你有如下定义的一个表：</span></p>
  <p><span>CREATE TABLE foo (a,b,c,d); </span></p>
  <h3><a name="_Toc245565817"><span >触发器</span></a></h3>
  <p><span >当特定的表上发生特定的数据库事件时，触发器会执行特定的</span><span>SQL</span><span >命令。创建触发器的一般语法如下：</span></p>
  <p><span>CREATE [TEMP|TEMPORARY] TRIGGER name
    [BEFORE|AFTER]</span></p>
  <p><span>&nbsp;[INSERT|DELETE|UPDATE|UPDATE OF
    columns] ON table </span></p>
  <p><span>action </span></p>
  <h4><span>UPDATE</span><span style='font-family:黑体'>触发器</span></h4>
  <p><span >不同于</span><span>INSERT
    and DELETE</span><span >触发器，</span><span>UPDATE</span><span
>触发器可以定义在一个表的特定的字段上。</span><span>The general
    form of this kind of trigger is as follows: </span></p>
  <p><span>CREATE TRIGGER name [BEFORE|AFTER] UPDATE
    OF column ON table </span></p>
  <p><span>action </span></p>
  <p><span>The following is a SQL script that shows an
    UPDATE trigger in action: </span></p>
  <p><span>.h on </span></p>
  <p><span>.m col </span></p>
  <p><span>.w 50 </span></p>
  <p><span>.echo on </span></p>
  <p><span>CREATE TEMP TABLE log(x); </span></p>
  <p><span>CREATE TEMP TRIGGER foods_update_log UPDATE
    of name ON foods </span></p>
  <p><span>BEGIN</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; INSERT INTO log
    VALUES('updated foods: new name=' || NEW.name); </span></p>
  <p><span>END; </span></p>
  <p><span>BEGIN;</span></p>
  <p><span>UPDATE foods set name='JUJYFRUIT' where
    name='JujyFruit';</span></p>
  <p><span>SELECT * FROM log;</span></p>
  <p><span>ROLLBACK;</span></p>
  <h4><span style='font-family:黑体'>错误处理</span></h4>
  <p><span >定义一个事件的</span><span>before</span><span
>触发器给了你一个阻止事件发生的机会。</span><span>before</span><span
>触发器可以实现新的完整性约束。</span><span>SQLite</span><span
>为触发器提供了一个称为</span><span>RAISE()</span><span
>的特殊</span><span>SQL</span><span
>函数，可以在触发器体中唤起一个错误。</span><span>RAISE</span><span
>如下定义：</span></p>
  <p><span>RAISE(resolution, error_message); </span></p>
  <h4><span style='font-family:黑体'>使用触发器的外键约束</span></h4>
  <p><span >在</span><span>SQLite</span><span
>中，触发器最有趣的应用之一是实现外键约束。为了进一步了解触发器，我将用这个想法在</span><span>foods</span><span >表和</span><span>food_types</span><span
>表之间实现外键。</span></p>
  <h3><a name="_Toc245565818"><span >附加</span><span>(Attaching)</span></a><span >数据库</span><span> </span></h3>
  <p><span>SQLite</span><span >允许你用</span><span>ATTACH</span><span >命令将多个数据库“附加”到当前连接上来。当你附加了一个数据库，它的所有内容在当前数据库文件的全局范围内都是可存取的。</span><span>ATTACH</span><span >的语法为：</span></p>
  <p><span>ATTACH [DATABASE] filename AS
    database_name; </span></p>
  <h3><a name="_Toc245565819"><span >清洁数据库</span></a></h3>
  <p><span>SQLite</span><span >有两个命令用于数据库清洁――</span><span>REINDEX</span><span >和</span><span>VACUUM</span><span
>。</span><span>REINDEX</span><span
>用于重建索引，有两种形式：</span></p>
  <p><span>REINDEX collation_name;</span></p>
  <p><span>REINDEX table_name|index_name;</span></p>
  <p><span >第一种形式利用给定的排序法名称重新建立所有的索引。</span><span> </span></p>
  <p><span>VACUUM</span><span >通过重建数据库文件来清除数据库内所有的未用空间。</span><span> </span></p>
  <h3><a name="_Toc245565820"><span >数据库配置</span></a></h3>
  <p><span>SQLite</span><span >没有配置文件。所有这些配置参数都是用</span><span>pragma</span><span >来实现。</span><span>Pragma</span><span >以独特的方式工作，有些像变量，又有些像命令。</span></p>
  <h4><span style='font-family:黑体'>连接缓冲区大小</span></h4>
  <p><span >缓冲区尺寸</span><span>pragma</span><span
>控制一个连接可以在内存中使用多少个数据库页。要查看当前缓冲区大小的默认值，执行：</span></p>
  <p><span lang=FR>sqlite&gt; PRAGMA cache_size; </span></p>
  <p><span lang=FR>cache_size </span></p>
  <p><span lang=FR>2000 </span></p>
  <p><span >要改变缓冲区大小，执行：</span></p>
  <p><span lang=FR>sqlite&gt; PRAGMA cache_size=10000; </span></p>
  <p><span>sqlite&gt; PRAGMA cache_size; </span></p>
  <p><span>cache_size </span></p>
  <p><span>10000 </span></p>
  <h4><span style='font-family:黑体'>获得数据库信息</span></h4>
  <p><span >可以使用数据库的</span><span>schema pragma</span><span >来获得数据库信息，定义如下：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>database_list: Lists information about all
    attached databases. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>index_info: Lists information about the columns
    within an index. It takes an index name as an argument. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>index_list: Lists information about the indexes
    in a table. It takes a table name as an argument. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>table_info: Lists information about all columns
    in a table.</span></p>
  <p><span >请看下面示例：</span></p>
  <p><span>sqlite&gt; PRAGMA database_list;</span></p>
  <p><span>seq name file</span></p>
  <p><span>0 main /tmp/foods.db</span></p>
  <p><span>2 db2 /tmp/db </span></p>
  <p><span>sqlite&gt; CREATE INDEX foods_name_type_idx
    ON foods(name,type_id);</span></p>
  <p><span>sqlite&gt; PRAGMA
    index_info(foods_name_type_idx);</span></p>
  <p><span>seqn cid name</span></p>
  <p><span>0 2 name</span></p>
  <p><span>1 1 type_id</span></p>
  <p><span>sqlite&gt; PRAGMA index_list(foods);</span></p>
  <p><span>seq name unique</span></p>
  <p><span>0 foods_name_type_idx 0</span></p>
  <p><span>sqlite&gt; PRAGMA table_info(foods);</span></p>
  <p><span>cid name type notn dflt pk</span></p>
  <p><span>0 id integer 0 1</span></p>
  <p><span>1 type_id integer 0 0</span></p>
  <p><span>2 name text 0 0</span></p>
  <h4><span style='font-family:黑体'>页大小、编码和自动排空</span></h4>
  <p><span>The database page size, encoding, and
    autovacuuming must be set before a database is created. That is, in order to
    alter the defaults, you must first set these pragmas before creating any
    database objects in a new database. The defaults are a 1,024-byte page size and
    UTF-8 encoding. SQLite supports page sizes ranging from 512 to 32,786 bytes, in
    powers of 2. Supported encodings are UTF-8, UTF-16le (little-endian UTF-16
    encoding), and UTF-16be (big-endian UTF-16 encoding). </span></p>
  <p><span >如果使用</span><span>auto_vacuum
    pragma</span><span >，可以使数据库自动维持最小。一般情况下，当一个事务从数据库中删除了数据并提交后，数据库文件的大小保持不变。当使用了</span><span>auto_vacuum pragma</span><span >后，当删除事务提交时，数据库文件会自动缩小。</span></p>
  <h3><a name="_Toc245565821"><span >系统表</span></a></h3>
  <p><span>sqlite_master</span><span style='font-family:
宋体'>表是一个系统表，它包含数据库中所有表、视图、索引和触发器的信息。例如，</span><span>foods</span><span
>的当前内容如下：</span></p>
  <p><span>sqlite&gt; SELECT type, name, rootpage FROM
    sqlite_master; </span></p>
  <p><span>type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rootpage </span></p>
  <p><span>table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; episodes
    2 </span></p>
  <p><span>table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foods
    3 </span></p>
  <p><span>table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foods_episodes
    4 </span></p>
  <p><span>table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; food_types
    5 </span></p>
  <p><span>index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foods_name_idx
    30 </span></p>
  <p><span>table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqlite_sequence
    50 </span></p>
  <p><span>trigger&nbsp;&nbsp;&nbsp;&nbsp; foods_update_trg
    0 </span></p>
  <p><span>trigger&nbsp;&nbsp;&nbsp;&nbsp; foods_insert_trg
    0 </span></p>
  <p><span>trigger&nbsp;&nbsp;&nbsp;&nbsp; foods_delete_trg
    0 </span></p>
  <p><span >有关</span><span>sqlite_master</span><span
>表的结构请参考第</span><span>2</span><span
>章的“获得数据库的</span><span>Schema</span><span
>信息”一节。</span></p>
  <p><span>sqlite_master</span><span style='font-family:
宋体'>包含一个称为</span><span>sql</span><span >的字段，存储了创建对象的</span><span>DDL</span><span >命令，如：</span></p>
  <p><span>sqlite&gt; SELECT sql FROM sqlite_master
    WHERE name='foods_update_trg'; </span></p>
  <p><span >返回：</span></p>
  <p><span>CREATE TRIGGER foods_update_trg </span></p>
  <p><span>BEFORE UPDATE OF type_id ON foods </span></p>
  <p><span>BEGIN</span></p>
  <p><span>&nbsp;SELECT CASE</span></p>
  <p><span>&nbsp;WHEN (SELECT id FROM food_types WHERE
    id=NEW.type_id) IS NULL</span></p>
  <p><span>&nbsp;THEN RAISE( ABORT,</span></p>
  <p><span>&nbsp;'Foreign Key Violation: foods.type_id
    is not in food_types.id') </span></p>
  <p><span>END; </span></p>
  <p><span>END </span></p>
  <h3><a name="_Toc245565822"><span >查看</span><span>Query</span></a><span >的执行</span></h3>
  <p><span >可以用</span><span>EXPLAIN</span><span
>命令查看</span><span>SQLite</span><span
>执行一个查询的方法。</span><span>EXPLAIN</span><span
>列出一个</span><span>SQL</span><span
>命令编译后的</span><span>VDBE</span><span
>程序。</span></p>
  <p><span>sqlite&gt; .m col</span></p>
  <p><span>sqlite&gt; .h on</span></p>
  <p><span>sqlite&gt; .w 4 15 3 3 3 10 3</span></p>
  <p><span>sqlite&gt; EXPLAIN SELECT * FROM foods; </span></p>
  <p><span>addr&nbsp;
    opcode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    p1&nbsp;&nbsp; p2&nbsp;&nbsp; p3&nbsp;&nbsp;
    p4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p5&nbsp;&nbsp; comment</span></p>
  <p><span>----&nbsp;
    ---------------&nbsp; ---&nbsp; ---&nbsp; ---&nbsp; ----------&nbsp; ---&nbsp;
    -------</span></p>
  <p><span>0&nbsp;&nbsp;&nbsp;&nbsp;
    Trace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>1&nbsp;&nbsp;&nbsp;&nbsp;
    Goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>2&nbsp;&nbsp;&nbsp;&nbsp;
    OpenRead &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;
    7&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00</span></p>
  <p><span>3&nbsp;&nbsp;&nbsp;&nbsp;
    Rewind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>4&nbsp;&nbsp;&nbsp;&nbsp;
    Rowid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>5&nbsp;&nbsp;&nbsp;&nbsp;
    Column&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
    2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>6&nbsp;&nbsp;&nbsp;&nbsp;
    Column&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;
    3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>7&nbsp;&nbsp;&nbsp;&nbsp;
    ResultRow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
    3&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>8&nbsp;&nbsp;&nbsp;&nbsp;
    Next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    01</span></p>
  <p><span>9&nbsp;&nbsp;&nbsp;&nbsp;
    Close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>10&nbsp;&nbsp;&nbsp;
    Halt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>11&nbsp;&nbsp;&nbsp;
    Transaction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>12&nbsp;&nbsp;&nbsp;
    VerifyCookie&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 40&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span>13&nbsp;&nbsp;&nbsp;
    TableLock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    7&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    foods&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00</span></p>
  <p><span>14&nbsp;&nbsp;&nbsp;
    Goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <br
clear=all style='page-break-before:always'>
  <h1><a name="_Toc245565823"><span >第</span><span>5</span></a><span >章</span><span>&nbsp; </span><span >设计和概念</span></h1>
  <p><span >本章为后面的</span><span>3</span><span
>章打下基础，这几章专注于</span><span>SQLite</span><span
>编程。这几章专注于作为程序员，在编码时你所应该了解的有关</span><span>SQLite</span><span
>的东西。无论你是用</span><span>C</span><span
>语言对</span><span>SQLite</span><span
>进行编程，还是用其它的编程语言，这些内容都是重要的。它不仅帮助你了解</span><span>API</span><span >，还包括部分有关</span><span>SQLite</span><span >的体系结构和实现方法的内容。具备了这些知识，你就可以编出更好的代码，这些代码执行得更快，且不会产生死锁、不可预知错误等问题。你会看到</span><span>SQLite</span><span >如何处理你的代码，你还会变得更加自信，因为你知道自己正前进在解决问题的正确方向上。</span></p>
  <p><span >你不需要从头到尾地读内部代码才能理解这些内容，你也不必是一个</span><span>C</span><span >程序员。</span><span>SQLite</span><span
>的设计和概念都是非常直观和容易理解的。只有一小部分内容你需要知道，本章就介绍这些内容。</span></p>
  <p><span>1</span><span >．明显地，你需要知道</span><span>API</span><span >是如何工作的。于是本章从一个对</span><span>API</span><span >概念性的介绍开始，图示了主要的数据结构，</span><span>API</span><span >的一般设计和它主要的函数。还可以看到</span><span>SQLite</span><span >的一些主要的子系统，这些子系统在查询的处理过程中起着重要作用。</span></p>
  <p><span>2</span><span >．除了知道什么函数做什么，你还需要从比</span><span>API</span><span >高的角度来看问题，看看所有这些函数在事务</span><span>(transactions)</span><span >中是如何操作的。</span><span>SQLite</span><span >的所有的工作都是在事务中完成的。于是，你需要知道在</span><span>API</span><span >之下，事务如何按照锁的约束来工作。如果你不知道锁是如何操作的，这些锁就会导致问题。当对锁有所了解之后，你不仅可以避免潜在的并发问题，还可以通过编程控制它们来优化你的查询。</span></p>
  <p><span>3</span><span >．最后，你还必须理解如何将这些内容应用于编码。本章的最后部分会将</span><span>3</span><span >个主题结合在一起――</span><span>API</span><span >、事务和锁，并且看一看好代码与坏代码的区别。</span></p>
  <p><span >空注：本章看得还是比较仔细的，翻译的也比较全。</span></p>
  <h2><a name="_Toc245565824"><span>API</span></a></h2>
  <p><span >从功能的角度来区分，</span><span>SQLite</span><span >的</span><span>API</span><span
>可分为两类：核心</span><span>API</span><span
>的扩充</span><span>API</span><span
>。核心</span><span>API</span><span
>由所有完成基本数据库操作的函数构成，包括：连接数据库、执行</span><span>SQL</span><span
>和遍历结果集。它还包括一些功能函数，用来完成字符串格式化、操作控制、调试和错误处理等任务。扩充</span><span>API</span><span >提供不同的方法来扩展</span><span>SQLite</span><span >，它使你能够创建自定义的</span><span>SQL</span><span >扩展，并与</span><span>SQLite</span><span
>本身的</span><span>SQL</span><span
>相集成。</span></p>
  <h3><a name="_Toc245565825"><span>SQLite</span></a><span
>版本</span><span>3</span><span
>的新特性</span></h3>
  <p><span >在开始之前，我们先讨论一下</span><span>SQLite</span><span >版本</span><span>3</span><span
>的新特色：</span></p>
  <p><span >一、首先，</span><span>SQLite</span><span
>的</span><span>API</span><span
>被彻底重新设计了，并具有了许多新特性。由第二版的</span><span>15</span><span
>个函数增加到</span><span>88</span><span
>个函数。这些函数包括支持</span><span>UTF-8</span><span
>和</span><span>UTF-16</span><span
>编码的功能函数。</span><span>SQLite3</span><span
>有一个更方便的查询模式，使查询的预处理更容易并且支持新的参数绑定方法。</span><span>SQLite3</span><span >还增加了用户定义的排序序列、</span><span>CHECK</span><span >约束、</span><span>64</span><span
>位的键值和新的查询优化。</span></p>
  <p><span >二、在后端大大地改进了并发性能。加锁子系统引进了一种新的锁升级模型，解决了第二版中的写进程饿死的问题。这种模型保证写进程按照先来先服务的算法得到排它锁</span><span>(Exclusive Lock)</span><span >。甚至，写进程通过把结果写入临时缓冲区</span><span>(Temporary Buffer)</span><span >，可以在得到排它锁之前就开始工作。这对于写要求较高的应用，性能可提高</span><span>400%</span><span >。</span></p>
  <p><span >三、</span><span>SQLite
    3</span><span >包含一个改进了的</span><span>B-tree</span><span
>模型。现在对库表使用</span><span>B+tree</span><span
>，大大提高查询效率，存储大数据字段更有效，并可以从磁盘上删除不用了的字段。其结果是数据库文件的体积减小了</span><span>25C35%</span><span >并改善了全面性能。</span><span>B+tree</span><span >将在第</span><span>9</span><span >章介绍。</span></p>
  <p><span >四、</span><span>SQLite
    3</span><span >最重要的改变是它的存储模型。由第二版只支持文本模型，扩展到支持</span><span>5</span><span >种本地数据类型，如第</span><span>4</span><span >章所介绍的，还增强了弱类型和类型亲和性的概念。每种类型都被优化，以得到更高的查询性能并战用更少的存储空间。例如，整数和浮点数以二进制的形式存储，而不再是以</span><span>ASCII</span><span >形式存储，这样，就不必再对</span><span>WHERE</span><span >子句中的值进行转换</span><span>(</span><span >像第</span><span>2</span><span
>版那样</span><span>)</span><span
>。弱类型使你能够在定义一个字段时选择是否预声明类型。亲和性确定一个值存储于字段的格式――基于值的表示法和列的亲和性。类型亲和性与弱类型紧密关联――列的亲和性由其类型的声明确定。</span></p>
  <p><span >在很多方面，</span><span>SQLite
    3</span><span >是一个与</span><span>SQLite 2</span><span
>完全不同的数据库，并且提供了很多在适应性、特色和性能方面的改进。</span></p>
  <h3><a name="_Toc245565826"><span >主要的数据结构</span></a></h3>
  <p><span >在第</span><span>1</span><span
>章你看到了很多</span><span>SQLite</span><span
>组件――分词器、分析器和虚拟机等等。但是从程序员的角度，最需要知道的是：</span><span>connection</span><span >、</span><span>statements</span><span >、</span><span>B-tree</span><span >和</span><span>pager</span><span
>。它们之间的关系如图</span><span>5-1</span><span
>所示。这些对象构成了编写优秀代码所必须知道的</span><span>3</span><span
>个首要内容：</span><span>API</span><span
>、事务和锁。</span></p>
  <p><span><img width=511 height=384
src="Definitive Guide/image007.jpg"></span></p>
  <p><span >图</span><span>5-1 SQLite
    C API</span><span >对象模型</span></p>
  <p><span >从技术上来说，</span><span>B-tree</span><span
>和</span><span>pager</span><span
>不是</span><span>API</span><span
>的一部分，但是它们却在事务和锁上起着关键作用。这里只介绍关联的内容，详细内容将在“事务”一节介绍。</span></p>
  <h4><span style='font-family:黑体'>连接</span><span>(Connection)</span><span
style='font-family:黑体'>和语句</span><span>(Statement)</span></h4>
  <p><span >连接</span><span>(Connection)</span><span
>和语句</span><span>(Statement)</span><span
>是执行</span><span>SQL</span><span
>命令涉及的两个主要数据结构，几乎所有通过</span><span>API</span><span
>进行的操作都要用到它们。连接代表在一个独立的事务环境下的一个单独的数据库连接。每个语句都和一个连接关联，通常表示一个编译过的</span><span>SQL</span><span >语句。在内部，它以</span><span>VDBE</span><span >字节码表示。语句包括执行一个命令所需要一切，包括保存</span><span>VDBE</span><span >程序执行状态所需的资源，指向硬盘记录的</span><span>B-tree</span><span >游标，以及参数等等。</span></p>
  <h4><span>B-tree</span><span style='font-family:黑体'>和</span><span>Pager</span></h4>
  <p><span >一个连接可以有多个</span><span>database</span><span >对象――一个主数据库和附加的数据库。每一个数据库对象有一个</span><span>B-tree</span><span >对象，一个</span><span>B-tree</span><span >有一个</span><span>pager</span><span >对象</span><span>(</span><span
>这里的对象不是面向对象的“对象”，只是为了说清楚问题</span><span>)</span><span
>。</span></p>
  <p><span >语句最终都是通过连接的</span><span>B-tree</span><span >和</span><span>pager</span><span
>从数据库读或者写数据，通过</span><span>B-tree</span><span
>的游标</span><span>(cursor)</span><span
>遍历存储在页</span><span>(page)</span><span
>中的记录。在游标访问页之前，页必须从磁盘加载到内存，而这就是</span><span>pager</span><span
>的任务。任何时候，如果</span><span>B-tree</span><span
>需要页，它都会请求</span><span>pager</span><span
>从磁盘读取数据，</span><span>pager</span><span
>把页加载到页缓冲区</span><span>(page cache)</span><span
>。之后，</span><span>B-tree</span><span
>和与之关联的游标就可以访问位于页中的记录了。</span></p>
  <p><span >如果游标改变了页，为了防止事务回滚，</span><span>pager</span><span >必须采取特殊的方式保存原来的页。总的来说，</span><span>pager</span><span >负责读写数据库，管理内存缓存和页，以及管理事务、锁和崩溃恢复</span><span>(</span><span >这些在“事务”一节会详细介绍</span><span>)</span><span >。</span></p>
  <p><span >总之，关于连接和事务，你必须知道两件事：</span><span>(1)</span><span >对数据库的任何操作，一个连接存在于一个事务之下。</span><span>(2)</span><span >一个连接绝不会同时存在于多个事务之下。无论何时，一个连接在对数据库做任何操作时，都总是在恰好一个事务之下，不会多，也不会少。</span></p>
  <h3><a name="_Toc245565827"><span >核心</span><span>API</span></a></h3>
  <p><span >核心</span><span>API</span><span
>主要与执行</span><span>SQL</span><span
>命令有关。有两种方法执行</span><span>SQL</span><span
>语句：预编译查询和封装查询。预编译查询由三个阶段构成：准备</span><span>(preparation)</span><span
>、执行</span><span>(execution)</span><span
>和定案</span><span>(finalization)</span><span
>。其实封闭装查询只是对预编译查询的三个过程进行了包装而已，最终也会转化为预编译查询来执行。</span></p>
  <h4><span style='font-family:黑体'>连接的生命周期</span><span>(The Connection
    Lifecycle)</span></h4>
  <p><span >和大多数据库连接相同，其生命周期由三个阶段构成：</span></p>
  <p><span>1. </span><span >连接数据库</span><span>(Connect to the database)</span><span >。</span><span> </span></p>
  <p><span>2. </span><span >处理事务</span><span>(Perform transactions)</span><span >：如你所知，任何命令都在事务下执行。默认情况下，事务自动提交，也就是每一个</span><span>SQL</span><span >语句都在一个独立的事务下运行。当然也可以通过使用</span><span>BEGIN..COMMIT</span><span >手动提交事务。</span><span> </span></p>
  <p><span>3. </span><span >断开连接</span><span>(Disconnect from the database)</span><span >：关闭数据库文件。还要关闭所有附加的数据库文件。</span></p>
  <p><span >在查询的处理过程中还包括其它一些行为，如处理错误、“忙”句柄和</span><span>schema</span><span >改变等，所有这些都将在</span><span>utility functions</span><span >一节中介绍。</span></p>
  <p><span >连接数据库</span><span>(Connect
    to the database)</span><span >：</span></p>
  <p><span >连接数据库不只是打开一个文件。每个</span><span>SQLite</span><span >数据库都存储在单独的操作系统文件中――数据库与文件一一对应。连接、打开数据库的</span><span>C API</span><span >为</span><span>sqlite3_open()</span><span
>，它只是一个简单的系统调用，来打开一个文件，它的实现位于</span><span>main.c</span><span
>文件中。</span></p>
  <p><span>SQLite</span><span >还可以创建内存数据库。如果你使用</span><span>:memory:</span><span >或一个空字符串做数据库名，数据库将在</span><span>RAM</span><span >中创建。内存数据库将只能被创建它的连接所存取，不能与其它连接共享。另外，内存数据库只能存活于连接期间，一旦连接关闭，数据库就将从内存中被删除。</span></p>
  <p><span >当连接一个位于磁盘上的数据库时，如果数据库文件存在，则打开该文件；如果不存在，</span><span>SQLite</span><span >会假定你想创建一个新的数据库。在这种情况下，</span><span>SQLite</span><span >不会立即在磁盘上创建一个文件，只有当你向数据库写入数据时才会创建文件，比如：创建表、视图或者其它数据库对象。如果你打开一个数据库，不做任何事，然后关闭它，</span><span>SQLite</span><span >会创建一个文件，但只是一个长度为</span><span>0</span><span >的空文件而已。</span></p>
  <p><span >另外一个不立即创建新文件的原因是，一些数据库的参数，比如：编码，页大小等，只能在数据库创建之前设置。默认情况下，页大小为</span><span>1024</span><span >字节，但是你可以选择</span><span>512-32768</span><span >字节之间为</span><span> 2</span><span >幂数的数字。有些时候，较大的页能更有效地处理大量的数据。你可以使用</span><span>page_size pragma</span><span >来设置数据库页大小。</span></p>
  <p><span >字符编码是数据库的另一个永久设置。你可以使用</span><span>encoding pragma</span><span >来设置字符编码，其值可以是</span><span>UTF-8</span><span >、</span><span>UTF-16</span><span
>、</span><span>UTF-16le (little endian)</span><span
>和</span><span>UTF-16be (big endian)</span><span
>。</span></p>
  <h4><span style='font-family:黑体'>执行预处理查询</span></h4>
  <p><span >前面提到，预处理查询</span><span>(Prepared Query)</span><span >是</span><span>SQLite</span><span >执行所有</span><span>SQL</span><span >命令的方式，包括以下三个步聚：</span></p>
  <p><span>(1) </span><span >准备</span><span>(preparation)</span><span >：</span></p>
  <p><span >分词器</span><span>(tokenizer) </span><span >、分析器</span><span>(parser)</span><span
>和代码生成器</span><span>(code generator)</span><span
>把</span><span>SQL</span><span
>语句编译成</span><span>VDBE</span><span
>字节码，编译器会创建一个语句句柄</span><span>(sqlite3_stmt)</span><span
>，它包括字节码以及其它执行命令和遍历结果集所需的全部资源。相应的</span><span>C
    API</span><span >为</span><span>sqlite3_prepare()</span><span
>，位于</span><span>prepare.c</span><span
>文件中。</span></p>
  <p><span>(2) </span><span >执行</span><span>(execution)</span><span >：</span></p>
  <p><span >虚拟机执行字节码，执行过程是一个步进</span><span>(stepwise)</span><span >的过程，每一步</span><span>(step)</span><span >由</span><span>sqlite3_step()</span><span
>启动，并由</span><span>VDBE</span><span
>执行一段字节码。当第一次调用</span><span>sqlite3_step()</span><span
>时，一般会获得一种锁，锁的种类由命令要做什么</span><span>(</span><span
>读或写</span><span>)</span><span
>决定。对于</span><span>SELECT</span><span
>语句，每次调用</span><span>sqlite3_step()</span><span
>使用语句句柄的游标移到结果集的下一行。对于结果集中的每一行，它返回</span><span>SQLITE_ROW</span><span >，当到达结果末尾时，返回</span><span>SQLITE_DONE</span><span >。对于其它</span><span>SQL</span><span >语句</span><span>(INSERT</span><span
>、</span><span>UPDATE</span><span
>、</span><span>DELETE</span><span
>等</span><span>)</span><span style='font-family:
宋体'>，第一次调用</span><span>sqlite3_step()</span><span style='font-family:
宋体'>就导致</span><span>VDBE</span><span >执行整个命令。</span></p>
  <p><span>(3) </span><span >定案</span><span>(finalization)</span><span >：</span></p>
  <p><span>VDBE</span><span >关闭语句，释放资源。相应的</span><span>C API</span><span >为</span><span>sqlite3_finalize()</span><span
>，它导致</span><span>VDBE</span><span
>结束程序运行并关闭语句句柄。如果事务是由人工控制开始的，它必须由人工控制进行提交或回卷，否则</span><span>sqlite3_finalize()</span><span >会返回一个错误。当</span><span>sqlite3_finalize()</span><span >执行成功，所有与语句对象关联的资源都将被释放。在自动提交模式下，还会释放关联的数据库锁。</span></p>
  <p><span >每一步</span><span>(preparation</span><span
>、</span><span>execution</span><span
>和</span><span>finalization)</span><span
>都关联于语句句柄的一种状态</span><span>(prepared</span><span
>、</span><span>active</span><span
>和</span><span>finalized)</span><span
>。</span><span>Pepared</span><span
>表示所有资源都已分配，语句已经可以执行，但还没有执行。现在还没有申请锁，一直到调用</span><span
>sqlite3_step()</span><span >时才会申请锁。</span><span
>Active</span><span >状态开始于对</span><span
>sqlite3_step()</span><span >的调用，此时语句正在被执行并拥有某种锁。</span><span
>Finalized</span><span >意味着语句已经被关闭且所有相关资源已经被释放。通过图</span><span
>5-2</span><span >可以更容易地理解该过程：</span></p>
  <p><span><img width=460 height=526
src="Definitive Guide/image008.jpg"></span></p>
  <p><span >图</span><span>5-2 </span><span
>语句处理</span></p>
  <p><span >下面代码例示了在</span><span
>SQLite</span><span >上执行一个</span><span
>query</span><span >的一般过程。</span></p>
  <p><span>#include&lt;stdio.h&gt;</span></p>
  <p><span>#include&lt;stdlib.h&gt;</span></p>
  <p><span>#include&quot;sqlite3.h&quot;</span></p>
  <p><span>#include&lt;string.h&gt;</span></p>
  <p><span>#pragma comment(lib,
    &quot;sqlite3.lib&quot;)</span></p>
  <p><span>int main(int argc,char **argv)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
    rc,i,ncols;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqlite3
    *db;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqlite3_stmt
    *stmt;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char
    *sql;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
    char*tail;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span
>打开数据</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc=sqlite3_open(&quot;foods.db&quot;,&amp;db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(rc){</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,&quot;Can'topendatabase:%sn&quot;,sqlite3_errmsg(db));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql=&quot;select
    * from episodes&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span
>预处理</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc=sqlite3_prepare(db,sql,(int)strlen(sql),&amp;stmt,&amp;tail);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(rc!=SQLITE_OK){</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,&quot;SQLerror:%sn&quot;,sqlite3_errmsg(db));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc=sqlite3_step(stmt);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ncols=sqlite3_column_count(stmt);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(rc==SQLITE_ROW){</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;ncols;i++){</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,&quot;'%s'&quot;,sqlite3_column_text(stmt,i));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,&quot;\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc=sqlite3_step(stmt);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span
>释放</span><span>statement</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqlite3_finalize(stmt);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span
>关闭数据库</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(0);</span></p>
  <p><span>}</span></p>
  <p><span >空注：</span></p>
  <p><span >上述代码在</span><span>VC6++</span><span
>下调试通过，其步骤为：</span></p>
  <p><span >将上述代码做成一个</span><span
>.cpp</span><span >文件并为它创建工作空间。</span></p>
  <p><span >将</span><span>sqlite3.def</span><span
>和</span><span>sqlite3.dll</span><span
>文件复制到工作空间所在目录。</span><span>(</span><span
>这两个文件可由</span><span>sqlitedll-3_6_18.zip</span><span
>文件解压而得</span><span>)</span></p>
  <p><span >进入</span><span>DOS</span><span
>命令行状态，进入工作空间所在目录，执行如下</span><span>3</span><span
>条命令：</span></p>
  <p><span>PATH = D:\Program Files\Microsoft Visual
    Studio 9.0\VC\bin;%PATH%</span></p>
  <p><span>PATH = D:\Program Files\Microsoft Visual
    Studio 9.0\Common7\IDE;%PATH%</span></p>
  <p><span>LIB /DEF:sqlite3.def /machine:IX86</span></p>
  <p><span >注：上述命令用于制作</span><span
>.lib</span><span >文件，用于项目的链接。如果</span><span
>PATH</span><span >已经设好，前两条命令可能不需要执行；如果执行，可能需要根据</span><span
>VC</span><span >的安装情况有所改动。</span></p>
  <p><span >临时存储器：</span></p>
  <p><span >临时存储器是查询处理的重要组成部分。</span><span
>SQLite</span><span >有时需要存储命令执行过程中产生的中间结果――如结果集由</span><span
>ORDER BY</span><span >子句指定需要排序，或进行多表交叉查询时。中间结果存储在临时存储器中。临时存储器或者在内存，或者在文件中。</span><span
> </span></p>
  <h4><span style='font-family:黑体'>使用参数化的</span><span>SQL</span></h4>
  <p><span>SQL</span><span >语句可以包含参数。参数是</span><span
>SQL</span><span >命令中的占位符，它们的值会在编译之后提供</span><span
>(</span><span >称为“绑定”</span><span>)</span><span
>。下面是带参数的</span><span>SQL</span><span
>示例语句：</span></p>
  <p><span>INSERT INTO foods (id, name) VALUES (?,?);</span></p>
  <p><span>INSERT INTO episodes (id, name) (:id,
    :name);</span></p>
  <p><span >上述语句表现了参数的两种绑定方式：按位置和按名称。第</span><span
>1</span><span >条命令采用了位置参数，第</span><span
>2</span><span >条命令采用了名称参数。</span></p>
  <p><span>Positional parameters are defined by the
    position of the question mark in the statement. The first question mark has
    position 1, the second 2, and so on. Named parameters use actual variable
    names, which are prefixed with a colon. When <span style='color:#CC0000'>sqlite3_prepare()</span> compiles a statement with parameters, it allocates placeholders for the
    parameters in the resulting statement handle. It then expects values to be
    provided for these parameters before the statement is </span></p>
  <p><span>executed. </span><span style='font-family:
宋体'>如果你没有为参数绑定值，在语句执行时，</span><span>SQLite </span><span
>默认为各参数赋</span><span>NULL</span><span
>值。</span></p>
  <p><span >使用参数绑定的好处是你可以多次执行相同的语句而不必重新编译它们。</span><span
>You just reset the statement, bind a new set of values, and
    reexecute. This is where resetting rather than finalizing a statement comes in
    handy: it avoids the overhead of SQL compilation. By resetting a statement, you
    are reusing the compiled SQL code. You completely avoid the tokenizing,
    parsing, and code generation overhead. Resetting a statement is implemented in
    the API by the <span style='color:#CC0000'>sqlite3_reset() </span>function. </span></p>
  <p><span >使用参数的另一个好处是：</span><span
>SQLite</span><span >可以对你绑定到参数的字符串值做一定的处理。例如，有一个参数值</span><span
>'Kenny's Chicken'</span><span >，参数绑定过程会自动地将其转化为</span><span
>'Kenny''s Chicken'</span><span >。下面的伪代码说明了绑定参数的基本方法：</span></p>
  <p><span>db = open('foods.db')</span></p>
  <p><span>stmt = db.prepare('INSERT INTO episodes
    (id, name) VALUES (:id, :name)')</span></p>
  <p><span>stmt.bind('id', '1')</span></p>
  <p><span>stmt.bind('name', 'Soup Nazi')</span></p>
  <p><span>stmt.step()</span></p>
  <p><span># Reset and use again</span></p>
  <p><span>stmt.reset()</span></p>
  <p><span>stmt.bind('id', '2')</span></p>
  <p><span>stmt.bind('name', 'The Junior Mint')</span></p>
  <p><span># Done</span></p>
  <p><span>stmt.finalize()</span></p>
  <p><span>db.close()</span></p>
  <h4><span style='font-family:黑体'>执行封装的</span><span>Query</span></h4>
  <p><span >如前文所述，有两个很有用的函数可以封装查询的预编译过程，允许你在单一的函数调用中执行</span><span
>SQL</span><span >命令。一个函数是</span><span
 style='color:#CC0000'>sqlite3_exec()</span><span style='font-family:
宋体'>，特别适合执行不需要返回数据的查询。另一个是</span><span  style='color:#CC0000'>sqlite3_get_table()</span><span
>，返回一个表格化的结果集。</span><span>In many language
    extensions you will see analogs to both functions. Most extensions refer to the
    first method simply as exec(), and the second as just get_table(). </span></p>
  <p><span>sqlite3_get_table()</span><span
>的函数名起得不太合适，听起来好象是要返回一个表的全部数据。其实它的命名只是表示将会返回一个表格化的结果集。</span><span
> </span></p>
  <p><span>db = open('foods.db')</span></p>
  <p><span>table = db.get_table(&quot;SELECT * FROM
    episodes LIMIT 10&quot;)</span></p>
  <p><span>for i=0; i &lt; table.rows; i++</span></p>
  <p><span>&nbsp;&nbsp;for j=0; j &lt; table.cols; j++ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;print table[i][j] </span></p>
  <p><span>&nbsp;&nbsp;end </span></p>
  <p><span>end </span></p>
  <p><span>db.close() </span></p>
  <h4><span style='font-family:黑体'>错误处理</span></h4>
  <p><span >前面的例子都是极度简化了的，只关注查询的执行。而在实际情况下，你总得关注出错的可能性。你前面所看到的几乎每个函数在某些情况下都可能引发错误。通常你需要对错误代码</span><span
>SQLITE_ERROR</span><span >、</span><span
>SQLITE_BUSY</span><span >和</span><span
>SQLITE_SCHEMA</span><span >进行处理。</span><span
>SQLITE_BUSY</span><span >在当前连接不能够获得一个锁时触发，</span><span
>SQLITE_SCHEMA</span><span >在语句的编译与执行之间</span><span
>schema</span><span >发生了改变时触发。“忙”状态将在本章的事务一节中介绍。</span><span
>Schema</span><span >错误将在第</span><span
>6</span><span >章介绍。</span></p>
  <p><span >很多语言扩展难于处理</span><span
>schema</span><span >错误。有些透明地报告处于忙状态，有些直接返回实际的错误代码。无论如何，如果你遇到了</span><span
>schema</span><span >错误，表示有其它的连接在你的读与写之间改变了数据库，你的语句已不再合法。你需要重新编译语句，以便能够重新执行它。</span><span
>Schema</span><span >错误只会发生在对</span><span
>prepare()</span><span >的调用和第</span><span
>1</span><span >次对</span><span>step()</span><span
>的调用之间。如果你的第</span><span>1</span><span
>次</span><span>step()</span><span
>调用成功，那你就不必再担心在后面调用</span><span>step()</span><span
>时会引发</span><span>schema</span><span
>错误了，因为你的连接已经锁住了数据库，其它的连接不可能在此期间修改数据库。</span></p>
  <p><span >对于一般性错误，</span><span
>API</span><span >提供了</span><span 
style='color:#CC0000'>sqlite3_errcode()</span><span >来获取最后一次调用</span><span
>API</span><span >函数时的返回码。你可以使用</span><span
 style='color:#CC0000'>sqlite3_errmsg()</span><span style='font-family:
宋体'>函数得到更具体的错误信息，该函数提供了对最后错误的文字描述，大多数语言扩展都支持这个函数。</span></p>
  <p><span >有了这个观念，前面例子中的每个调用都可以用类似下面的代码来检查错误：</span></p>
  <p><span># Check and report errors </span></p>
  <p><span>if db.errcode() != SQLITE_OK</span></p>
  <p><span>&nbsp;&nbsp;print db.errmsg(stmt) </span></p>
  <p><span>end</span></p>
  <p><span >一般情况下，错误处理并不困难。处理错误的方法由你确切地想要做什么决定。</span><span
> </span></p>
  <h4><span style='font-family:黑体'>格式化</span><span>SQL</span><span
style='font-family:黑体'>语句</span></h4>
  <p><span >另一个方便的函数是</span><span
 style='color:#CC0000'>sqlite3_mprintf()</span><span
>，它是标准</span><span>C</span><span
>库函数</span><span>sprintf()</span><span
>的一个变体。它有很独特的替换符，特别方便对</span><span>SQL</span><span
>进行处理。它的替换符是</span><span>%q</span><span
>和</span><span>%Q</span><span
>。</span><span>%q</span><span
>的工作原理像</span><span>%s</span><span
>，从参数列表中取得一个以</span><span>NULL</span><span
>结束的字符串。它会将单引号反斜杠都双写，使你更容易防范</span><span>SQL</span><span
>注入式攻击</span><span>(</span><span
>参本节下文的“</span><span>SQL</span><span
>注入式攻击”一段</span><span>)</span><span
>。例如：</span></p>
  <p><span>char* before = &quot;Hey, at least %q no
    pig-man.&quot;; </span></p>
  <p><span>char* after = sqlite3_mprintf(before,
    &quot;\he's\&quot;); </span></p>
  <p><span >上述程序执行后</span><span>after</span><span
>的值为</span><span>'Hey, at least \\he''s\\ no
    pig-man'</span><span >。</span><span>The single
    quote in he’s is doubled along with the backslashes around it, making it
    acceptable as a string literal in a SQL statement. The %Q formatting does
    everything %qdoes, but it additionally encloses the resulting string in single
    quotes. Furthermore, if the argument for %Q is a NULL pointer (in C), it
    produces the string NULL without single quotes. For more information, see the
    sqlite3_mprintf() documentation in the C API reference in Appendix B. </span></p>
  <p><span>SQL</span><span >注入式攻击：</span></p>
  <p><span >如果你的应用程序依赖用户的输入来构造</span><span
>SQL</span><span >语句，那么它将很容易受到</span><span
>SQL</span><span >注入攻击。如果你没有精心地过滤用户输入，有人可能会输入别有用心的内容，注入到你的</span><span
>SQL</span><span >中，并在其后面构成一个新的</span><span
>SQL</span><span >语句。例如，你的程序用用户输入来填充下面</span><span
>SQL</span><span >语句：</span></p>
  <p><span>SELECT * FROM foods WHERE name='%s'; </span></p>
  <p><span >如果无论用户输入什么都直接来替换</span><span
>%s</span><span >，如果用户对你的数据库有一定了解，他可以输入如下内容：</span></p>
  <p><span>nothing' LIMIT 0; SELECT name FROM sqlite_master
    WHERE name='% </span></p>
  <p><span >将用户输入替换进原有的</span><span
>SQL</span><span >语句之后，变成了两个新的语句：</span></p>
  <p><span>SELECT * FROM foods WHERE name='nothing'
    LIMIT 0; SELECT name FROM </span></p>
  <p><span>sqlite_master WHERE name='%'; </span></p>
  <p><span >第</span><span>1</span><span
>个语句什么都不返回，但第</span><span>2</span><span
>个将返回表中所有的记录。</span><span>Granted, the odds of
    this happening require quite a bit of knowledge on the attacker’s part, but it
    is nevertheless possible. Some major (commercial) web applications have been
    known to keep SQL statements embedded in their JavaScript, which can provide
    plenty of hints about the database being used. In the previous example, all a malicious
    user has to do now is insert DROP TABLE statements for every table found in
    sqlite_master and you could find yourself fumbling through backups. </span></p>
  <h3><a name="_Toc245565828"><span >操作控制</span></a></h3>
  <p><span>API</span><span >中包含几个命令来监视、控制，或者说限制数据库操作。</span><span
>SQLite</span><span >使用过滤</span><span
>(</span><span >或称回叫</span><span>)</span><span
>函数来完成此功能，你可以注册它们由特定的事件来调用。有</span><span>3</span><span
>个</span><span>“hook”</span><span
>函数：</span><span>sqlite3_commit_hook()</span><span
>，它监视事务的提交；</span><span>sqlite3_rollback_hook()</span><span
>，它监视事务的回卷；</span><span>sqlite3_update_hook()</span><span
>，它监视</span><span>INSERT</span><span
>、</span><span>UPDATE</span><span
>和</span><span>DELETE</span><span
>操作。这些函数在运行时被调用――即当命令执行时被调用。</span><span>Each
    hook allows you to register a callback function on a connection-by-connection
    basis, and lets you provide some kind of application-specific data to be passed
    to the callback as well. The general use of operational control functions is as
    follows: </span></p>
  <p><span>def commit_hook(cnx) </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log('Attempted
    commit on connection %x', cnx) </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
    -1</span></p>
  <p><span>end</span></p>
  <p><span>db = open('foods.db')</span></p>
  <p><span>db.set_commit_hook(rollback_hook, cnx)</span></p>
  <p><span>db.exec(&quot;BEGIN; DELETE from episodes;
    ROLLBACK&quot;)</span></p>
  <p><span>db.close()</span></p>
  <h4><span style='font-family:黑体'>使用线程</span></h4>
  <p><span>SQLite</span><span >有几个可以在多线程环境下使用的函数。在</span><span>3.3.1</span><span >版中，</span><span>SQLite</span><span
>引入了一种称为共享缓冲区模式的独特的操作模式，就是为多线程的内嵌式服务器设计的。这个模式提供了一种用单线程来处理多连接的方法，可以共享相同的页缓冲区，从而降低了整个服务器的内存需求。这个模式包括多个函数来管理内存和服务器。详见第</span><span
>6</span><span >章“共享缓冲区模式”一节。</span></p>
  <h3><a name="_Toc245565829"><span >扩充</span><span
>API</span></a></h3>
  <p><span>SQLite</span><span >的扩充</span><span
>API</span><span >用来支持用户定义的函数、聚合和排序法。用户定义函数是一个</span><span
>SQL</span><span >函数，它对应于你用</span><span
>C</span><span >语言或其它语言实现的函数的句柄。使用</span><span
>C API</span><span >时，这些句柄用</span><span
>C/C++</span><span >实现。</span></p>
  <p><span >用户定义的扩展必须注册到一个由连接到连接的基础</span><span
>(connection-by-connection basis)</span><span style='font-family:
宋体'>之上，存储在程序内存中。也就是说，它们不是存储在数据库中</span><span>(</span><span
>就像大型数据库的存储过程一样</span><span>)</span><span
>，而是存储在你的程序中。</span></p>
  <h4><span style='font-family:黑体'>创建用户自定义函数</span></h4>
  <p><span >实现一个用户自定义的函数分为两步。首先，写句柄。句柄实现一些你想通过</span><span
>SQL</span><span >完成的功能。然后，注册句柄，为它提供</span><span
>SQL</span><span >名称、参数的数量和一个指向句柄的指针。</span></p>
  <p><span >例如，你想创建一个叫做</span><span
>hello_newman()</span><span >的</span><span
>SQL</span><span >函数，它返回文本</span><span
>'Hello Jerry'</span><span >。在</span><span
>SQLite C API</span><span >中，先创建一个</span><span
>C</span><span >函数来实现此功能，如：</span></p>
  <p><span>void hello_newman(sqlite3_context* ctx, int
    nargs, sqlite3_value** values) </span></p>
  <p><span>{ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Create Newman's reply
    */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char *msg =
    &quot;Hello Jerry&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Set the return value.
    Have sqlite clean up msg w/ sqlite_free(). */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_result_text(ctx,
    msg, strlen(msg), sqlite3_free); </span></p>
  <p><span>} </span></p>
  <p><span >不了解</span><span>C</span><span
>和</span><span>C API</span><span
>也没关系。这个句柄仅返回</span><span>'Hello Jerry'</span><span
>。下面是实际使用它。使用</span><span>sqlite3_create_function()</span><span
>函数注册这个句柄：</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_create_function(db,
    &quot;hello_newman&quot;, 0, hello_newman); </span></p>
  <p><span >第</span><span>1</span><span
>个参数</span><span>(db)</span><span
>是数据库连接。第</span><span>2</span><span
>个参数是函数的名称，这个名称将出现在</span><span>SQL</span><span
>中。第</span><span>3</span><span
>个参数表示这个函数有</span><span>0</span><span
>个参数</span><span>(</span><span
>如果该参数值为</span><span>-1</span><span
>，表示该函数接受可变数量的参数</span><span>)</span><span
>。最后一个参数是</span><span>C</span><span
>函数</span><span>hello_newman()</span><span
>的指针，当</span><span>SQL</span><span
>函数被调用时，通过这个指针来调用实际的函数。</span></p>
  <p><span >一旦进行了注册，</span><span
>SQLite</span><span >就知道了当遇到</span><span
>SQL</span><span >函数调用</span><span>hello_newman()</span><span
>时，它需要调用</span><span>C</span><span
>函数</span><span>hello_newman()</span><span
>来得到结果。现在，你可以在程序中执行</span><span>SELECT
    hello_newman()</span><span >语句，它将返回单行单列的文本</span><span
>'Hello Jerry'</span><span >。</span></p>
  <p><span >如前所述，很多语言扩展允许用各自的语言来实现用户自定义的函数。例如，</span><span
>Java</span><span >、</span><span>Perl</span><span
>等。不同的语言扩展用不同的方法注册函数，有些使用其本身语言的函数来完成此项工作，例如，在</span><span
>Ruby</span><span >中使用</span><span>block―one</span><span
>。</span></p>
  <h4><span style='font-family:黑体'>创建用户自定义聚合</span></h4>
  <p><span >所谓聚合函数，就是那些在结果集中应用于全部记录，并从中计算一些聚合值的函数。</span><span
>SUM()</span><span >、</span><span>COUNT()</span><span
>和</span><span>AVG()</span><span
>都是</span><span>SQLite</span><span
>标准聚合函数的例子。</span></p>
  <p><span >创建用户自定义聚合需要三步：注册聚合、实现步进函数</span><span
>(</span><span >对结果集中的每条记录调用</span><span
>)</span><span >、实现定案函数</span><span>(</span><span
>在所有记录处理完后调用</span><span>)</span><span
>。在定案函数中计算最终的聚合值，并做一些必要的清理工作。</span></p>
  <h4><span style='font-family:黑体'>创建用户自定义排序法</span></h4>
  <h2><a name="_Toc245565830"><span style='font-family:黑体'>事务</span></a></h2>
  <p><span >现在，你应该已经对</span><span
>API</span><span >有了一个较好的了解。你知道了执行</span><span
>SQL</span><span >命令的不同方法和一些有用的功能函数。但是，只知道</span><span
>API</span><span >还不够，事务和锁与查询的处理过程是紧密关联的。查询永远只能在事务中完成，事务包含锁，而如果不清楚自己到底在做什么，锁则可能会导致问题。根据你是如何使用</span><span
>SQL</span><span >及如何编码，你可以控制锁的类型和持续时间。</span></p>
  <p><span >第</span><span>4</span><span
>章图示了一个特殊的假想：两个独立的连接同时执行时导致了死锁。作为程序员，你还可以从代码的角度来看待问题，代码中可能包括处于多种状态的多个连接，带有多个语句句柄，而你的代码可能在你不知情的情况下就持有了</span><span
>EXCLUSIVE</span><span >锁，从而使其它连接不能做任何事情。</span></p>
  <p><span >这就是为什么掌握下面知识很重要：事务和锁如何工作，它们如何与</span><span
>API</span><span >结合来处理查询。理想的目标是，你应该能够看着你写的代码并说出事务处于什么状态，或者至少能够发现潜在的问题。本节将介绍事务和锁背后的运行机制，下一节将介绍如何实际地编码。</span></p>
  <h3><a name="_Toc245565831"><span >事务的生命周期</span></a></h3>
  <p><span >有一些关于代码和事务的问题需要关注。首先需要知道哪个对象运行在哪个事务之下。另一个问题是持续时间――一个事务何时开始，何时结束，从哪一点开始影响其它连接？第一个问题与</span><span
>API</span><span >直接关联，第二个与</span><span
>SQL</span><span >的一般概念及</span><span
>SQLite</span><span >的特殊实现关联。</span></p>
  <p><span >一个连接</span><span>(connection)</span><span
>可以包含多个语句</span><span>(statement)</span><span
>，而且每个连接有一个与数据库关联的</span><span>B-tree</span><span
>和一个</span><span>pager</span><span
>。</span><span>Pager</span><span
>在连接中起着很重要的作用，因为它管理事务、锁、内存缓冲以及负责崩溃恢复</span><span
>(crash recovery)</span><span >。当你进行数据库写操作时，记住最重要的一件事：在任何时候，只在一个事务下执行一个连接。这回答了第一个问题。</span></p>
  <p><span >关于第二个问题，一般来说，一个事务的生命周期和语句差不多，你也可以手动结束它。默认情况下，事务自动提交，当然你也可以通过</span><span
>BEGIN..COMMIT</span><span >手动提交。接下来的问题是事务如何与锁关联。</span></p>
  <h3><a name="_Toc245565832"><span >锁的状态</span></a></h3>
  <p><span >大多数情况下，锁的生命周期在事务的生命周期之中。它们不一定同时开始，但总时同时结束。当你结束一个事务时，也会释放它相关的锁。或者说，锁直到事务结束或系统崩溃时才会释放。如果系统在事务没有结束的情况下崩溃，那么下一个访问数据库的连接会处理这种情况，详见“锁与崩溃恢复”一节。</span></p>
  <p><span >在</span><span>SQLite</span><span
>中有</span><span>5</span><span
>种不同的锁状态，连接</span><span>(connection)</span><span
>任何时候都处于其中的一个状态。图</span><span>5-3</span><span
>显示了锁的状态以及状态的转换。</span></p>
  <p><span><img width=513 height=577
src="Definitive Guide/image009.jpg"></span></p>
  <p><span >图</span><span>5-3 SQLite</span><span
>锁转换</span></p>
  <p><span >关于这个图有以下几点值得注意：</span></p>
  <p><span>(1)</span><span >一个事务可以在</span><span
>UNLOCKED</span><span >、</span><span
>RESERVED</span><span >或</span><span
>EXCLUSIVE</span><span >三种状态下开始。默认情况下在</span><span
>UNLOCKED</span><span >时开始。</span></p>
  <p><span>(2)</span><span >白色框中的</span><span
>UNLOCKED</span><span >、</span><span
>PENDING</span><span >、</span><span>SHARED</span><span
>和</span><span> RESERVED</span><span
>可以在一个数据库的同一时刻存在。</span></p>
  <p><span>(3)</span><span >从灰色的</span><span
>PENDING</span><span >开始，事情就变得严格起来，意味着事务想得到排它锁</span><span
>(EXCLUSIVE)(</span><span >注意与白色框中的区别</span><span
>)</span><span >。</span></p>
  <p><span >虽然锁有这么多状态，但是从体质上来说，只有两种情况：读事务和写事务。</span></p>
  <h3><a name="_Toc245565833"><span >读事务</span></a></h3>
  <p><span >我们先来看看</span><span>SELECT</span><span
>语句执行时锁的状态变化过程，非常简单：一个连接执行</span><span>SELECT</span><span
>语句，触发一个事务，从</span><span>UNLOCKED</span><span
>到</span><span>SHARED</span><span
>，当事务</span><span>COMMIT</span><span
>时，又回到</span><span>UNLOCKED</span><span
>，就这么简单。</span></p>
  <p><span >那么，当你运行两个语句时会发生什么呢？这时如何加锁呢？这依赖于你是否运行在自动提交状态。考虑下面的例子</span><span
>(</span><span >为了简单，这里用了伪码</span><span
>)</span><span >：</span></p>
  <p><span>db = open('foods.db')</span></p>
  <p><span>db.exec('BEGIN')</span></p>
  <p><span>db.exec('SELECT * FROM episodes')</span></p>
  <p><span>db.exec('SELECT * FROM episodes')</span></p>
  <p><span>db.exec('COMMIT')</span></p>
  <p><span>db.close()</span></p>
  <p><span >由于显式地使用了</span><span
>BEGIN</span><span >和</span><span>COMMIT</span><span
>，两个</span><span>SELECT</span><span
>命令在一个事务下执行。第一个</span><span>exec()</span><span
>执行时，连接处于</span><span>SHARED</span><span
>，然后第二个</span><span>exec()</span><span
>执行。当事务提交时，连接又从</span><span>SHARED</span><span
>回到</span><span>UNLOCKED</span><span
>状态，状态变化如下：</span></p>
  <p><span>UNLOCKED</span><span style='font-family:
宋体'>→</span><span>PENDING</span><span >→</span><span
>SHARED</span><span >→</span><span>UNLOCKED</span></p>
  <p><span >如果没有</span><span>BEGIN</span><span
>和</span><span>COMMIT</span><span
>两行，两个</span><span>SELECT</span><span
>都运行于自动提交状态，状态变化如下：</span></p>
  <p><span>UNLOCKED</span><span style='font-family:
宋体'>→</span><span>PENDING</span><span >→</span><span
>SHARED</span><span >→</span><span>UNLOCKED</span><span
>→</span><span>PENDING</span><span
>→</span><span>SHARED</span><span
>→</span><span>UNLOCKED</span></p>
  <p><span >仅仅是读数据，但在自动提交模式下，却会经历两个加解锁的循环，太麻烦。而且，一个写进程可能插到两个</span><span
>SELECT</span><span >中间对数据库进行修改，这样，你就不能保证第二次能够读到同样的数据了，而使用</span><span
>BEGIN..COMMIT</span><span >就可以有此保证。</span></p>
  <h3><a name="_Toc245565834"><span >写事务</span></a></h3>
  <p><span >下面我们来考虑写数据库，比如</span><span
>UPDATE</span><span >。和读事务一样，它也会经历</span><span
>UNLOCKED</span><span >→</span><span
>PENDING</span><span >→</span><span>SHARED</span><span
>的变化过程，但接下来就会看到</span><span>PENDING</span><span
>锁是如何起到关口作用的了。</span></p>
  <h4><span style='font-family:黑体'>保留</span><span>(RESERVED)</span><span
style='font-family:黑体'>状态</span></h4>
  <p><span >当一个连接</span><span>(connection)</span><span
>要向数据库写数据时，从</span><span>SHARED</span><span
>状态变为</span><span>RESERVED</span><span
>状态。如果它得到</span><span>RESERVED</span><span
>锁，也就意味着它已经准备好进行写操作了。即使它没有把修改写入数据库，也可以把修改保存到位于</span><span
>pager</span><span >的缓冲区中</span><span
>(page cache)</span><span >了。</span></p>
  <p><span >当一个连接进入</span><span>RESERVED</span><span
>状态，</span><span>pager</span><span
>就开始初始化回卷日志</span><span>(rollback journal)</span><span
>。回卷日志是一个文件，用于回卷和崩溃恢复，见图</span><span>5-1</span><span
>。在</span><span>RESERVED</span><span
>状态下，</span><span>pager</span><span
>管理着三种页：</span></p>
  <p><span>(1)</span><span >已修改的页：包含被</span><span
>B-tree</span><span >修改的记录，位于</span><span
>page cache</span><span >中。</span></p>
  <p><span>(2)</span><span >未修改的页：包含没有被</span><span
>B-tree</span><span >修改的记录。</span></p>
  <p><span>(3)</span><span >日志页：这是修改页以前的版本，日志页并不存储在</span><span
>page cache</span><span >中，而是在</span><span
>B-tree</span><span >修改页之前写入日志。</span></p>
  <p><span>Page cache</span><span style='font-family:
宋体'>非常重要，正是因为它的存在，一个处于</span><span>RESERVED</span><span
>状态的连接可以真正的开始工作，而不会干扰其它的</span><span>(</span><span
>读</span><span>)</span><span style='font-family:
宋体'>连接。所以，</span><span>SQLite</span><span >可以高效地处理在同一时刻的多个读连接和一个写连接。</span></p>
  <h4><span style='font-family:黑体'>未决</span><span>(PENDING)</span><span
style='font-family:黑体'>状态</span></h4>
  <p><span >当一个连接完成修改，需要真正开始提交事务时，执行该过程的</span><span
>pager</span><span >进入</span><span>EXCLUSIVE</span><span
>状态。从</span><span>RESERVED</span><span
>状态开始，</span><span>pager</span><span
>试着获取</span><span>PENDING</span><span
>锁，一旦得到，就独占它，不允许任何其它连接获得</span><span>PENDING</span><span
>锁。既然写操作持有</span><span>PENDING</span><span
>锁，其它任何连接都不能从</span><span>UNLOCKED</span><span
>状态进入</span><span>SHARED</span><span
>状态，即不会再有新的读进程，也不会再有新的写进程。只有那些已经处于</span><span
>SHARED</span><span >状态的连接可以继续工作。而处于</span><span
>PENDING</span><span >状态的写进程会一直等到所有这些连接释放它们的锁，然后对数据库加</span><span
>EXCUSIVE</span><span >锁，进入</span><span
>EXCLUSIVE</span><span >状态，独占数据库。</span></p>
  <h4><span style='font-family:黑体'>排它状态</span></h4>
  <p><span >在</span><span>EXCLUSIVE</span><span
>状态下，主要的工作是把修改的页从</span><span>page cache</span><span
>写入数据库文件，这是真正进行写操作的地方。</span></p>
  <p><span >在</span><span>pager</span><span
>将修改页写到文件之前，还必须先处理日志。它检查是否所有的日志都写入了磁盘，因为它们可能还位于操作系统的缓冲区中。所以</span><span
>pager</span><span >得告诉</span><span>OS</span><span
>把所有的文件写入磁盘，这与</span><span>synchronous pragma</span><span
>所做的工作相同，如第</span><span>4</span><span
>章所述。</span></p>
  <p><span >日志是数据库进行恢复的惟一方法，所以日志对于</span><span
>DBMS</span><span >非常重要。如果日志页没有完全写入磁盘而发生崩溃，数据库就不能恢复到它原来的状态，此时数据库就处于不一致状态。日志写盘完成后，</span><span
>pager</span><span >就把所有的修改页写入数据库文件。接下来做什么取决于事务提交的模式，如果是自动提交，那么</span><span
>pager</span><span >清理日志、</span><span
>page cache</span><span >，然后由</span><span
>EXCLUSIVE</span><span >进入</span><span
>UNLOCKED</span><span >。如果是手动提交，那么</span><span
>pager</span><span >继续持有</span><span
>EXCLUSIVE</span><span >锁和回卷日志，直至遇到</span><span
>COMMIT</span><span >或者</span><span>ROLLBACK</span><span
>。</span></p>
  <p><span >总之，出于性能方面的考虑，进程占有排它锁的时间应该尽可能的短，所以</span><span
>DBMS</span><span >通常都是在真正写文件时才会占有排它锁，这样能大大提高并发性能。</span></p>
  <h4><span style='font-family:黑体'>自动提交与效率</span></h4>
  <h3><a name="_Toc245565835"><span >调整页缓冲区</span></a></h3>
  <p><span >回到前面的例子，事务从</span><span
>BEGIN</span><span >开始，跟着</span><span
>UPDATE</span><span >。如果在写盘之前，修改操作将缓冲区用完了</span><span
>(</span><span >也就是说修改操作需要比预设的更多的缓冲区</span><span
>)</span><span >，这时会发生什么呢？</span></p>
  <h4><span style='font-family:黑体'>转换为排它</span></h4>
  <p><span >真正的问题是：到底在哪个</span><span
>(</span><span >精确的</span><span>)</span><span
>时刻，到底为什么，</span><span>pager </span><span
>从</span><span>RESERVED</span><span
>转换为</span><span>EXCLUSIVE</span><span
>。这会发生在两种情况下：当连接到达提交点主动进入排它状态；或页缓冲区已满不得不进入排它状态。</span></p>
  <p><span >前面我们仅看到了第</span><span
>1</span><span >种情况，那么，在第</span><span
>2</span><span >种情况下会发生什么呢？此时</span><span
>pager</span><span >已不能再存储更多的已修改页，也就不能再做任何修改操作。它必须转换为排它状态，以使工作能够继续进行。实际上也不完全是这样，实际上有软限制和硬限制的区别。</span></p>
  <h4><span style='font-family:黑体'>调整页缓冲区的大小</span></h4>
  <p><span >如何决定需要多大的缓冲区尺寸呢？这由你想做什么而定。假设你想修改</span><span
>episodes</span><span >表的所有记录，那么该表的所有页都会被修改，因此，你就可以计算出</span><span
>episodes</span><span >表总共需要多少个页并对缓冲区做出调整。可以用</span><span
>sqlite_analyzer</span><span >到得所有关于</span><span
>episodes</span><span >表的需要的信息。对每一个表，它都可以做出完备的统计，包括总页数。例如，对于</span><span
>foods</span><span >数据库，可以得到关于</span><span
>episodes</span><span >表的如下信息：</span></p>
  <p><span>*** Table EPISODES
    *************************************************** </span></p>
  <p><span>Percentage of total database..........
    20.0% </span></p>
  <p><span>Number of entries..................... 181 </span></p>
  <p><span>Bytes of storage consumed............. 5120 </span></p>
  <p><span>Bytes of payload...................... 3229
    63.1% </span></p>
  <p><span>Average payload per entry.............
    17.84 </span></p>
  <p><span>Average unused bytes per entry........ 5.79 </span></p>
  <p><span>Average fanout........................ 4.00 </span></p>
  <p><span>Maximum payload per entry............. 38 </span></p>
  <p><span>Entries that use overflow............. 0
    0.0% </span></p>
  <p><span>Index pages used...................... 1 </span></p>
  <p><span>Primary pages used.................... 4 </span></p>
  <p><span>Overflow pages used................... 0 </span></p>
  <p><span>Total pages used...................... 5 </span></p>
  <p><span>Unused bytes on index pages........... 990
    96.7% </span></p>
  <p><span>Unused bytes on primary pages......... 58
    1.4% </span></p>
  <p><span>Unused bytes on overflow pages........ 0 </span></p>
  <p><span>Unused bytes on all pages............. 1048
    20.5% </span></p>
  <p><span >总页数是</span><span>5</span><span
>，但实际上表只用了</span><span>4</span><span
>页，还有</span><span>1</span><span
>页是索引。因为默认的缓冲区大小是</span><span>2000</span><span
>个页，所以你没有必要担心。在</span><span>episodes</span><span
>表中有</span><span>400</span><span
>条记录，也就是说每页可存放约</span><span>100</span><span
>条记录。所以，在修改所有记录之前你不需要考虑调整页缓冲区，除非</span><span>episodes</span><span
>中至少有了</span><span>196000</span><span
>条记录。还要记住，你只需要在有其它连接并发使用数据库的情况下才需要考虑这些，如果只有你自己使用数据库，这些就都不需要考虑了。</span></p>
  <h3><a name="_Toc245565836"><span >等待加锁</span></a></h3>
  <p><span >我们前面谈到过</span><span>pager</span><span
>等待从</span><span>PENDING</span><span
>状态进入</span><span>EXCLUSIVE</span><span
>状态，那么在这个期间到底发生了什么呢？首先，任何</span><span>exec()</span><span
>或</span><span>step()</span><span
>的调用都可能进入等待。当</span><span>SQLite</span><span
>遇到不能获得锁的情况时，它的默认表现总是向函数返回一个</span><span>SQLITE_BUSY</span><span
>并使函数继续寻求锁。无论你执行什么命令，都有可能遇到</span><span>SQLITE_BUSY</span><span
>，包括</span><span>SELECT</span><span
>命令，都有可能因为有其它的写进程处于未决状态而遇到</span><span>SQLITE_BUSY</span><span
>。当遇到</span><span>SQLITE_BUSY</span><span
>时，最简单的选择是重试。但是，下面我们就会看到这并不一定是最好的选择。</span></p>
  <h4><span style='font-family:黑体'>使用“忙”句柄</span></h4>
  <p><span >你可以使用一个忙句柄，而不是一遍遍地重试。忙句柄是一个函数，你创建它用来消磨时间或做其它任何事情――如给岳母发一封邮件</span><span
>(</span><span >？</span><span>)</span><span
>。它仅在</span><span>SQLite</span><span
>不能获得锁时被调用。忙句柄必须做的唯一的事是返回一个值，告诉</span><span>SQLite</span><span
>下一步该做什么。如果它返回</span><span>TRUE</span><span
>，</span><span>SQLite</span><span
>将会继续尝试获得锁；如果它返回</span><span>FALSE</span><span
>，</span><span>SQLite</span><span
>将向申请锁的函数返回</span><span>SQLITE_BUSY</span><span
>。看下面的例子：</span></p>
  <p><span>counter = 1 </span></p>
  <p><span>def busy()</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; counter = counter + 1 </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if counter == 2</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;return
    0</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; end</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; spam_mother_in_law(100)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return 1</span></p>
  <p><span>end </span></p>
  <p><span>db.busy_handler(busy)</span></p>
  <p><span>stmt = db.prepare('SELECT * FROM
    episodes;')</span></p>
  <p><span>stmt.step()</span></p>
  <p><span>stmt.finalize()</span></p>
  <p><span>spam_mother_in_law()</span><span
>完成一个发邮件功能。</span></p>
  <p><span>step()</span><span >函数必须获得一个</span><span
>SHARED</span><span >锁以完成</span><span
>SELECT</span><span >操作。如果此时有一个写进程活动，正常情况下</span><span
>step()</span><span >会返回</span><span
>SQLITE_BUSY</span><span >。但是，在上面程序中却不是这样，而是由</span><span
>pager</span><span >调用</span><span>busy()</span><span
>函数，因为它已经被注册队忙句柄。</span><span>busy()</span><span
>函数增加计数，给你岳母发一封邮件，并且返回</span><span>1</span><span
>，在</span><span>pager</span><span
>中会被翻译成</span><span>true</span><span
>――继续申请锁。</span><span>Pager</span><span
>再次申请获得</span><span>SHARED</span><span
>锁，但数据库仍然被锁着，于是</span><span>pager</span><span
>再次调用</span><span>busy()</span><span
>函数。只有此时，</span><span>busy()</span><span
>函数返回</span><span>0</span><span
>，在</span><span>pager</span><span
>中会被翻译成</span><span>false</span><span
>――返回</span><span>SQLITE_BUSY</span><span
>。</span></p>
  <h4><span style='font-family:黑体'>使用正确的事务</span></h4>
  <h2><a name="_Toc245565837"><span style='font-family:黑体'>编码</span></a></h2>
  <p><span >现在，你对</span><span>API</span><span
>、事务和锁已经有了很好的了解了。最后，我们把这</span><span>3</span><span
>个内容在代码中结合到一起。</span></p>
  <h3><a name="_Toc245565838"><span >使用多个连接</span></a></h3>
  <p><span >如果你曾经为其它的关系型数据库编写过程序，你就会发现有些适用于那些数据库的方法不一定适用于</span><span
>SQLite</span><span >。使用其它数据库时，经常会在同一个代码块中打开多个连接，典型的例子就是在一个连接中返复遍历一个表而在另一个连接中修改它的记录。</span></p>
  <p><span >在</span><span>SQLite</span><span
>中，在同一个代码块中使用多个连接会引起问题，必须小心地对待这种情况。请看下面代码：</span></p>
  <p><span>c1 = open('foods.db') </span></p>
  <p><span>c2 = open('foods.db') </span></p>
  <p><span>stmt = c1.prepare('SELECT * FROM episodes') </span></p>
  <p><span>while stmt.step() </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print
    stmt.column('name')</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; c2.exec('UPDATE episodes
    SET …) </span></p>
  <p><span>end </span></p>
  <p><span>stmt.finalize() </span></p>
  <p><span>c1.close() </span></p>
  <p><span>c2.close() </span></p>
  <p><span >问题很明显，当</span><span>c2</span><span
>试图执行</span><span>UPDATE</span><span
>时，</span><span>c1</span><span
>拥有一个</span><span>SHARED</span><span
>锁，这个锁只有等</span><span>stmt.finalize()</span><span
>之后才会释放。所以，是不可能成功写数据库的。最好的办法是在一个连接中完成工作，并且在同一个</span><span
>BEGIN IMMEDIATE</span><span >事务中完成。新程序如下：</span></p>
  <p><span>c1 = open('foods.db') </span></p>
  <p><span># Keep trying until we get it</span></p>
  <p><span>while c1.exec('BEGIN IMMEDIATE') != SQLITE_OK</span></p>
  <p><span>end</span></p>
  <p><span>stmt = c1.prepare('SELECT * FROM episodes') </span></p>
  <p><span>while stmt.step()</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print stmt.column('name') </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; c1.exec('UPDATE episodes
    SET …)</span></p>
  <p><span>end </span></p>
  <p><span>stmt.finalize()</span></p>
  <p><span>c1.exec('COMMIT')</span></p>
  <p><span>c1.close()</span></p>
  <p><span >在这种情况下，你应该在单独的连接中使用语句</span><span
>(statement)</span><span >来完成读和写，这样，你就不必担心数据库锁会引发问题了。但是，这个特别的示例仍然不能工作。如果你在一个语句</span><span
>(statement)</span><span >中返复遍历一个表而在另一个语句中修改它的记录，还有一个附加的锁问题你需要了解，我们将在下面介绍。</span></p>
  <h3><a name="_Toc245565839"><span >表锁</span></a></h3>
  <p><span >即使只使用一个连接，在有些边界情况下也会出现问题。不要认为一个连接中的两个语句</span><span
>(statements)</span><span >就能协调工作，至少有一个重要的例外。</span></p>
  <p><span >当在一个表上执行了</span><span
>SELECT</span><span >命令，语句对象会在表上创建一个</span><span
>B-tree</span><span >游标。如果表上有一个活动的</span><span
>B-tree</span><span >游标，即使是本连接中的其它语句也不能够再修改这个表。如果做这种尝试，将会得到</span><span
>SQLITE_BUSY</span><span >。看下面的例子：</span></p>
  <p><span>c = sqlite.open(&quot;foods.db&quot;) </span></p>
  <p><span>stmt1 = c.compile('SELECT * FROM episodes
    LIMIT 10') </span></p>
  <p><span>while stmt1.step() do </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; # Try to update the row</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; row = stm1.row()</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; stmt2 =
    c.compile('UPDATE episodes SET …')</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; # Uh oh: ain't gonna
    happen</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; stmt2.step()</span></p>
  <p><span>end </span></p>
  <p><span>stmt1.finalize()</span></p>
  <p><span>stmt2.finalize ()</span></p>
  <p><span>c.close() </span></p>
  <p><span >这里我们只使用了一个连接。但当调用</span><span
>stmt2.step()</span><span >则不会工作，因为</span><span
>stmt1</span><span >拥有</span><span>episodes</span><span
>表的一个游标。在这种情况下，</span><span>stmt2.step()</span><span
>有可能成功地将锁升级到</span><span>EXCLUSIVE</span><span
>，但仍会返回</span><span>SQLITE_BUSY</span><span
>，因为</span><span>episodes</span><span
>的游标会阻止它修改表。完成这种操作有两种方法：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >遍历一个语句的结果集，在内存中保存需要的信息。定案这个读语句，然后执行修改操作。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >将</span><span>SELECT</span><span
>的结果存到一个临时表中并用读游标打开它。这时同时有一个读语句和一个写语句，但它们在不同的表上，所以不会影响主表上的写操作。写完成后，删掉临时表就是了。</span></p>
  <p><span >当表上打开了一个语句，它的</span><span
>B-tree</span><span >游标在两种情况下会被移除：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >到达了语句结果集的尾部。这时</span><span
>step()</span><span >会自动地关闭语句的游标。从</span><span
>VDBE</span><span >的角度，当到达结果集的尾部时，</span><span
>CDBE</span><span >遇到</span><span>Close</span><span
>命令，这将导致所有相关游标的关闭。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >程序显式地调用了</span><span>finalize()</span><span
>，所有相关游标将关闭。</span></p>
  <p><span >在很多编程语言扩展中，</span><span
>statement</span><span >对象的</span><span
>close()</span><span >函数会自动调用</span><span
>sqlite3_finalize()</span><span >。</span></p>
  <h3><a name="_Toc245565840"><span >有趣的临时表</span></a></h3>
  <p><span >临时表使你可以做到不违反规则。如果你确实需要在一个代码块中使用两个连接，或者使用两个语句</span><span
>(statement)</span><span >操作同一个表，你可以安全地在临时表上如此做。当一个连接创建了一个临时表，不需要得到</span><span
>RESERVED</span><span >锁，因为临时表存在于数据库文件之外。有两种方法可以做到这一点，看你想如何管理并发。请看如下代码：</span></p>
  <p><span>c1 = open('foods.db') </span></p>
  <p><span>c2 = open('foods.db') </span></p>
  <p><span>c2.exec('CREATE TEMPORARY TABLE
    temp_epsidodes as SELECT * from episodes') </span></p>
  <p><span>stmt = c1.prepare('SELECT * FROM episodes') </span></p>
  <p><span>while stmt.step() </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print
    stmt.column('name')</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; c2.exec('UPDATE
    temp_episodes SET …') </span></p>
  <p><span>end</span></p>
  <p><span>stmt.finalize()</span></p>
  <p><span>c2.exec('BEGIN IMMEDIATE')</span></p>
  <p><span>c2.exec('DELETE FROM episodes')</span></p>
  <p><span>c2.exec('INSERT INTO episodes SELECT * FROM
    temp_episodes')</span></p>
  <p><span>c2.exec('COMMIT')</span></p>
  <p><span>c1.close()</span></p>
  <p><span>c2.close()</span></p>
  <p><span >上面的例子可以完成功能，但不好。</span><span
>episodes</span><span >表中的数据要全部删除并重建，这将丢失</span><span
>episodes</span><span >表中的所有完整性约束和索引。下面的方法比较好：</span></p>
  <p><span>c1 = open('foods.db') </span></p>
  <p><span>c2 = open('foods.db') </span></p>
  <p><span>c1.exec('CREATE TEMPORARY TABLE
    temp_episodes as SELECT * from episodes') </span></p>
  <p><span>stmt = c1.prepare('SELECT * FROM
    temp_episodes') </span></p>
  <p><span>while stmt.step() </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print
    stmt.column('name')</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; c2.exec('UPDATE episodes
    SET …') # What about SQLITE_BUSY? </span></p>
  <p><span>end </span></p>
  <p><span>stmt.finalize() </span></p>
  <p><span>c1.exec('DROP TABLE temp_episodes') </span></p>
  <p><span>c1.close() </span></p>
  <p><span>c2.close() </span></p>
  <h3><a name="_Toc245565841"><span >定案的重要性</span></a></h3>
  <p><span >使用</span><span>SELECT</span><span
>语句必须要意识到，其</span><span>SHARED</span><span
>锁</span><span>(</span><span style='font-family:
宋体'>大多数时候</span><span>)</span><span >直到</span><span
>finalize()</span><span >被调用后才会释放，请看下面代码：</span></p>
  <p><span>stmt = c1.prepare('SELECT * FROM episodes') </span></p>
  <p><span>while stmt.step() </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print
    stmt.column('name') </span></p>
  <p><span>end </span></p>
  <p><span>c2.exec('BEGIN IMMEDIATE; UPDATE episodes
    SET …; COMMIT;') </span></p>
  <p><span>stmt.finalize() </span></p>
  <p><span >如果你用</span><span>C
    API</span><span >写了与上例等价的程序，它实际上是能够工作的。尽管没有调用</span><span
>finalize()</span><span >，但第二个连接仍然能够修改数据库。在告诉你为什么之前，先来看第二个例子：</span></p>
  <p><span>c1 = open('foods.db') </span></p>
  <p><span>c2 = open('foods.db') </span></p>
  <p><span>stmt = c1.prepare('SELECT * FROM episodes') </span></p>
  <p><span>stmt.step()</span></p>
  <p><span>stmt.step()</span></p>
  <p><span>stmt.step()</span></p>
  <p><span>c2.exec('BEGIN IMMEDIATE; UPDATE episodes
    SET …; COMMIT;') </span></p>
  <p><span>stmt.finalize() </span></p>
  <p><span >假设</span><span>episodes</span><span
>中有</span><span>100</span><span
>条记录，程序仅仅访问了其中的</span><span>3</span><span
>条，这时会发生什么情况呢？第</span><span>2</span><span
>个连接会得到</span><span>SQLITE_BUSY</span><span
>。</span></p>
  <p><span >在第</span><span>1</span><span
>个例子中，当到达语句结果集尾部时，会释放</span><span>SHARED</span><span
>锁，尽管还没有调用</span><span>finalize()</span><span
>。在第</span><span>2</span><span
>个例子中，没有到达语句结果集尾部，</span><span>SHARED</span><span
>锁没有释放。所以，</span><span>c2</span><span
>不能执行</span><span>UPDATE</span><span
>操作。</span></p>
  <p><span >这个故事的中心思想是：不要这么做，尽管有时这么做是可以的。在用另一个连接进行写操作之前，永远要先调用</span><span
>finalize()</span><span >。</span><span
> </span></p>
  <h3><a name="_Toc245565842"><span >共享缓冲区模式</span></a></h3>
  <p><span >现在你对并发规则已经很清楚了，但我还要找些事来扰乱你。</span><span
>SQLite</span><span >提供一种可选的并发模式，称为共享缓冲区模式，它允许在单一的线程中操作多个连接。</span></p>
  <p><span >在共享缓冲区模式中，一个线程可以创建多个连接来共享相同的页缓冲区。进而，这组连接可以有多个“读”和一个“写”同时工作于相同的数据库。缓冲区不能在线程间共享，它被严格地限制在创建它的线程中。因此，“读”和“写”就需要准备处理与表锁有关的一些特殊情况。</span></p>
  <p><span >当</span><span> readers</span><span >读表时，</span><span> SQLite</span><span
>自动在这些表上加锁，</span><span>writer</span><span
>就不能再改这些表了。如果</span><span>writer</span><span
>试图修改一个有读锁的表，会得到</span><span>SQLITE_LOCKED</span><span
>。如果</span><span>readers</span><span
>运行在</span><span>read-uncommitted</span><span
>模式</span><span>(</span><span
>通过</span><span>read_uncommitted pragma</span><span
>来设置</span><span>)</span><span
>，则当</span><span>readers</span><span
>读表时，</span><span>writer</span><span
>也可以写表。在这种情况下，</span><span>SQLite</span><span
>不为</span><span>readers</span><span
>所读的表加读锁，结果就是</span><span>readers</span><span
>和</span><span>writer</span><span
>互不干扰。也因此，当一个</span><span>writer</span><span
>修改表时，这些</span><span>readers</span><span
>可能得到不一致的结果。</span></p>
  <br
clear=all style='page-break-before:always'>
  <h1><a name="_Toc245565843"></a><a name="_Toc242291771"><span style='font-family:
宋体'>第</span><span>6</span></a><span >章</span><span
>&nbsp; </span><span >核心</span><span
>C API</span></h1>
  <p><span >本章介绍用于数据库操作的</span><span
>SQLite API</span><span >。第</span><span
>5</span><span >章已经介绍了</span><span>API</span><span
>如何工作，本章关注细节。</span></p>
  <p><span >本章从几个例子开始，深入介绍</span><span
>C API</span><span >。学完本章之后，你会看到每个</span><span
>C API</span><span >函数都与常用的数据库操作有关，包括执行命令、管理事务、取记录、处理错误等等。</span></p>
  <p><span>SQLite</span><span >的版本</span><span
>3</span><span >的</span><span>API</span><span
>包括大约</span><span>80</span><span
>个函数。只有</span><span>8</span><span
>个函数在连接、查询和断开连接时是必须的，其它的函数用来完成特定的任务。</span></p>
  <p><span >如第</span><span>5</span><span
>章所述，版本</span><span>3</span><span
>与</span><span>2</span><span style='font-family:
宋体'>的</span><span>API</span><span >相比有较大改变。最值得关注的一个改变是增加了对</span><span
>UTF</span><span >的支持。所有接受字符串做为参数或返回字符串的函数都同时具有</span><span
>UTF-8</span><span >和</span><span>UTF-16</span><span
>的相似体。例如，</span><span>sqlite3_open()</span><span
>，接受一个</span><span>UTF-8</span><span
>的数据库名做参数；而</span><span>sqlite3_open16()</span><span
>具有同样的功能与格式，但参数使用</span><span>UTF-16</span><span
>编码。本章一般只介绍</span><span>UTF-8</span><span
>的函数，</span><span>UTF-16</span><span
>版本仅仅是在名字上有微小差别。</span></p>
  <p><span >本章最好顺序地读，如果在细节上有问题，可以参考附录</span><span
>B</span><span >。</span></p>
  <p><span >空注：第</span><span>6</span><span
>、</span><span>7</span><span style='font-family:
宋体'>两章应该也是本书的精华了，主要介绍对</span><span>SQLite</span><span
>进行编程的方法。大多数</span><span>SQLite</span><span
>的使用者可能更关心这两章，但我又不开发基于</span><span>SQLite</span><span
>的应用程序，研究</span><span>SQLite</span><span
>纯粹出于兴趣，个人更关心</span><span>SQLite</span><span
>本身的实现方法，所以对这部分内容只是略做浏览。关心这部分内容的兄弟还是得自己看原文。</span></p>
  <h2><a name="_Toc245565844"><span style='font-family:黑体'>封装的查询</span></a></h2>
  <p><span >你已经熟悉了</span><span>SQLite</span><span
>执行查询的方法，包括在一个单独的函数中执行封装的</span><span>SQL</span><span
>。我们从封装的</span><span>SQL</span><span
>开始介绍，因为这些函数简单、独立且易用。它们是好的起点，使你能得到乐趣，又不会被过多的细节所困扰。</span></p>
  <h3><a name="_Toc245565845"><span >连接和断开连接</span></a></h3>
  <p><span >在执行</span><span>SQL</span><span
>命令之前，首先要连接数据库。因为</span><span>SQLite</span><span
>数据库存储在一个单独的操作系统文件当中，所以连接数据库可以理解为“打开”数据库。同样，断开连接也就是关闭数据库。</span></p>
  <p><span >打开数据库用</span><span>sqlite3_open()</span><span
>或</span><span>sqlite3_open16()</span><span
>函数，它们的声明如下：</span></p>
  <p><span>int sqlite3_open(</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char *filename, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
    Database filename (UTF-8) */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 **ppDb &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
    OUT: SQLite db handle */</span></p>
  <p><span>); </span></p>
  <p><span>int sqlite3_open16( </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const void *filename,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
    Database filename (UTF-16) */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 **ppDb &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
    OUT: SQLite db handle */</span></p>
  <p><span>); </span></p>
  <p><span >其中，</span><span>filename</span><span
>参数可以是一个操作系统文件名，或字符串</span><span>':memory:'</span><span
>，或一个空指针</span><span>(NULL)</span><span
>。用后两者将创建内存数据库。如果</span><span>filename</span><span
>不为空，先尝试打开，如果文件不存在，则用这个名字创建一个新的数据库。</span></p>
  <p><span >关闭连接使用</span><span>sqlite3_close()</span><span
>函数，它的声明如下：</span></p>
  <p><span>int sqlite3_close(sqlite3*); </span></p>
  <p><span >为了</span><span>sqlite3_close()</span><span
>能够成功执行，所有与连接所关联的已编译的查询必须被定案。如果仍然有查询没有定案，</span><span
>sqlite3_close()</span><span >将返回</span><span
>SQLITE_BUSY</span><span >和错误信息：</span><span
>Unable to close due to unfinalized statements</span><span
>。</span></p>
  <h3><a name="_Toc245565846"><span >执行</span><span
>Query</span></a><span> </span></h3>
  <p><span >函数</span><span>sqlite3_exec()</span><span
>提供了一种执行</span><span>SQL</span><span
>命令的快速、简单的方法，它特别适合处理对数据库的修改操作</span><span>(</span><span
>不需要返回数据</span><span>)</span><span
>。</span><span>sqlite3_exec()</span><span
>的声明如下：</span></p>
  <p><span>int sqlite3_exec( </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3*, /* An open
    database */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char *sql, /* SQL
    to be executed */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite_callback, /*
    Callback function */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; void *data /* 1st
    argument to callback function */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char **errmsg /* Error
    msg written here */ </span></p>
  <p><span>); </span></p>
  <p><span>SQL</span><span >命令由</span><span
>sql</span><span >参数提供，它可以由多个</span><span
>SQL</span><span >命令构成，</span><span>sqlite3_exec()</span><span
>会对其中每个命令进行分析并执行，直到命令串结束或遇到一个错误。列表</span><span
>6-1(</span><span >来自</span><span>create.c)</span><span
>说明了</span><span>sqlite3_exec()</span><span
>的用法：</span></p>
  <p><span >列表</span><span>6-1 </span><span
>对简单的命令使用</span><span>sqlite3_exec()</span></p>
  <p><span>#include &lt;stdio.h&gt;</span></p>
  <p><span>#include &lt;stdlib.h&gt;</span></p>
  <p><span>#include &quot;util.h&quot;</span></p>
  <p><span>#pragma comment(lib,
    &quot;sqlite3.lib&quot;)</span></p>
  <p><span>int main(int argc, char **argv)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 *db;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *zErr;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int rc;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *sql;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc =
    sqlite3_open(&quot;test.db&quot;, &amp;db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if (rc) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;Can't open database: %s\n&quot;, sqlite3_errmsg(db));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    exit(1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;create table
    episodes( id integer primary key,&quot;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;&nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name
    text, cid int)&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc = sqlite3_exec(db, sql,
    NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if (rc != SQLITE_OK) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    if (zErr != NULL) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;SQL error: %s\n&quot;, zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_free(zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;insert into
    episodes (name,id) values ('Cinnamon Babka2',1)&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc = sqlite3_exec(db,
    sql, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if (rc != SQLITE_OK) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    if (zErr != NULL) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;SQL error: %s\n&quot;, zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_free(zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return
    0;&nbsp;&nbsp;&nbsp; </span></p>
  <p><span>}</span></p>
  <h4><span style='font-family:黑体'>处理记录</span><span> </span></h4>
  <p><span >如第</span><span>5</span><span
>章所述，还是有可能从</span><span>sqlite3_exec()</span><span
>取得记录的。</span><span>sqlite3_exec()</span><span
>包含一个回叫</span><span>(callback)</span><span
>机制，提供了一种从</span><span>SELECT</span><span
>语句得到结果的方法。这个机制由</span><span>sqlite3_exec()</span><span
>函数的第</span><span>3</span><span
>和第</span><span>4</span><span
>个参数实现。第</span><span>3</span><span
>个参数是一个指向回叫函数的指针，如果提供了回叫函数，</span><span>SQLite</span><span
>则会在执行</span><span>SELECT</span><span
>语句期间在遇到每一条记录时调用回叫函数。回叫函数的声明如下：</span></p>
  <p><span>typedef int (*sqlite3_callback)( </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; void*, /* Data provided
    in the 4th argument of sqlite3_exec() */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int, /* The number of
    columns in row */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char**, /* An array of
    strings representing fields in the row */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char** /* An array of
    strings representing column names */ </span></p>
  <p><span>); </span></p>
  <p><span >函数</span><span>sqlite3_exec()</span><span
>的第</span><span>4</span><span
>个参数是一个指向任何应用程序指定的数据的指针，这个数据是你准备提供给回叫函数使用的。</span><span
>SQLite</span><span >将把这个数据作为回叫函数的第</span><span
>1</span><span >个参数传递。</span></p>
  <p><span >总之，</span><span>sqlite3_exec()</span><span
>允许你处理一批命令，并且你可以使用回叫函数来收集所有返回的数据。例如，先向</span><span
>episodes</span><span >表插入一条记录，再从中查询所有记录，所有这些都在一个</span><span
>sqlite3_exec()</span><span >调用中完成。完整的程序代码见列表</span><span
>6-2</span><span >，它来自</span><span>exec.c</span><span
>。</span></p>
  <p><span >列表</span><span>6-2 </span><span
>将</span><span>sqlite3_exec()</span><span
>用于记录处理</span></p>
  <p><span>#include &lt;stdio.h&gt;</span></p>
  <p><span>#include &lt;stdlib.h&gt;</span></p>
  <p><span>#include &quot;util.h&quot;</span></p>
  <p><span>#pragma comment(lib,
    &quot;sqlite3.lib&quot;)</span></p>
  <p><span>int callback(void* data, int ncols, char**
    values, char** headers);</span></p>
  <p><span>int main(int argc, char **argv)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 *db;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int rc;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *sql;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *zErr;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char*
    data;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc = sqlite3_open(&quot;test.db&quot;,
    &amp;db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(rc) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;Can't open database: %s\n&quot;, sqlite3_errmsg(db));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    exit(1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; data = &quot;Callback
    function called&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;insert into
    episodes (name, cid) values ('Mackinaw Peaches', 1);&quot;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    &quot;select * from episodes;&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc = sqlite3_exec(db,
    sql, callback, data, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(rc != SQLITE_OK) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    if (zErr != NULL) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;SQL error: %s\n&quot;, zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_free(zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return
    0;&nbsp;&nbsp;&nbsp; </span></p>
  <p><span>}</span></p>
  <p><span>int callback(void* data, int ncols, char**
    values, char** headers)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int i;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stderr,
    &quot;%s: &quot;, (const char*)data);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; for(i=0; i &lt; ncols;
    i++) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;%s=%s &quot;, headers[i], values[i]);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stderr,
    &quot;\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return 0;</span></p>
  <p><span>}</span></p>
  <h3><a name="_Toc245565847"><span >字符串处理</span></a></h3>
  <p><span>int main(int argc, char **argv)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *sql;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *trouble =
    &quot;'Here's trouble'&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql =
    sqlite3_mprintf(&quot;insert into x values('%q')&quot;, trouble);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;%s\n&quot;, sql);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_free(sql);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return
    0;&nbsp;&nbsp;&nbsp; </span></p>
  <p><span>}</span></p>
  <p><span>The result sql will contain </span></p>
  <p><span>insert into x values('''Here''s trouble''') </span></p>
  <p><span>Listing 6-3. Using sqlite3_vmprintf() </span></p>
  <p><span>int execute(sqlite3 *db, const char* sql,
    ...) </span></p>
  <p><span lang=FR>{ </span></p>
  <p><span lang=FR>&nbsp;&nbsp;&nbsp; char *err, *tmp;</span></p>
  <p><span lang=FR>&nbsp;&nbsp;&nbsp; va_list ap;</span></p>
  <p><span lang=FR>&nbsp;&nbsp;&nbsp; va_start(ap, sql);</span></p>
  <p><span lang=FR>&nbsp;&nbsp;&nbsp; tmp = sqlite3_vmprintf(sql,
    ap);</span></p>
  <p><span lang=FR>&nbsp;&nbsp;&nbsp; va_end(ap);</span></p>
  <p><span lang=FR>&nbsp;&nbsp;&nbsp; int rc = sqlite3_exec(db,
    tmp, NULL, NULL, &amp;err);</span></p>
  <p><span lang=FR>&nbsp;&nbsp;&nbsp; </span><span>if(rc
    != SQLITE_OK) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    if (err != NULL) { </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stdout, &quot;execute() : Error %i : %s\n&quot;, rc, err); </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_free(err);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_free(tmp);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return rc;</span></p>
  <p><span>}</span></p>
  <h3><a name="_Toc245565848"><span>Get Table</span></a><span
>查询</span></h3>
  <p><span>int sqlite3_get_table( </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3*, /* An open
    database */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char *sql, /* SQL
    to be executed */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char ***resultp, /*
    Result written to a char *[] that this points to */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int *nrow, /* Number of
    result rows written here */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int *ncolumn, /* Number
    of result columns written here */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char **errmsg /* Error
    msg written here */ </span></p>
  <p><span>); </span></p>
  <p><span>Listing 6-4. Using sqlite3_get_table </span></p>
  <p><span>void main(int argc, char **argv)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 *db;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *zErr;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int rc,i;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *sql;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char **result;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
    nrows, ncols;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Connect to database,
    etc. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc =
    sqlite3_open(&quot;test.db&quot;, &amp;db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;select *
    from episodes;&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc = sqlite3_get_table(db,
    sql, &amp;result, &amp;nrows, &amp;ncols, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Do something with
    data */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;rows=%d,cols=%d\n&quot;,nrows,ncols);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for
    (i=0;i&lt;=nrows;i++)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;%-5s%-20s%-5s\n&quot;,result[3*i],result[3*i+1],result[3*i+2]);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Free memory */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_free_table(result);</span></p>
  <p><span>}</span></p>
  <p><span>If, for example, the result set returned is
    of the form </span></p>
  <p><span>rows=2,cols=3</span></p>
  <p><span>id&nbsp;&nbsp;
    name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    cid</span></p>
  <p><span>1&nbsp;&nbsp;&nbsp; Cinnamon
    Babka2&nbsp;&nbsp;&nbsp;&nbsp; (null)</span></p>
  <p><span>2&nbsp;&nbsp;&nbsp; Mackinaw
    Peaches&nbsp;&nbsp;&nbsp; 1</span></p>
  <h2><a name="_Toc245565849"><span style='font-family:黑体'>预处理的查询</span></a></h2>
  <p><span>As you’ll recall from Chapter 5, prepared
    queries are performed in three basic steps: compilation, execution, and
    finalization. This process is illustrated in Figure 6-1. </span></p>
  <p><span><img width=347 height=481
src="Definitive Guide/image010.jpg"></span></p>
  <p><span>Figure 6-1. Prepared query processing </span></p>
  <p><span>Now that you’ve seen the whole process,
    let’s go through an example. A simple, complete program using a prepared query
    is listed in Listing 6-6. It is taken from select.c in the examples. </span></p>
  <p><span>Listing 6-6. Using Prepared Queries </span></p>
  <p><span>#include &lt;string.h&gt;</span></p>
  <p><span>int main(int argc, char **argv)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int rc, i, ncols;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 *db;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_stmt *stmt;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *sql;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char *tail;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc =
    sqlite3_open(&quot;test.db&quot;, &amp;db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(rc) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;Can't open database: %s\n&quot;, sqlite3_errmsg(db));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    exit(1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;select *
    from episodes;&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc = sqlite3_prepare(db,
    sql, (int)strlen(sql), &amp;stmt, &amp;tail);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(rc != SQLITE_OK) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;SQL error: %s\n&quot;, sqlite3_errmsg(db));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc = sqlite3_step(stmt);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; ncols =
    sqlite3_column_count(stmt); </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; while(rc == SQLITE_ROW)
    {</span></p>
  <p><span>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;
    i &lt; ncols; i++) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;'%s' &quot;, sqlite3_column_text(stmt, i));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    rc = sqlite3_step(stmt);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_finalize(stmt);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return
    0;&nbsp;&nbsp;&nbsp; </span></p>
  <p><span>}</span></p>
  <p><span >跟</span><span>sqlite3_exec()</span><span
>相似，</span><span>sqlite3_prepare()</span><span
>也可以接受一个包括多个</span><span>SQL</span><span
>语句的字符串。不同的是</span><span>sqlite3_prepare()</span><span
>只处理字符串中的第</span><span>1</span><span
>个语句。</span><span>But it does make it easy for
    you to process subsequent SQL statements in the string by providing the
    pzTailout parameter. After you call sqlite3_prepare(), it will point this
    parameter (if provided) to the starting position of the next statement in the
    zSQL string. Using pzTail, processing a batch of SQL commands in a given string
    can be executed in a loop as follows: </span></p>
  <p><span>while(sqlite3_complete(sql) { </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc = sqlite3_prepare(db,
    sql, strlen(sql), &amp;stmt, &amp;tail);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Process query results
    */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Skip to next command
    in string. */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = tail; </span></p>
  <p><span>} </span></p>
  <h3><a name="_Toc245565850"><span >取记录</span></a></h3>
  <h4><span style='font-family:黑体'>取字段信息</span></h4>
  <p><span >你可以使用</span><span>sqlite3_column_name()</span><span
>来取得各字段的名称：</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char
    *sqlite3_column_name( sqlite3_stmt*, /* statement handle */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    int iCol /* column ordinal */); </span></p>
  <p><span >类似地，你可以使用</span><span
>sqlite3_column_type()</span><span >取得各字段的存储类：</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int sqlite3_column_type(
    sqlite3_stmt*, /* statement handle */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    int iCol /* column ordinal */); </span></p>
  <p><span >这个函数返回一个整数值，代表</span><span
>5</span><span >个存储类的代码，定义如下：</span></p>
  <p><span>#define SQLITE_INTEGER 1 </span></p>
  <p><span>#define SQLITE_FLOAT 2 </span></p>
  <p><span>#define SQLITE_TEXT 3 </span></p>
  <p><span>#define SQLITE_BLOB 4 </span></p>
  <p><span>#define SQLITE_NULL 5 </span></p>
  <p><span >这些是</span><span>SQLite</span><span
>本身的类型，或称存储类，在第</span><span>4</span><span
>章有详细介绍。</span><span>All data stored within a
    SQLite database is stored in one of these five forms, depending on its initial
    representation and the affinity of the column. For our purposes, the terms
    storage class and data type are synonymous. For more information on storage
    classes, see the sections “Storage Classes” and “Type Affinity” in Chapter 4. </span></p>
  <p><span >你可以使用</span><span>sqlite3_column_decltype()</span><span
>函数获得字段声明的数据类型：</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char
    *sqlite3_column_decltype( sqlite3_stmt*, /* statement handle */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    int /* column ordinal */); </span></p>
  <p><span >如果结果集中的一列不是来自一个实际的字段</span><span
>(</span><span >如来自于表达式、函数或聚合的结果</span><span
>)</span><span >，这个函数将返回</span><span
>NULL</span><span >。</span><span>For
    example, suppose you have a table in your database defined as </span></p>
  <p><span>CREATE TABLE t1(c1 INTEGER); </span></p>
  <p><span>Then you execute the following query: </span></p>
  <p><span>SELECT c1 + 1, 0 FROM t1; </span></p>
  <p><span>In this case, sqlite3_column_decltype()
    will return INTEGER for the first column and NULL for </span></p>
  <p><span>the second. </span></p>
  <p><span >还可以用下列函数获得字段的其它信息：</span></p>
  <p><span>const char
    *sqlite3_column_database_name(sqlite3_stmt *pStmt, int iCol); </span></p>
  <p><span>const char
    *sqlite3_column_table_name(sqlite3_stmt *pStmt, int iCol); </span></p>
  <p><span>const char
    *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int iCol); </span></p>
  <p><span>The first function will return the database
    associated with a column, the second its table, and </span></p>
  <p><span>the last function returns the column’s
    actual name as defined in the schema. That is, if you </span></p>
  <p><span>assigned the column an alias in the SQL
    statement, sqlite3_column_origin_name() will return </span></p>
  <p><span>its actual name as defined in the schema.
    Note that these functions are only available if you </span></p>
  <p><span>compile SQLite with the <span
style='color:#CC0000'>SQLITE_ENABLE_COLUMN_METADATA</span> preprocessor
    directive. </span></p>
  <p><span >列元数据：</span></p>
  <p><span >字段的详细信息可以从一个独立的</span><span
>query</span><span >获得，使用</span><span
>sqlite3_table_column_metadata()</span><span >函数，声明如下：</span></p>
  <p><span>SQLITE_API int
    sqlite3_table_column_metadata(</span></p>
  <p><span>&nbsp; sqlite3
    *db,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* Connection handle */</span></p>
  <p><span>&nbsp; const char
    *zDbName,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Database name or NULL */</span></p>
  <p><span>&nbsp; const char
    *zTableName,&nbsp;&nbsp;&nbsp;&nbsp; /* Table name */</span></p>
  <p><span>&nbsp; const char
    *zColumnName,&nbsp;&nbsp;&nbsp; /* Column name */</span></p>
  <p><span>&nbsp; char const
    **pzDataType,&nbsp;&nbsp;&nbsp; /* OUTPUT: Declared data type */</span></p>
  <p><span>&nbsp; char const
    **pzCollSeq,&nbsp;&nbsp;&nbsp; &nbsp;/* OUTPUT: Collation sequence name */</span></p>
  <p><span>&nbsp; int
    *pNotNull,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* OUTPUT: True if NOT NULL constraint exists */</span></p>
  <p><span>&nbsp; int
    *pPrimaryKey,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
    OUTPUT: True if column part of PK */</span></p>
  <p><span>&nbsp; int
    *pAutoinc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* OUTPUT: True if column is auto-increment */</span></p>
  <p><span>);</span></p>
  <p><span >这个函数包含输入和输出参数。它不在</span><span
>statement</span><span >句柄下工作，但需要提供连接句柄、数据库名、表名和列名。可选的数据库名指明附加的逻辑数据库名</span><span
>(</span><span >一个连接上可能附加多个数据库</span><span
>)</span><span >。表名和字段名是必须的。</span><span
> </span></p>
  <h4><span style='font-family:黑体'>取字段值</span></h4>
  <p><span >可以使用</span><span>sqlite3_column_xxx()</span><span
>函数取当前记录中每个字段的值，其一般形式为：</span></p>
  <p><span>xxx sqlite3_column_xxx( sqlite3_stmt*, /*
    statement handle */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int iCol /* column ordinal
    */); </span></p>
  <p><span>xxx</span><span >表示你希望得到的数据类型。</span><span
>sqlite3_column_xxx()</span><span >包括以下函数：</span></p>
  <p><span>int sqlite3_column_int(sqlite3_stmt*, int
    iCol);</span></p>
  <p><span>double sqlite3_column_double(sqlite3_stmt*,
    int iCol);</span></p>
  <p><span>long long int
    sqlite3_column_int64(sqlite3_stmt*, int iCol);</span></p>
  <p><span>const void *sqlite3_column_blob(sqlite3_stmt*,
    int iCol);</span></p>
  <p><span>const unsigned char
    *sqlite3_column_text(sqlite3_stmt*, int iCol);</span></p>
  <p><span>const void
    *sqlite3_column_text16(sqlite3_stmt*, int iCol);</span></p>
  <p><span >对每个函数，</span><span>SQLite</span><span
>都会将字段值从存储类转化为函数指定的结果类型。</span><span>Table 6-1</span><span
>中是转换规则。</span></p>
  <p><span>Table 6-1. Column Type Conversion Rules </span></p>
  <p><span>Internal Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Requested
    Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Conversion </span></p>
  <p><span>NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result
    is 0. </span></p>
  <p><span>NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLOAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result
    is 0.0. </span></p>
  <p><span>NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result
    is a NULL pointer. </span></p>
  <h4><span style='font-family:黑体'>一个实际的例子</span></h4>
  <p><span>To help solidify all of these column
    functions, Listing 6-7 (taken from columns.c) illustrates using the functions we’ve
    described to retrieve column information and values for a simple SELECT
    statement. </span></p>
  <p><span>Listing 6-7. Obtaining Column Information </span></p>
  <p><span>#include &lt;string.h&gt;</span></p>
  <p><span>int main(int argc, char **argv)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int rc, i, ncols, id,
    cid; </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char
    *name, *sql;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 *db; sqlite3_stmt
    *stmt;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql =
    &quot;select id,cid,name from episodes&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;
    sqlite3_open(&quot;test.db&quot;, &amp;db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_prepare(db, sql,
    strlen(sql), &amp;stmt, NULL);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; ncols =
    sqlite3_column_count(stmt); </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc = sqlite3_step(stmt);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Print column
    information */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; for(i=0; i &lt; ncols;
    i++) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stdout, &quot;Column: name=%s, storage class=%i, declared=%s\n&quot;, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_column_name(stmt, i),</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_column_type(stmt, i),</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_column_decltype(stmt, i));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; while(rc == SQLITE_ROW)
    {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    id = sqlite3_column_int(stmt, 0);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    cid = sqlite3_column_int(stmt, 1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    name = (char *)sqlite3_column_text(stmt, 2);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    if(name != NULL){</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;Row:&nbsp; id=%i, cid=%i, name='%s'\n&quot;,
    id,cid,name);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    } else {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* Field is NULL */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;Row:&nbsp; id=%i, cid=%i, name=NULL\n&quot;, id,cid);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    } </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    rc = sqlite3_step(stmt);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_finalize(stmt);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return 0;</span></p>
  <p><span>}</span></p>
  <h3><a name="_Toc245565851"><span >参数化的查询</span></a></h3>
  <p><span><img width=556 height=503
src="Definitive Guide/image011.jpg"></span></p>
  <p><span>Figure 6-2. SQL parameter binding </span></p>
  <h2><a name="_Toc245565852"><span style='font-family:黑体'>错误和意外</span></a></h2>
  <p><span >有些</span><span>API</span><span
>是很可能出错的，在编码时总要记得</span><span>3</span><span
>件事：错误、忙状态和</span><span>schema</span><span
>改变。</span></p>
  <h3><a name="_Toc245565853"><span >处理错误</span></a></h3>
  <p><span >很多</span><span>API</span><span
>函数返回整数结果码，这表示它们可以返回错误码。在使用一个函数之前，应该仔细阅读关于该函数的说明</span><span
>(</span><span >见附录</span><span>B)</span><span
>，看它可能引发什么错误。</span><span>API</span><span
>中定义了大约</span><span>23</span><span
>种错误。所有的</span><span>SQLite</span><span
>返回码见表</span><span>6-2</span><span
>。所有能够返回这些码的函数包括：</span></p>
  <p><span>sqlite3_bind_xxx()</span></p>
  <p><span>sqlite3_close()</span></p>
  <p><span>sqlite3_create_collation()</span></p>
  <p><span>sqlite3_collation_needed()</span></p>
  <p><span>sqlite3_create_function()</span></p>
  <p><span>sqlite3_prepare()</span></p>
  <p><span>sqlite3_exec()</span></p>
  <p><span>sqlite3_finalize()</span></p>
  <p><span>sqlite3_get_table()</span></p>
  <p><span>sqlite3_open()</span></p>
  <p><span>sqlite3_reset()</span></p>
  <p><span>sqlite3_step()</span></p>
  <p><span>sqlite3_transfer_bindings()</span></p>
  <p><span >可以使用函数</span><span>sqlite3_errmsg()</span><span
>获得附加的错误信息，其声明如下：</span></p>
  <p><span>const char *sqlite3_errmsg(sqlite3 *); </span></p>
  <p><span >它以一个连接句柄作参数，返回该连接最近的一条错误信息。如果还没有发生错误，它返回</span><span
>“not an error”</span><span >。</span></p>
  <p><span >表</span><span>6-2 SQLit</span><span
>的返回码</span></p>
  <table border=1 cellspacing=0 cellpadding=0>
    <tr>
      <td width=158 valign=top><p align=center style='text-align:center'><span
  >返回码</span></p></td>
      <td width=410 valign=top><p align=center style='text-align:center'><span
  >说明</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_OK</span></p></td>
      <td width=410 valign=top><p><span>The operation was successful.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_ERROR</span></p></td>
      <td width=410 valign=top><p><span>General SQL error or missing database. It
          may be possible to obtain more error information depending on the error
          condition (SQLITE_SCHEMA, for example).</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_PERM</span></p></td>
      <td width=410 valign=top><p><span>Access permission denied. Cannot read or
          write to the database file.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_ABORT</span></p></td>
      <td width=410 valign=top><p><span>A callback routine requested an abort.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_BUSY</span></p></td>
      <td width=410 valign=top><p><span>The database file is locked.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_LOCKED</span></p></td>
      <td width=410 valign=top><p><span>A table in the database is locked.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_NOMEM</span></p></td>
      <td width=410 valign=top><p><span>A call to malloc() has failed within a
          database operation.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_READONLY</span></p></td>
      <td width=410 valign=top><p><span>An attempt was made to write to a
          read-only database.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_INTERRUPT</span></p></td>
      <td width=410 valign=top><p><span>Operation was terminated by
          sqlite3_interrupt().</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_IOERR</span></p></td>
      <td width=410 valign=top><p><span>Some kind of disk I/O error occurred.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_CORRUPT</span></p></td>
      <td width=410 valign=top><p><span>The database disk image is malformed.
          This will also occur if an attempt is made to open a non-SQLite database file
          as a SQLite database. SQLITE_FULL Insertion failed because the database is
          full. There is no more space on the file system or the database file cannot
          be expanded. </span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_CANTOPEN</span></p></td>
      <td width=410 valign=top><p><span>SQLite was unable to open the database
          file.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_PROTOCOL</span></p></td>
      <td width=410 valign=top><p><span>The database is locked or there has been
          a protocol error.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_EMPTY</span></p></td>
      <td width=410 valign=top><p><span>(Internal only) The database table is
          empty.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_SCHEMA</span></p></td>
      <td width=410 valign=top><p><span>The database schema has changed.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_CONSTRAINT</span></p></td>
      <td width=410 valign=top><p><span>Abort due to constraint violation. This
          constant is returned if the SQL statement would have violated a database
          constraint (such as attempting to insert a value into a unique index that
          already exists in the index).</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_MISMATCH</span></p></td>
      <td width=410 valign=top><p><span>Data type mismatch. An example of this is
          an attempt to insert non-integer data into a column labeled INTEGER PRIMARY
          KEY. For most </span></p>
        <p><span>columns, SQLite ignores the data type and
          allows any kind of data to be stored. But an INTEGER PRIMARY KEY column is
          only allowed to store integer data.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_MISUSE</span></p></td>
      <td width=410 valign=top><p><span>Library was used incorrectly. This error
          might occur if one or more of the SQLite API routines is used incorrectly.
          Examples of incorrect usage include calling sqlite3_exec() after the database
          has been closed using sqlite3_close() or calling sqlite3_exec() with the same
          database pointer simultaneously from two separate threads.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_NOLFS</span></p></td>
      <td width=410 valign=top><p><span>Uses OS features not supported on host.
          This value is returned if the SQLite library was compiled with large file
          support (LFS) enabled but </span></p>
        <p><span>LFS isn’t supported on the host operating
          system.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_AUTH</span></p></td>
      <td width=410 valign=top><p><span>Authorization denied. This occurs when a
          callback function installed using sqlite3_set_authorizer() returns
          SQLITE_DENY.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_ROW</span></p></td>
      <td width=410 valign=top><p><span>sqlite3_step() has another row ready.</span></p></td>
    </tr>
    <tr>
      <td width=158 valign=top><p><span>SQLITE_DONE</span></p></td>
      <td width=410 valign=top><p><span>sqlite3_step() has finished executing.</span></p></td>
    </tr>
  </table>
  <h3><a name="_Toc245565854"><span >处理忙状态</span></a></h3>
  <h2><a name="_Toc245565855"><span style='font-family:黑体'>操作控制</span></a></h2>
  <p><span>API</span><span >提供了几个函数，可以用来监视或管理编译期间和运行时的</span><span
>SQL</span><span >命令。这些函数允许你建立回叫函数，并以此对不同的数据库事件进行监视和控制</span><span
>(</span><span >当事件发生时</span><span>)</span><span
>。</span></p>
  <h3><a name="_Toc245565856"><span >提交</span><span
>Hook</span></a><span >函数</span></h3>
  <p><span >使用</span><span>sqlite3_commit_hook()</span><span
>函数可以在特定连接提交事务时对其进行监视。其声明如下：</span></p>
  <p><span>void *sqlite3_commit_hook( sqlite3 *cnx, /*
    database handle */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int(*xCallback)(void
    *data), /* callback function */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; void *data); /*
    application data */ </span></p>
  <h3><a name="_Toc245565857"><span >回卷</span><span
>Hook</span></a><span >函数</span></h3>
  <p><span >回卷</span><span>Hook</span><span
>函数与提交</span><span>Hook</span><span
>函数相类似，但它在特定连接回卷事务时对其进行监视。</span></p>
  <p><span>void *sqlite3_rollback_hook(sqlite3 *cnx,
    void(*xCallback)(void *data), void *data); </span></p>
  <h3><a name="_Toc245565858"><span >修改</span><span
>Hook</span></a><span >函数</span></h3>
  <p><span >函数</span><span>sqlite3_update_hook()</span><span
>用来监视特定数据库连接所有的</span><span>UPDATE</span><span
>、</span><span>INSERT</span><span
>和</span><span>DELETE</span><span
>操作，对这些操作中所涉及的每一行都进行监视，其声明如下：</span></p>
  <p><span>void *sqlite3_update_hook( </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 *cnx,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; void(*)(void *, int,
    char const*, char const*, sqlite_int64),</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; void *data); </span></p>
  <p><span>The first argument of the callback function
    is a pointer to application-specific data, which you provide in the third
    argument. The callback function has the following form: </span></p>
  <p><span>void callback ( void * data,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int operation_code,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char const *db_name,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char const *table_name,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite_int64 rowid), </span></p>
  <h3><a name="_Toc245565859"><span >授权函数</span></a></h3>
  <p><span>sqlite3_set_authorizer()</span><span
>是最强有力的事件过滤函数。用它可以在查询编译的时候对其进行监视和控制。其声明如下：</span></p>
  <p><span>int sqlite3_set_authorizer( </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3*, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int (*xAuth)( void*,int,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    const char*, const char*, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    const char*,const char*), </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; void *pUserData </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; ); </span></p>
  <p><span >其中注册了一个</span><span>callback</span><span
>函数，作为授权函数。</span><span>SQLite</span><span
>在一些数据库事件的命令编译阶段将会调用它</span><span>(</span><span
>不是在执行阶段</span><span>)</span><span
>。这个函数的用意是使用</span><span>SQLite</span><span
>能够安全地执行用户提供的</span><span>SQL(user-supplied
    SQL)</span><span >。它提供了一种途径将这类</span><span>SQL</span><span
>限制在特定的操作上或拒绝对某些表或字段的存取。</span></p>
  <p><span>Callback</span><span style='font-family:
宋体'>的声明形式如下：</span></p>
  <p><span>int auth( void*, /* user data */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int, /* event code */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char*, /* event
    specific */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char*, /* event
    specific */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char*, /* database
    name */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char* /* trigger
    or view name */ ); </span></p>
  <p><span >第</span><span>1</span><span
>个参数是一个数据指针，它会传递给</span><span>sqlite3_set_authorizer()</span><span
>函数的第</span><span>4</span><span
>个参数。第</span><span>2</span><span
>个参数是一个常量，可选值在表</span><span>6-3</span><span
>中列出。这些常量值表示需要授权的是什么操作。第</span><span>3</span><span
>、</span><span>4</span><span style='font-family:
宋体'>个函数的含义决定于事件代码</span><span>(</span><span >第</span><span
>2</span><span >个参数，参表</span><span>6-3)</span><span
>。</span></p>
  <p><span >第</span><span>5</span><span
>个参数是数据库名。第</span><span>6</span><span
>个参数是最内层触发器或视图的名称，就是这个触发器或视图企图存取数据库。如果这个参数为</span><span
>NULL</span><span >，则说明这种存取的企图是直接由顶层的</span><span
>SQL</span><span >引发的。</span></p>
  <p><span >授权函数的返回值应该是</span><span
>SQLITE_OK</span><span >、</span><span
>SQLITE_DENY</span><span >或</span><span
>SQLITE_IGNORE</span><span >之一。前两个值的含义对所有事件都是确定的――接受或拒绝</span><span
>SQL</span><span >。</span><span>SQLITE_DENY</span><span
>将会取消整个</span><span>SQL</span><span
>语句的执行并生成一个错误。</span></p>
  <p><span>SQLITE_IGNORE</span><span style='font-family:
宋体'>的含义与事件有关。如果</span><span>SQL</span><span >语句是读或改记录，会在语句试图操作的每个字段上产生</span><span
>SQLITE_READ</span><span >或</span><span
>SQLITE_UPDATE</span><span >事件。在这种情况下，如果回叫函数返回</span><span
>SQLITE_IGNORE</span><span >，这些字段将从操作中被排除</span><span
>(</span><span >高：别的字段继续操作，这些字段就不操作了</span><span
>)</span><span >。具体说，试图读的返回</span><span
>NULL</span><span >，试图写的则什么也不做</span><span
>(silently fail)</span><span >。</span></p>
  <p><span >表</span><span>6-3 SQLite</span><span
>的授权事件</span></p>
  <table border=1 cellspacing=0 cellpadding=0>
    <tr>
      <td width=228 valign=top><p align=center style='text-align:center'><span
  >事件代码</span></p></td>
      <td width=156 valign=top><p align=center style='text-align:center'><span
  >参数</span><span>3</span></p></td>
      <td width=144 valign=top><p align=center style='text-align:center'><span
  >参数</span><span>4</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_CREATE_INDEX</span></p></td>
      <td width=156 valign=top><p><span>Index name</span></p></td>
      <td width=144 valign=top><p><span>Table name</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_CREATE_TABLE</span></p></td>
      <td width=156 valign=top><p><span>Table name</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_CREATE_TEMP_INDEX</span></p></td>
      <td width=156 valign=top><p><span>Index name</span></p></td>
      <td width=144 valign=top><p><span>Table name</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_CREATE_TEMP_TABLE</span></p></td>
      <td width=156 valign=top><p><span>Table name</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_CREATE_TEMP_TRIGGER</span></p></td>
      <td width=156 valign=top><p><span>Trigger name</span></p></td>
      <td width=144 valign=top><p><span>Table name</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_CREATE_TEMP_VIEW</span></p></td>
      <td width=156 valign=top><p><span>View name</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_CREATE_TRIGGER</span></p></td>
      <td width=156 valign=top><p><span>Trigger name</span></p></td>
      <td width=144 valign=top><p><span>Table name</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_CREATE_VIEW</span></p></td>
      <td width=156 valign=top><p><span>View name</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_DELETE</span></p></td>
      <td width=156 valign=top><p><span>Table name</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_DROP_INDEX</span></p></td>
      <td width=156 valign=top><p><span>Index name</span></p></td>
      <td width=144 valign=top><p><span>Table name</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_DROP_TABLE</span></p></td>
      <td width=156 valign=top><p><span>Table name</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_DROP_TEMP_INDEX</span></p></td>
      <td width=156 valign=top><p><span>Index name</span></p></td>
      <td width=144 valign=top><p><span>Table name</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_DROP_TEMP_TABLE</span></p></td>
      <td width=156 valign=top><p><span>Table name</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_DROP_TEMP_TRIGGER</span></p></td>
      <td width=156 valign=top><p><span>Trigger name</span></p></td>
      <td width=144 valign=top><p><span>Table name</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_DROP_TEMP_VIEW</span></p></td>
      <td width=156 valign=top><p><span>View name</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_DROP_TRIGGER</span></p></td>
      <td width=156 valign=top><p><span>Trigger name</span></p></td>
      <td width=144 valign=top><p><span>Table name</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_DROP_VIEW</span></p></td>
      <td width=156 valign=top><p><span>View name</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_INSERT</span></p></td>
      <td width=156 valign=top><p><span>Table name</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_PRAGMA</span></p></td>
      <td width=156 valign=top><p><span>Pragma name</span></p></td>
      <td width=144 valign=top><p><span>First argument or NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_READ</span></p></td>
      <td width=156 valign=top><p><span>Table name</span></p></td>
      <td width=144 valign=top><p><span>Column name</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_SELECT</span></p></td>
      <td width=156 valign=top><p><span>NULL</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_TRANSACTION</span></p></td>
      <td width=156 valign=top><p><span>NULL</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_UPDATE</span></p></td>
      <td width=156 valign=top><p><span>Table name</span></p></td>
      <td width=144 valign=top><p><span>Column name</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_ATTACH</span></p></td>
      <td width=156 valign=top><p><span>Filename</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
    <tr>
      <td width=228 valign=top><p><span>SQLITE_DETACH</span></p></td>
      <td width=156 valign=top><p><span>Database name</span></p></td>
      <td width=144 valign=top><p><span>NULL</span></p></td>
    </tr>
  </table>
  <p><span >下面例子说明授权函数的使用</span><span
>(</span><span >完整的程序在</span><span>authorizer.c</span><span
>中</span><span>)</span><span style='font-family:
宋体'>。</span></p>
  <p><span >这是一个很长的例子，会用授权函数对很多不同的数据库事件进行过滤，所以我们通过程序片段来进行说明。见列表</span><span
>6-10</span><span >。</span></p>
  <p><span >列表</span><span>6-10 </span><span
>授权函数示例</span></p>
  <p><span >授权函数的一般形式为：</span></p>
  <p><span>int auth( void* x, int type, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    const char* a, const char* b, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    const char* c, const char* d )</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char* operation =
    a;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; //printf(
    &quot;&nbsp;&nbsp;&nbsp; %s &quot;, event_description(type));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Filter for different
    database events </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; ** from
    SQLITE_TRANSACTION to SQLITE_INSERT, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; ** UPDATE, DELETE,
    ATTACH, etc. and either allow or deny </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; ** them.</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return SQLITE_OK; </span></p>
  <p><span>} </span></p>
  <p><span >授权函数做的第</span><span>1</span><span
>件事是：看看事务状态是否改变；如果改变，则输出一个信息：</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if((a != NULL)
    &amp;&amp; (type == SQLITE_TRANSACTION)) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    printf(&quot;: %s &Ecirc;&Acirc;&Icirc;&ntilde;&quot;, operation);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span >下一步是对引起</span><span>schema</span><span
>改变的事件进行过滤：</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; switch(type) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case SQLITE_CREATE_INDEX:</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case SQLITE_CREATE_TABLE:</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case
    SQLITE_CREATE_TRIGGER:</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case SQLITE_CREATE_VIEW:</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case SQLITE_DROP_INDEX:</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case SQLITE_DROP_TABLE:</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case SQLITE_DROP_TRIGGER:</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case SQLITE_DROP_VIEW:</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    printf(&quot;: Schema&cedil;&Auml;±&auml;&Aacute;&Euml;&iexcl;&pound;&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span >下一步是对读的企图进行检查，这种企图是基于字段的。这里，所有的读都被允许，除了</span><span
>z</span><span >字段。当要读</span><span>z</span><span
>字段时，函数返回</span><span>SQLITE_IGNORE</span><span
>，这将导致</span><span>SQLite</span><span
>在读这个字段时返回</span><span>NULL</span><span
>，从而有效地保护其数据。</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(type == SQLITE_READ)
    {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    printf(&quot;: Read of %s.%s &quot;, a, b);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* Block attempts to read column z */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    if(strcmp(b,&quot;z&quot;)==0) {</span></p>
  <p><span>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;-&gt;
    DENIED\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    return SQLITE_IGNORE;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span >下面是</span><span>INSERT</span><span
>和</span><span>UPDATE</span><span
>的过滤。所有的插入被允许。对</span><span>x</span><span
>字段的修改被拒绝。这样不会锁住</span><span>UPDATE</span><span
>的执行，而是简单地过滤掉对</span><span>x</span><span
>字段的修改企图。</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(type ==
    SQLITE_INSERT) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    printf(&quot;: &sup2;&aring;&Egrave;&euml;&frac14;&Ccedil;&Acirc;&frac14; into %s &quot;, a);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(type == SQLITE_UPDATE)
    {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    printf(&quot;: Update of %s.%s &quot;, a, b);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* Block updates of column x */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    if(strcmp(b,&quot;x&quot;)==0) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    printf(&quot;-&gt; DENIED\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    return SQLITE_IGNORE;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span >最后，对</span><span>DELETE</span><span
>、</span><span>ATTACH</span><span
>和</span><span>DETACH</span><span
>进行过滤，在遇到这些事件时只是简单地给出通知。</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(type ==
    SQLITE_DELETE) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    printf(&quot;: Delete from %s &quot;, a);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(type ==
    SQLITE_ATTACH) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    printf(&quot;: %s&quot;, a);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(type ==
    SQLITE_DETACH) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    printf(&quot;-&gt; %s&quot;, a);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span >下面是主程序，为了介绍的方便，也会分成多个片段。</span></p>
  <p><span>int main(int argc, char **argv)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 *db, *db2;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *zErr;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int rc;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /*
    -------------------------------------------------------------------------</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; **&nbsp;
    Setup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; ** -------------------------------------------------------------------------</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Connect to test.db */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc =
    sqlite3_open(&quot;test.db&quot;, &amp;db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(rc) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;Can't open database: %s\n&quot;, sqlite3_errmsg(db));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;exit(1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /*
    -------------------------------------------------------------------------</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; **&nbsp; Authorize and
    test</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; **
    -------------------------------------------------------------------------</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Register the
    authorizer function */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;
    sqlite3_set_authorizer(db, auth, NULL);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Test transactions
    events */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Starting transaction\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db,
    &quot;BEGIN&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Committing transaction\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db,
    &quot;COMMIT&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Starting transaction\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db,
    &quot;BEGIN&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Aborting transaction\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db,
    &quot;ROLLBACK&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; // Test table events</span></p>
  <p><span>&nbsp; &nbsp;&nbsp;printf(&quot;program :
    Creating table\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db,
    &quot;create table foo(x int, y int, z int)&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Inserting record\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db,
    &quot;insert into foo values (1,2,3)&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Selecting record (value for z should be NULL)\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print_sql_result(db,
    &quot;select * from foo&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Updating record (update of x should be denied)\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db,
    &quot;update foo set x=4, y=5, z=6&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Selecting record (notice x was not updated)\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print_sql_result(db,
    &quot;select * from foo&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Deleting record\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db,
    &quot;delete from foo&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Dropping table\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db,
    &quot;drop table foo&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>Several things are going on here. The
    program selects all records in the table, one of which is </span></p>
  <p><span>column z. We should see in the output that
    column z’s value is NULL. All other fields should </span></p>
  <p><span>contain data from the table. Next, the
    program attempts to update all fields, the most important </span></p>
  <p><span>of which is column x. The update should
    succeed, but the value in column x should be </span></p>
  <p><span>unchanged, as the authorizer denies it.
    This is confirmed on the following SELECT statement, </span></p>
  <p><span>which shows that all columns were updated
    except for column x, which is unchanged. The </span></p>
  <p><span>program then drops the foo table, which
    should issue a schema change notification from the </span></p>
  <p><span>previous filter. </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; // Test ATTACH/DETACH </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; // Connect to test2.db</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc =
    sqlite3_open(&quot;test2.db&quot;, &amp;db2);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(rc) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;Can't open database: %s\n&quot;, sqlite3_errmsg(db2));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_close(db2);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    exit(1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; // Drop table foo2 in test2 if exists </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db2,
    &quot;drop table foo2&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db2,
    &quot;create table foo2(x int, y int, z int)&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; // Attach database
    test2.db to test.db </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Attaching database test2.db\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db,
    &quot;attach 'test2.db' as test2&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; // Select record from
    test2.db foo2 in test.db </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Selecting record from attached database test2.db\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db,
    &quot;select * from foo2&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; printf(&quot;program :
    Detaching table\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_exec(db,
    &quot;detach test2&quot;, NULL, NULL, &amp;zErr);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /*
    -------------------------------------------------------------------------</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; **&nbsp; Cleanup</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; **
    -------------------------------------------------------------------------</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_close(db2);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return
    0;&nbsp;&nbsp;&nbsp; </span></p>
  <p><span>}</span></p>
  <h2><a name="_Toc245565860"><span style='font-family:黑体'>线程</span></a></h2>
  <p><span >如第</span><span>2</span><span
>章所述，</span><span>SQLite</span><span
>支持线程。在多线程环境下使用</span><span>SQLite</span><span
>时，有一些基本规则需要遵守。</span></p>
  <h3><a name="_Toc245565861"><span >共享缓冲区模式</span></a></h3>
  <p><span><img width=237 height=392
src="Definitive Guide/image012.jpg"></span></p>
  <p><span>Figure 6-3. The shared cache model </span></p>
  <h3><a name="_Toc245565862"><span >线程和内存管理</span></a></h3>
  <p><span >共享缓冲区模式的目录是为了节省内在，</span><span
>SQLite</span><span >中有几个函数是与线程和内存管理有关的。使用它们可以限制堆的尺寸或手工地发起内存清理。这些函数包括：</span></p>
  <p><span>void sqlite3_soft_heap_limit(int N); </span></p>
  <p><span>int sqlite3_release_memory(int N); </span></p>
  <p><span>void sqlite3_thread_cleanup(void); </span></p>
  <br
clear=all style='page-break-before:always'>
  <h1><a name="_Toc245565863"></a><a name="_Toc242291777"><span style='font-family:
宋体'>第</span><span>7</span></a><span >章</span><span
>&nbsp; </span><span >扩充</span><span
>C API</span></h1>
  <p><span >本章介绍</span><span>SQLite</span><span
>的新技巧。前一章涉及一般的数据库操作，本章将开始创新。扩充</span><span>API</span><span
>提供</span><span>3</span><span
>种基本方法来扩展</span><span>(</span><span
>或说定制</span><span>)SQLite</span><span
>，包括：创建用户自定义函数、聚合和排序序列。</span></p>
  <p><span >用户自定义函数是编写用于特定应用的</span><span
>SQL</span><span >函数。一旦注册，就可以在</span><span
>SQL</span><span >中被调用。</span></p>
  <p><span >本章将涉及所有这</span><span
>3</span><span >个用户定义的扩展工具及与之相关的</span><span
>API</span><span >函数。你会看到，当与其它工具，如触发器和冲突解决等结合在一起时，用户定义的扩充</span><span
>API</span><span >是强有力的，并能为</span><span
>SQLite</span><span >创造非凡特色。</span></p>
  <p><span >空注：本章内容对编程还是很有用的，但我对这部分内容只是略做浏览。关心这部分内容的兄弟还是得自己看原文。</span></p>
  <h2><a name="_Toc245565864"><span>API</span></a></h2>
  <p><span >用户自定义聚合、函数和排序法的生命同期是基于连接的。它们不存储在数据库中。有时你可能会把它们当成存储过程看待，而忘记了它们是在数据库之外的。它们存在于程序库</span><span
>(librarie)</span><span >中，其生命周期严格地限制在你的程序之内。</span><span
>I </span></p>
  <h3><a name="_Toc245565865"><span >注册函数</span></a></h3>
  <h3><a name="_Toc245565866"><span >步进函数</span></a></h3>
  <p><span >自定义函数和聚合的步进函数是一样的，可如下定义：</span></p>
  <p><span>void fn(sqlite3_context* ctx, int nargs,
    sqlite3_value** values) </span></p>
  <h3><a name="_Toc245565867"><span >返回值</span></a></h3>
  <h2><a name="_Toc245565868"><span style='font-family:黑体'>函数</span></a></h2>
  <h3><a name="_Toc245565869"><span >返回值</span></a></h3>
  <h3><a name="_Toc245565870"><span >一个完整的例子</span></a></h3>
  <p><span>Listing 7-2. The main Function </span></p>
  <p><span>int main(int argc, char **argv)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int rc;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 *db;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char* sql;</span></p>
  <p><span>&nbsp; &nbsp;&nbsp;sqlite3_open(&quot;test.db&quot;,
    &amp;db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_create_function(
    db, &quot;function&quot;, -1, SQLITE_UTF8, NULL,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    function, NULL, NULL);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Turn on SQL logging
    */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; //log_sql(db, 1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Call function with
    one text argument. */</span></p>
  <p><span>&nbsp; &nbsp;&nbsp;execute(db, &quot;select
    function(1)&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Call function with
    several arguments of various types. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; execute(db, &quot;select
    function(1, 2.71828)&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Call function with
    variable arguments, the first argument’s value</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; ** being 'fail'. This
    will trigger the function to call </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; **
    sqlite3_result_error(). */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; execute(db, &quot;select
    function('fail', 1, 2.71828, 'three', X'0004', NULL)&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Done */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return
    0;&nbsp;&nbsp;&nbsp; </span></p>
  <p><span>}</span></p>
  <p><span>Listing 7-3. A Vanilla User-Defined
    Function </span></p>
  <p><span>void function(sqlite3_context* ctx, int
    nargs, sqlite3_value** values)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int i; const char *msg;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;function() : Called with %i arguments\n&quot;, nargs);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; for(i=0; i &lt; nargs;
    i++) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf( stdout, &quot;&nbsp;&nbsp;&nbsp; arg %i: value=%-7s type=%i\n&quot;,
    i, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_value_text(values[i]), </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_value_type(values[i]));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(strcmp((const char
    *)sqlite3_value_text(values[0]), &quot;fail&quot;) == 0) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    msg = &quot;function() : Failing because you told me to.&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;sqlite3_result_error(ctx,
    msg, strlen(msg));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stdout, &quot;\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    return;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_result_int(ctx,
    0);</span></p>
  <p><span>}</span></p>
  <h3><a name="_Toc245565871"><span >一个实际的应用程序</span></a></h3>
  <h2><a name="_Toc245565872"><span style='font-family:黑体'>聚合</span></a></h2>
  <p><span><img width=231 height=312
src="Definitive Guide/image013.jpg"></span></p>
  <p><span>Figure 7-1. Query processing with
    aggregates </span></p>
  <h3><a name="_Toc245565873"><span >一个实际的例子</span></a></h3>
  <p><span>Listing 7-9. The sum_int() Test Program </span></p>
  <p><span>int main(int argc, char **argv)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int rc;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 *db;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *sql;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc =
    sqlite3_open(&quot;test.db&quot;, &amp;db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(rc) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    print_error(db, &quot;Can't open database&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    exit(1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Create aggregate
    table, add records. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; setup(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Register aggregate.
    */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;Registering aggregate sum_int()\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; log_sql(db, 1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_create_function(
    db, &quot;sum_int&quot;, 1, SQLITE_UTF8, db,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    NULL, step, finalize);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Test it. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;\nRunning query: \n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;select
    sum_int(id) from aggregate&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print_sql_result(db,
    sql);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Done. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return
    0;&nbsp;&nbsp;&nbsp; </span></p>
  <p><span>}</span></p>
  <h4><span style='font-family:黑体'>步进函数</span></h4>
  <p><span>The step() function is shown in Listing
    7-10. </span></p>
  <p><span>Listing 7-10. The sum_int() Step Function </span></p>
  <p><span>void step(sqlite3_context* ctx, int ncols,
    sqlite3_value** values)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sum* s;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int x;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; s =
    (sum*)sqlite3_aggregate_context(ctx, sizeof(sum));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;
    if(sqlite3_aggregate_count(ctx) == 1) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    s-&gt;x = 0;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; x =
    sqlite3_value_int(values[0]);;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; s-&gt;x += x;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;step()&nbsp;&nbsp;&nbsp;&nbsp; : value=%i, total=%i\n&quot;, x, s-&gt;x);</span></p>
  <p><span>}</span></p>
  <p><span>The value sum is a struct that is specific
    to this example and is defined as follows: </span></p>
  <p><span>typedef struct { </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int x; </span></p>
  <p><span>} sum; </span></p>
  <h4><span style='font-family:黑体'>聚合的</span><span>Context </span></h4>
  <h4><span>Finalize</span><span style='font-family:黑体'>函数</span></h4>
  <p><span>Listing 7-11. The sum_int() Finalize
    Function </span></p>
  <p><span>void finalize(sqlite3_context* ctx)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sum* s;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; s =
    (sum*)sqlite3_aggregate_context(ctx, sizeof(sum));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_result_int(ctx,
    s-&gt;x);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;finalize() : total=%i\n\n&quot;, s-&gt;x);</span></p>
  <p><span>}</span></p>
  <h2><a name="_Toc245565874"><span style='font-family:黑体'>排序法</span></a></h2>
  <h3><a name="_Toc245565875"><span >排序法定义</span></a></h3>
  <h4><span style='font-family:黑体'>排序法如何工作</span></h4>
  <h4><span style='font-family:黑体'>标准的排序法类型</span></h4>
  <h3><a name="_Toc245565876"><span >一个简单的例子</span></a></h3>
  <h4><span>Compare</span><span style='font-family:黑体'>函数</span></h4>
  <p><span>Listing 7-12. The Political Collation
    Function </span></p>
  <p><span>int political_collation( void* data, int
    l1, const void* s1, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    int l2, const void* s2 )</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int value, opinion;
    struct tm* t; time_t rt;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Get the unpolitical
    value */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value
    = strcmp(s1,s2);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Get the date and time
    */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; time(&amp;rt);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; t = localtime(&amp;rt);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Form an opinion */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(t-&gt;tm_wday)
    {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case 0: /* Monday yes&nbsp;&nbsp;&nbsp; */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opinion
    = value;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    break;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case 1: /* Tueday no&nbsp;&nbsp;&nbsp;&nbsp; */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    opinion = -value;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    break;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case 2: /* Wednesday bigger is better */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    opinion = l1 &gt;= l2 ? -1:1;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    break;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case 3: /* Thursday strongly no&nbsp;&nbsp; */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    opinion = -100;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    break;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case 4: /* Friday strongly yes&nbsp;&nbsp;&nbsp; */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    opinion = 100;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    break;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    case 5: /* Saturday golf, everything's the same */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    opinion = 0;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    &nbsp;break;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    default: /* Sunday - Meet the Press, opinion changes </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    by the hour */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    opinion = 2*(int)sin(t-&gt;tm_hour*180);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Now change it on a
    whim */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; opinion =
    rand()-(RAND_MAX/2) &gt; 0 ? -1:1;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return opinion;</span></p>
  <p><span>}</span></p>
  <h4><span style='font-family:黑体'>测试程序</span></h4>
  <p><span>Listing 7-13. The Political Collation Test
    Program </span></p>
  <p><span>int main(int argc, char **argv)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int rc;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 *db;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *sql;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* For forming more
    consistent political opinions. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;
    srand((unsigned)time(NULL));</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc = sqlite3_open(&quot;test.db&quot;,
    &amp;db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(rc) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    print_error(db, &quot;Can't open database&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    exit(1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Create issues table,
    add records. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; setup(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Register collating
    sequence. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout, &quot;1.
    Register political collating sequence\n\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;
    sqlite3_create_collation( db, &quot;POLITICAL&quot;, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    SQLITE_UTF8, db,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    political_collation );</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Turn SQL logging on.
    */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; log_sql(db, 1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Test default
    collation. */</span></p>
  <p><span>&nbsp;&nbsp; &nbsp;fprintf(stdout, &quot;2.
    Select records using default collation.\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;select *
    from issues order by issue&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print_sql_result(db,
    sql);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Test Oracle
    collation. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;\nSelect records using political collation. \n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;select *
    from issues order by issue collate POLITICAL&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print_sql_result(db,
    sql);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Done. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return
    0;&nbsp;&nbsp;&nbsp; </span></p>
  <p><span lang=FR>}</span></p>
  <h3><a name="_Toc245565877"><span >按需排序</span></a><span
lang=FR>(Collation on Demand)</span></h3>
  <p><span>Listing 7-14. Collation Registration
    Function </span></p>
  <p><span>void crf( void* data, sqlite3* db, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int eTextRep, const
    char* cname)</span></p>
  <p><span>{ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;
    if(strcmp(collation_name, &quot;POLITICAL&quot;) == 0) { </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* Political collation has not been registered and is now needed */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_create_collation( db, &quot;POLITICAL&quot;,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    SQLITE_UTF8, db, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    political_collation ); </span></p>
  <p><span>&nbsp;&nbsp;&nbsp; } else { </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* Punt: Use some default comparison function this collation. */ </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    sqlite3_create_collation( db, collation_name,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    SQLITE_UTF8, db, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    default_collation );</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>}</span></p>
  <h3><a name="_Toc245565878"><span >一个实际的应用程序</span></a></h3>
  <h4><span style='font-family:黑体'>比较函数</span></h4>
  <p><span>Listing 7-15. Oracle Date Collation
    Function </span></p>
  <p><span>int oracle_date_collation( void* data, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    int len1, const void* arg1, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    int len2, const void* arg2 )</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int len;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; date d1;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; date d2;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char zDate1[25];</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char zDate2[25];</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Copy date 1 */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(len1 &gt; 24) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    len = 24;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; } else {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    len = len1;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; strncpy(&amp;zDate1[0],
    arg1, len);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; zDate1[len] = '\0';</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Copy date 2 */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(len2 &gt; 24) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    len = 24;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; } else {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    len = len2;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; strncpy(&amp;zDate2[0],
    arg2, len);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; zDate2[len] = '\0';</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Convert dates to date
    struct */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;
    oracle_date_str_to_struct(zDate1, &amp;d1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;
    oracle_date_str_to_struct(zDate2, &amp;d2);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;collate_fn() : date1=%s, date2=%s\n&quot;, zDate1, zDate2);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Compare structs */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(d1.year &lt; d2.year)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    return -1;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; else if(d1.year &gt;
    d2.year)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    return 1;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* If this far, years
    are equal. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(d1.month &lt;
    d2.month)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    return -1;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; else if(d1.month &gt;
    d2.month)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    return 1;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* If this far, months
    are equal. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(d1.day &lt; d2.day)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    return -1;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; else if(d1.day &gt;
    d2.day)</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    return 1;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* If this far, dates
    are equal. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return 0;</span></p>
  <p><span>}</span></p>
  <h4><span style='font-family:黑体'>日期解析</span></h4>
  <p><span>Listing 7-16. The Oracle Date Parsing
    Function </span></p>
  <p><span>int oracle_date_str_to_struct(const char*
    value, date* d)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char* date, *tmp;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *start, *end,
    zDay[3], zMonth[4], zYear[3];</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; date = get_date(value);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(date == NULL) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    fprintf(stderr, &quot;Invalid date\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    return -1;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Find first '-' */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; start =
    strchr(date,'-');</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Find last '-' */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; end&nbsp;&nbsp; =
    strchr(start+1,'-');</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Extract day part,
    convert to int*/</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; strncpy(zDay, date,2);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; zDay[2] = '\0';</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; d-&gt;day = atoi(zDay);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Extract month part,
    convert to int*/</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; strncpy(zMonth,
    start+1,3);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; zMonth[3] = 0;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; tmp = uppercase(zMonth);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; d-&gt;month =
    month_num(tmp);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; free((void*)tmp);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Extract year part,
    convert to int*/</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; strncpy(zYear, end+1,2);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; zYear[2] = '\0';</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; d-&gt;year =
    atoi(zYear);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; free((void*)date);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return 0;</span></p>
  <p><span>}</span></p>
  <p><span>Listing 7-17. The get_date() Function </span></p>
  <p><span>#define ORACLE_DATE_REGEX &quot;[0-9]{1,2}-[a-zA-Z]{3,3}-[0-9]{2,2}&quot;; </span></p>
  <p><span>const char* get_date(const char* value)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; pcre *re;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; const char *error,
    *pattern;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int erroffset;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int ovector[3];</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int value_length;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int rc,
    substring_length;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char* result,
    *substring_start;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; pattern =
    ORACLE_DATE_REGEX;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; re = pcre_compile(</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    pattern,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* the pattern */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* default options */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    &amp;error,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* for error message */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    &amp;erroffset,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
    for error offset */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* use default character tables */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Compilation failed */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if (re == NULL) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    return NULL;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; value_length =
    (int)strlen(value);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc = pcre_exec(</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    re,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* the compiled
    pattern */</span></p>
  <p><span>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* no extra data - we didn't study the pattern */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    value,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* the value string */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    value_length, /* the length of the value */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* start
    at offset 0 in the value */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* default
    options */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    ovector,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* output vector for substring
    information */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* number of
    elements in the output vector */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if (rc &lt; 0) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /* Match error */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    return NULL;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Match succeded */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; substring_start =
    (char*)value + ovector[0];</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; substring_length =
    ovector[1] - ovector[0];</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;
    //printf(&quot;%.*s\n&quot;, substring_length, substring_start);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; result =
    malloc(substring_length+1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; strncpy(result,
    substring_start, substring_length);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; result[substring_length]
    = '\0';</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return result;</span></p>
  <p><span>}</span></p>
  <h4><span style='font-family:黑体'>测试程序</span></h4>
  <p><span>All three of the above functions work
    together to collate Oracle dates in chronological order. Our example program is
    shown in Listing 7-18. </span></p>
  <p><span>Listing 7-18. The Oracle Collation Test
    Program </span></p>
  <p><span>int main(int argc, char **argv)</span></p>
  <p><span>{</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; int rc;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3 *db;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; char *sql;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; rc =
    sqlite3_open(&quot;test.db&quot;, &amp;db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; if(rc) {</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    print_error(db, &quot;Can't open database&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    exit(1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; }</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Install oracle
    related date functions. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; install_date_functions(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Register collating
    sequence. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;Registering collation sequence oracle_date\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;
    sqlite3_create_collation( db, &quot;oracle_date&quot;, </span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    SQLITE_UTF8, db,</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    oracle_date_collation );</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Create dates table,
    add records. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; setup(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Install date */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp;
    install_date_triggers(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Turn SQL logging on.
    */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; log_sql(db, 1);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Test default
    collation. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;Select records. Use default collation.\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;select *
    from dates order by date&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print_sql_result(db,
    sql);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Test Oracle
    collation. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;\nSelect records. Use Oracle data collation. \n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;select *
    from dates order by date collate oracle_date&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print_sql_result(db,
    sql);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Get ISO Date from
    Oracle date. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;\nConvert Oracle date to ISO format.\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;select
    iso_from_oradate('01-APR-05') as 'ISO Date'&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print_sql_result(db, sql);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; </span><span lang=FR>/*
    Validate Oracle date. */</span></p>
  <p><span lang=FR>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;\nValidate Oracle format. </span><span>Should fail.\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;select
    validate_oradate('01-NOT-2005')&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; execute(db, sql);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Test Oracle date
    triggers. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;\nTest Oracle insert trigger -- should fail.\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;insert into
    dates (date) values ('01-NOT-2005')&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; execute(db, sql);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; fprintf(stdout,
    &quot;\nTest Oracle update trigger -- should succeed.\n&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sql = &quot;update dates
    set date='01-JAN-2005'&quot;;</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; execute(db, sql);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; print_sql_result(db,
    &quot;select * from dates&quot;);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; /* Done. */</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; sqlite3_close(db);</span></p>
  <p><span>&nbsp;&nbsp;&nbsp; return
    0;&nbsp;&nbsp;&nbsp; </span></p>
  <p><span>}</span></p>
  <h4><span style='font-family:黑体'>运行结果</span></h4>
  <p><span >略。</span></p>
  <br
clear=all style='page-break-before:always'>
  <h1><a name="_Toc245565879"></a><a name="_Toc242291782"><span style='font-family:
宋体'>第</span><span>8</span></a><span >章</span><span
>&nbsp; </span><span >语言扩</span><span
>展</span></h1>
  <p><span>SQLite</span><span >本身是用</span><span
>C</span><span >语言编写的，它有自己的</span><span
>C API</span><span >。但是，开源社区中提供了多种</span><span
>SQLite</span><span >的扩展，使你在以在其它的编程语言或程序库中存取</span><span
>SQLite</span><span >数据库，如</span><span
>Per</span><span >、</span><span>Python</span><span
>、</span><span>Ruby</span><span
>、</span><span>Java</span><span
>、</span><span>Qt</span><span
>和</span><span>ODBC</span><span
>。在很多情况下，每种编程语言可以有几个扩展可供选择，这些扩展由不同的人为不同的需求而编写。</span></p>
  <p><span >空注：我只在其它地方看了</span><span
>Delphi</span><span >的扩展，本章基本没看。</span></p>
  <br
clear=all style='page-break-before:always'>
  <h1><a name="_Toc245565880"></a><a name="_Toc242291785"><span style='font-family:
宋体'>第</span><span>9</span></a><span >章</span><span
>&nbsp; SQLite</span><span >内核</span></h1>
  <p><span >本章是</span><span>SQLite</span><span
>各主要子系统的一个概览。它的灵感来自一次会议上</span><span>Richard
    Hipp</span><span >对</span><span>SQLite</span><span
>所做的介绍。即使你没有看过</span><span>SQLite</span><span
>的源代码，你也会发现这些内容是如此的有趣。即使</span><span>SQLite</span><span
>还在发展，但本章所介绍的概念一时不会改变。</span></p>
  <p><span >现在，你应该已经熟悉</span><span
>SQLite</span><span >的主要组件了。第</span><span
>1</span><span >章有一个概述，第</span><span
>5</span><span >章介绍了</span><span>B-tree</span><span
>和</span><span>pager</span><span
>，这些概念本章就不再介绍了。本章会从虚拟机入手，它是</span><span>SQLite</span><span
>的心脏；然后是存储层；最后是编译器，它可能是系统中最复杂的部分。</span></p>
  <h2><a name="_Toc245565881"><span style='font-family:黑体'>虚拟数据库引擎</span><span
>(VDBE)</span></a></h2>
  <p><span>VDBE</span><span >是</span><span
>SQLite</span><span >的核心，它的上层模块和下层模块本质上都是为它服务的，它的实现位于</span><span
>vbde.c</span><span >、</span><span>vdbe.h</span><span
>、</span><span>vdbeapi.c</span><span
>、</span><span>vdbeInt.h</span><span
>和</span><span>vdbemem.c</span><span
>等几个文件中。如第</span><span>5</span><span
>章所述，一个语句</span><span>(statement)</span><span
>会编译为一个完整的</span><span>VDBE</span><span
>程序，执行一条单独的</span><span>SQL</span><span
>命令。它通过底层的基础设施</span><span>B-tree</span><span
>执行由编译器</span><span>(Compiler)</span><span
>生成的字节代码，这种字节代码程序语言是为了进行查询、读取和修改数据库而专门设计的。</span></p>
  <p><span >字节代码在内存中被封装成</span><span
>sqlite3_stmt</span><span >对象</span><span
>(</span><span >内部叫做</span><span>Vdbe</span><span
>，见</span><span>vdbeInt.h)</span><span
>，</span><span>Vdbe(</span><span
>或者说</span><span>statement)</span><span
>包含执行程序所需要的一切，包括：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>VDBE</span><span >程序</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >程序计数器</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >结果字段的名称和类型</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >参数的绑定值</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >运行栈和固定数量的编号的内在单元</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span >其它的运行时状态信息，如</span><span>B-tree</span><span
>游标</span></p>
  <p><span>VDBE</span><span >是一个虚拟机，它的字节代码指令和汇编程序十分类似，每一条指令由操作码和三个操作数构成：</span><span
>&lt;opcode, P1, P2, P3&gt;</span><span >。</span><span
>Opcode</span><span >为一定功能的操作码，为了理解，可以看成一个函数。</span><span
>p1</span><span >是</span><span>32</span><span
>位的有符号整数，</span><span>p2</span><span
>是</span><span>31</span><span
>位的无符号整数，它通常是跳转</span><span>(jump)</span><span
>指令的目标地址</span><span>(destination)</span><span
>，当然还有其它用途；</span><span>p3</span><span
>为一个以</span><span>null</span><span
>结尾的字符串或者其它结构体的指针。目前</span><span>SQLite</span><span
>中有</span><span>128</span><span
>个操作码。和</span><span>C API</span><span
>不同的是，</span><span>VDBE</span><span
>操作码经常变化，所以不应该用字节码编写自己的程序。</span></p>
  <p><span >下面的几个</span><span>C
    API</span><span >直接和</span><span>VDBE</span><span
>交互：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3_bind_xxx() functions </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3_step() </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3_reset() </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3_column_xxx() functions </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3_finalize() </span></p>
  <p><span >一般情况下，所有的</span><span
>API</span><span >都是用来执行一个查询并在</span><span
>VDBE</span><span >相关的结果集中步进操作。它们有一个共同点：都以一个语句句柄做参数。这是因为它们都需要句柄中的</span><span
>VDBE</span><span >代码或相关资源来完成任务。注意：</span><span
>sqlite3_prepare()</span><span >工作于开始阶段，用于产生</span><span
>VDBE</span><span >代码，它不参与执行。</span></p>
  <p><span >所有</span><span>SQL</span><span
>命令的</span><span>VDBE</span><span
>程序都可以通过</span><span>EXPLAIN</span><span
>命令得到，如：</span></p>
  <p><span>sqlite&gt; .m col </span></p>
  <p><span>sqlite&gt; .h on </span></p>
  <p><span>sqlite&gt; .w 4 15 3 3 15</span></p>
  <p><span>sqlite&gt; explain select * from episodes; </span></p>
  <p><span>addr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; opcode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p1&nbsp;&nbsp;&nbsp; p2&nbsp;&nbsp;&nbsp; p3 </span></p>
  <p><span>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Goto
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 12 </span></p>
  <p><span>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span>2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OpenRead
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 &nbsp;&nbsp;&nbsp; 2
    &nbsp;&nbsp;&nbsp; # episodes </span></p>
  <p><span>3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetNumColumns
    &nbsp; 0 &nbsp;&nbsp;&nbsp; 3 </span></p>
  <p><span>4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rewind
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 10 </span></p>
  <p><span>5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Recno
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span>6 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Column
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 1 </span></p>
  <p><span>7 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Column
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 2 </span></p>
  <p><span>8 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Callback&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3
    &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span>9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 5 </span></p>
  <p><span>10 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Close
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span>11 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Halt
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span>12 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Transaction
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span>13 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VerifyCookie
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 &nbsp;&nbsp;&nbsp; 10 </span></p>
  <p><span>14 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Goto
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 1 </span></p>
  <p><span>15 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Noop
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span >上面使用了</span><span>4</span><span
>条命令，前面的命令用于调试和格式化。另外，我在编译</span><span>SQLite</span><span
>时使用了</span><span>SQLITE_DEBUG</span><span
>选项，这个选择可以提供运行栈更多的信息，比如包含在</span><span>p3</span><span
>里面的表名。</span></p>
  <p><span >空注：当前版本的</span><span
>SQLite(3.6.18)</span><span
>确实有较大变化，现在执行</span><span>EXPLAIN</span><span
>命令的结果如下。</span></p>
  <p><span lang=FR >addr&nbsp;
    opcode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    p1&nbsp;&nbsp; p2&nbsp;&nbsp; p3&nbsp;&nbsp;&nbsp;&nbsp;
    p4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p5&nbsp;&nbsp;&nbsp;
    comment</span></p>
  <p><span  >----&nbsp;
    ---------------&nbsp; ---&nbsp; ---&nbsp; -----&nbsp; ----------&nbsp;
    ----&nbsp; ----------</span></p>
  <p><span  >0&nbsp;&nbsp;&nbsp;&nbsp;
    Trace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    &nbsp;00</span></p>
  <p><span  >1&nbsp;&nbsp;&nbsp;&nbsp;
    Goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span  >2&nbsp;&nbsp;&nbsp;&nbsp;
    OpenRead&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    2&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00</span></p>
  <p><span  >3&nbsp;&nbsp;&nbsp;&nbsp;
    Rewind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span  >4&nbsp;&nbsp;&nbsp;&nbsp;
    Rowid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span  >5&nbsp;&nbsp;&nbsp;&nbsp;
    Column&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; &nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span  >6&nbsp;&nbsp;&nbsp;&nbsp;
    Column&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;
    3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span  >7&nbsp;&nbsp;&nbsp;&nbsp;
    ResultRow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
    3&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span  >8&nbsp;&nbsp;&nbsp;&nbsp;
    Next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    01</span></p>
  <p><span  >9&nbsp;&nbsp;&nbsp;&nbsp;
    Close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span  >10&nbsp;&nbsp;&nbsp;
    Halt&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span  >11&nbsp;&nbsp;&nbsp;
    Transaction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span  >12&nbsp;&nbsp;&nbsp;
    VerifyCookie&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 40&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span  >13&nbsp;&nbsp;&nbsp;
    TableLock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
    2&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; episodes&nbsp;&nbsp;&nbsp;
    00</span></p>
  <p><span  >14&nbsp;&nbsp;&nbsp;
    Goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;
    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp;00</span></p>
  <p><span >空注：有关</span><span>VDBE</span><span
>的最详细参考在</span><span>vbde.c</span><span
>中，也可以参考</span><span>SQLite</span><span
>网站提供的文档</span><span>http://www.sqlite.org/opcode.html</span><span
>。</span></p>
  <p><span >空注：后面的内容还按原文翻译。</span></p>
  <h3><a name="_Toc245565882"><span >栈</span><span
>(Stack)</span></a></h3>
  <p><span >一个</span><span>VDBE</span><span
>程序通常由几个完成特定任务的段</span><span>(section)</span><span
>构成，每一个段中都有一些操作栈的指令。这么做是因为不同的指令有不同数量的参数，有些指令只有一个参数；有些指令没有参数；有些指令有好几个参数，这时三个操作数就不够了。</span></p>
  <p><span >考虑到这些情况，指令采用栈来传递参数。而这些指令本身不会做这些工作，所以在它们之前需要其它一些指令的帮助，以取得需要的参数。</span><span
>VDBE</span><span >把计算的中间结果保存到内存单元</span><span
>(memory cell)</span><span >中，其实堆栈和内存单元都基于</span><span
>Mem</span><span >结构</span><span>(</span><span
>见</span><span>vdbeInt.h)</span><span
>。</span></p>
  <h3><a name="_Toc245565883"><span >程序体</span></a></h3>
  <p><span >让我们来看前面打开</span><span
>episodes</span><span >表的例子。它的第一个段主要包括指令</span><span
>1~3</span><span >。</span></p>
  <p><span >第一条指令</span><span>(Integer)</span><span
>是为第二条指令作准备的，也就是把第二条指令执行需要的参数压入堆栈，</span><span
>OpenRead</span><span >从堆栈中取出参数值然后执行。</span></p>
  <p><span>SQLite</span><span >可以通过</span><span
>ATTACH</span><span >命令在一个连接中打开多个数据库文件，每当</span><span
>SQLite</span><span >打开一个数据库，它就为之赋一个索引号</span><span
>(index)</span><span >，主数据库的索引为</span><span
>0</span><span >，附加的第一个数据库为</span><span
>1</span><span >，依次类推。</span><span>Integer</span><span
>指令将数据库索引的值压入栈</span><span>(</span><span
>本例为</span><span>0</span><span
>，代表主数据库</span><span>)</span><span
>，而</span><span>OpenRead</span><span
>从中取出值，并决定操作哪个数据库。它用</span><span>P2</span><span
>来确定需要打开表的根页</span><span>(root page)</span><span
>。然后它打开一个指定数据库中指定表的</span><span>B-tree</span><span
>游标。所有这些在</span><span>VDBE</span><span
>代码文档中都有解释，例如，</span><span>OpenRead</span><span
>命令在</span><span>SQLite</span><span
>文档中的解释如下：</span></p>
  <p><span >为数据库表打开一个只读游标，这个表的根页在数据库文件的</span><span
>P2</span><span >处。数据库文件由栈顶的一个整数指定。</span><span
>0</span><span >表示主数据库，</span><span>1</span><span
>表示用于存放临时表的数据库。新打开游标的标识符在</span><span>P1</span><span
>中。</span><span>P1</span><span
>的值不必是相邻的，但应该是一个小整数。如果其值为负，表示错误。</span><span>If
    P2==0 then take the root page number from off of the stack. </span></p>
  <p><span >只要有游标打开，就会有一个读锁加载到数据库上。如果数据库本来是未加锁的，此命令的部分工作包括获得一个读锁。读锁允许其它进程读数据库，但是禁止任何进程改数据库。读锁在所有游标都关闭时释放。如果此指令在申请读锁时失败，程序结束并返回</span><span
>SQLITE_BUSY</span><span >错误码。</span></p>
  <p><span>P3</span><span
>的值是指向一个结构的指针，该结构定义索引的内容和排序序列的关键信息。当不指向索引时，</span><span
>P3</span><span >的内容为空。</span></p>
  <p><span >这个关于</span><span>OpenRead</span><span
>的文档与其它指令的文档一样，可以直接在源程序文件中找到，特别是</span><span>vdbe.c</span><span
>中。</span></p>
  <p><span >最终，</span><span>SetNumColumns</span><span
>指令设置游标需要处理的列的数量，这是由所要处理的表包含的列数决定的。</span><span
>P1</span><span >为游标的索引</span><span>(</span><span
>这里为</span><span>0</span><span
>，是刚刚打开的游标的索引号</span><span>)</span><span
>。</span><span>P2</span><span
>为列的数目，</span><span>episodes</span><span
>表有三列。</span></p>
  <p><span >继续本例，</span><span>Rewind</span><span
>指令将游标设置到表的开始，它会检查表是否为空</span><span>(</span><span
>“空”即没有记录</span><span>)</span><span
>。如果没有记录，它会导致指令指针跳转到</span><span>P2</span><span
>指定的指令处。此处</span><span>P2</span><span
>为</span><span>10</span><span
>，即</span><span>Close</span><span
>指令。一旦</span><span>Rewind</span><span
>设置游标，接下来就会执行下一段</span><span>(</span><span
>指令</span><span>5~9)</span><span
>的几条指令。它们的主要功能是遍历结果集，</span><span>Recno</span><span
>把由游标</span><span>P1</span><span
>指定的记录的关键字段值压入堆栈。</span><span>Column</span><span
>指令从由</span><span>P1</span><span
>指定的游标，</span><span>P2</span><span
>指定的列取值。</span><span>5,6,7</span><span
>三条指令分别把</span><span>id(primary key)</span><span
>、</span><span>season</span><span
>和</span><span>name</span><span
>字段</span><span>(</span><span
>游标</span><span>0</span><span
>所指明的表</span><span>episodes</span><span
>的全部</span><span>3</span><span
>个字段</span><span>)</span><span
>的值压入栈。接下来，</span><span>Callback</span><span
>指令从栈中取出三个值</span><span>(</span><span
>由</span><span>P1</span><span
>指定</span><span>)</span><span
>，然后形成一个记录数组，存储在内存单元</span><span> (memory
    cell) </span><span >中。然后，</span><span>Callback</span><span
>会挂起</span><span>VDBE</span><span
>的执行，把控制权交给</span><span>sqlite3_step()</span><span
>，该函数将返回</span><span>SQLITE_ROW</span><span
>。</span></p>
  <p><span><img width=497 height=237
src="Definitive Guide/image014.jpg"></span></p>
  <p><span >图</span><span>9-1 VDBE</span><span
>的步骤：</span><span>Open</span><span
>和</span><span>Read</span></p>
  <p><span >一旦</span><span>VDBE</span><span
>创建了记录结构</span><span>(</span><span
>该结构同样关联于语句</span><span>(statement)</span><span
>句柄</span><span>)</span><span
>，程序就可以通过</span><span>sqlite3_column_xxx() </span><span
>函数从记录结构内取出字段值。当下次调用</span><span>sqlite3_step()</span><span
>时，指令指针会指向</span><span>Next</span><span
>指令。</span><span>Next</span><span
>指令会把游标移向表的下一行，如果有其它的记录，它会跳到由</span><span>P2</span><span
>指定的指令，在这里为指令</span><span>5(Recno</span><span
>指令</span><span>)</span><span
>，创建一个新的记录结构，进入下一次循环。如果已经没有其它记录可读，</span><span
>Next</span><span >不跳转，而是执行下一条指令，这里是</span><span
>Close</span><span >指令。</span><span>Close</span><span
>指令会关闭游标，然后执行</span><span>Halt</span><span
>指令，结束</span><span>VDBE</span><span
>程序，并且</span><span>sqlite3_step()</span><span
>函数会返回</span><span>SQLITE_DONE</span><span
>。</span></p>
  <h3><a name="_Toc245565884"><span >程序开始与停止</span></a></h3>
  <p><span >前面介绍了程序的核心部分，现在来看看其余的指令，这些指令与启动和初始化有关，见图</span><span
>9-2</span><span >。第一条指令是</span><span
>Goto</span><span >指令，它是一条跳转指令，跳到</span><span
>P2</span><span >处，本例中是跳到第</span><span
>12</span><span >条指令。</span></p>
  <p><span >指令</span><span>12</span><span
>是</span><span>Transaction</span><span
>，它开始一个新的事务；然后执行下一条指令</span><span>VerifyCookie</span><span
>，它的主要功能是确定</span><span>VDBE</span><span
>程序编译后，数据库</span><span>schema</span><span
>是否改变</span><span>(</span><span
>即是否进行过更新操作</span><span>)</span><span
>。这在</span><span>SQLite</span><span
>中是一个很重要的概念，在</span><span>SQL</span><span
>被</span><span>sqlite3_prepare()</span><span
>编译成</span><span>VDBE</span><span
>代码至程序调用</span><span>sqlite3_step()</span><span
>执行字节码的这段时间内，另一个</span><span>SQL</span><span
>命令可能会改变数据库模式</span><span>(</span><span
>比如</span><span>ALTER TABLE</span><span
>、</span><span>DROP TABLE</span><span
>或</span><span>CREATE TABLE)</span><span
>。一旦发生这种情况，</span><span>schema</span><span
>版本就会改变，之前编译的语句</span><span>(statement)</span><span
>就会变得无效。当前的数据库</span><span>schema</span><span
>信息记录在数据库文件的根页中。类似地，每个语句都有一份用于比较的在编译时刻该模式的备份，</span><span
>VerifyCookie</span><span >的功能就是检查它们是否匹配，如果不匹配，就要采取适当的措施。</span></p>
  <p><span><img width=533 height=257
src="Definitive Guide/image015.jpg"></span></p>
  <p><span >图</span><span>9-2 VDBE</span><span
>的步骤：程序开始</span></p>
  <p><span >语句的版本号由</span><span>VerifyCookie</span><span
>的</span><span>P2</span><span
>参数指定，将它与磁盘上的数据库</span><span>schema</span><span
>版本号进行比较。如果</span><span>schema</span><span
>没有改变，两个版本号应该一致。如果不一致，则</span><span>VDBE</span><span
>程序失效。在此情况下，</span><span>VerifyCookie</span><span
>将会终止程序并返回</span><span>SQLITE_SCHEMA</span><span
>错误。在此情况下，应用程序需要重新编译</span><span>SQL</span><span
>语句，基于新的</span><span>schema</span><span
>版本生成新的</span><span>VDBE</span><span
>程序。</span></p>
  <p><span >如果两者匹配，会执行下一条指令</span><span
>Goto</span><span >；它会跳到程序的主要部分，即第一条指令，打开表读取记录。这里有两点值得注意：</span></p>
  <p><span>(1)Transaction</span><span
>指令本身不会获取锁。它的功能相当于</span><span>BEGIN</span><span
>，而共享锁实际是由</span><span>OpenRead</span><span
>指令获取的。当事务关闭时释放锁，由</span><span>Halt</span><span
>指令完成，它会进行扫尾工作。</span></p>
  <p><span>(2) </span><span >语句对象</span><span
>(VDBE</span><span >程序</span><span>)</span><span
>所需的存储空间在程序执行前就已经确定。这缘于两个重要事实：首先，栈的深度不会比指令的数目还多。其次，内存单元</span><span
>(memory cell)</span><span >的数量永远不会多于指令的数量</span><span
>(</span><span >通常少得多</span><span>)</span><span
>。在执行</span><span>VDBE</span><span
>程序之前，</span><span>SQLite</span><span
>可以计算出分配资源所需要的内存。</span></p>
  <h3><a name="_Toc245565885"><span >指令的类型</span></a></h3>
  <p><span>VDBE</span><span >同时只会执行一条指令。每条指令都完成一项简单的任务，而且通常和该指令前面、后面的指令有关。大体上来说，指令可分为三类：</span></p>
  <p><span>(1)</span><span >处理值：这些指令通常完成算术运算，比如加、减和除；逻辑运算，比如与和或；还有字符串操作。</span></p>
  <p><span>(2)</span><span >数据管理：这些指令操作在内存和磁盘上的数据。内存指令进行栈操作或者在内存单元之间传递数据。磁盘操作指令控制</span><span
>B-tree</span><span >和</span><span>pager</span><span
>打开或操作游标，开始或结束事务，等等。</span></p>
  <p><span>(3)</span><span >流程控制：控制指令主要是有条件地或无条件地移动指令指针。</span></p>
  <p><span >一旦熟悉了指令集，就不难明白</span><span
>VDBE</span><span >程序是如何工作的。至少你可以了解如何使用栈来为后面指令的执行做准备。</span></p>
  <h2><a name="_Toc245565886"></a><a name="_Toc242291787"><span>B-Tree</span></a><span
style='font-family:黑体'>和</span><span>Pager</span><span
style='font-family:黑体'>模型</span></h2>
  <p><span>B-tree</span><span >使</span><span
>VDBE</span><span >执行查找、插入和删除的效率达到</span><span
>O(logN)</span><span >，以及在</span><span
>O(1)</span><span >的效率下双向遍历结果集。它是自平衡的，可自动地执行碎片整理和空间回收。</span><span
>B-tree</span><span >本身不会直接读写磁盘，它仅仅维护着页</span><span
>(page)</span><span >之间的关系。当</span><span
>B-tree</span><span >需要页或者修改页时，它就会调用</span><span
>pager</span><span >。当修改页时，</span><span
>pager</span><span >保证原始页首先写入日志文件。当它完成写操作时，</span><span
>pager</span><span >根据事务状态决定如何做。</span></p>
  <h3><a name="_Toc245565887"><span >数据库文件格式</span></a></h3>
  <p><span >数据库中所有的页从</span><span
>1</span><span >开始顺序编号。一个数据库由多个多重</span><span
>B-tree</span><span >构成――</span><span
>B-tree</span><span >用于每一个表和索引。每个表和索引的第</span><span
>1</span><span >个页</span><span>(</span><span
>地址</span><span>)</span><span
>称为根页。所有表和索引的根页都存储在</span><span>sqlite_master</span><span
>表中。</span></p>
  <p><span >数据库中第一个页</span><span
>(page 1)</span><span >有点特殊，</span><span
>page 1</span><span >的前</span><span>100</span><span
>个字节是一个对数据库文件进行描述的特殊文件头。它包括库的版本、格式的版本、页大小、编码等所有创建数据库时设置的永久性参数。有关这个特殊文件头的文档在</span><span
>btree.c</span><span >中，</span><span
>page 1</span><span >也是</span><span>sqlite_master</span><span
>表的根页。</span></p>
  <h4><span style='font-family:黑体'>页重用及回收</span></h4>
  <p><span>SQLite</span><span >利用一个空闲页链表</span><span
>(free list)</span><span >完成页的循环使用。当一个页的所有记录都被删除时，就被插入到该链表。当有新信息需要进入数据库时，临近的空闲页先被选中，当没有空闲页时，才创建新的页</span><span
>(</span><span >会增加文件的大小</span><span
>)</span><span >。当运行</span><span>VACUUM</span><span
>命令时，会清空空闲页链表，所以数据库会缩小。本质上它是在新的文件中重新建立数据库，而所正使用的页都被拷贝过去，而空闲页链表不拷，结果就是一个新的，变小了的数据库。当数据库的</span><span
>autovacuum</span><span >开启时，</span><span
>SQLite</span><span >不会使用空闲页链表，而且在每一次事务提交时自动压缩数据库。</span></p>
  <h4><span>B-Tree</span><span style='font-family:黑体'>记录</span></h4>
  <p><span>B-tree</span><span >中的页由</span><span
>B-tree</span><span >记录组成，也叫做</span><span
>payload(</span><span >有效载荷</span><span
>)</span><span >。每一个</span><span>B-tree</span><span
>记录</span><span>(</span><span
>或</span><span>payload)</span><span
>有两个域：关键字域</span><span>(key field)</span><span
>和数据域</span><span>(data field)</span><span
>。关键字域就是</span><span>ROWID</span><span
>的值，也就是每个数据库表都会提供的关键字的值。从</span><span>B-tree</span><span
>的角度，数据域可以是任何无结构的数据。数据库的记录就保存在这些数据域中。</span><span
>B-tree</span><span >的任务就是排序和遍历，这仅需要关键字段。</span><span
>Payload</span><span >的大小是不定的，这与内部的关键字和数据域有关。平均情况下，每个页一般包含多个</span><span
>payload</span><span >，当然也可能一个</span><span
>payload</span><span >占用几个页</span><span
>(</span><span >当一个</span><span>payload</span><span
>太大不能存在一个页内</span><span>)</span><span
>。</span></p>
  <h4><span>B+</span><span style='font-family:黑体'>树</span></h4>
  <p><span>B-tree</span><span >按关键字的顺序存储，在一个</span><span
>B-tree</span><span >中所有的关键字必须唯一</span><span
>(</span><span >这一点自动地由</span><span>ROWID</span><span
>主键字段保证</span><span>)</span><span
>。表采用</span><span>B+tree</span><span
>，</span><span>B+tree</span><span
>的内部结点不包含表数据</span><span>(</span><span
>数据库记录</span><span>)</span><span
>。图</span><span>9-3</span><span
>是一个表的</span><span>B+tree</span><span
>的示例：</span></p>
  <p><span><img width=543 height=215
src="Definitive Guide/image016.jpg"></span></p>
  <p><span >图</span><span>9-3 B+tree</span><span
>的组织</span><span>(</span><span
>表</span><span>) </span></p>
  <p><span>B+tree</span><span >中的根页</span><span
>(root page)</span><span >和内部页</span><span
>(internal page)</span><span >都是用来导航的，这些页的数据域都是指向下级页的指针，仅仅包含关键字。所有的数据库记录都存储在叶子页</span><span
>(leaf page)</span><span >内。在叶节点一级，记录和页都是按照关键字的顺序排列的，这使</span><span
>B-tree</span><span >游标只使用页结点就能正向和反向</span><span
>(</span><span >水平地</span><span>)</span><span
>遍历记录，并使遍历的效率</span><span>(</span><span
>时间复杂度</span><span>)</span><span
>可能达到</span><span>O(1)</span><span
>。</span></p>
  <h4><span style='font-family:黑体'>记录和字段</span></h4>
  <p><span >数据库记录位于叶子页的数据域，由</span><span
>VDBE</span><span >管理</span><span>(</span><span
>前面在介绍</span><span>Callback</span><span
>命令时介绍过</span><span>)</span><span
>。数据库记录以二进制的形式存储，但有一定的数据格式，这种格式描述了记录中的所有字段。记录格式是连续的字节流，其组成包括一个逻辑头</span><span
>(logical header)</span><span >和一个数据区</span><span
>(data segment)</span><span >，逻辑头包括“头大小</span><span
>(</span><span >可变长的</span><span>64</span><span
>位整数</span><span>)</span><span
>”和一个数据类型</span><span>(</span><span
>也是可变长的</span><span>64</span><span
>位整数</span><span>)</span><span
>数组，数据类型用来描述存储在数据区的字段的类型，如图</span><span>9-4</span><span
>所示。</span><span>64</span><span
>位整数用</span><span>Huffman</span><span
>编码实现。</span></p>
  <p><span><img width=534 height=134
src="Definitive Guide/image017.jpg"></span></p>
  <p><span >图</span><span>9-4 </span><span
>记录结构</span></p>
  <p><span >类型入口的数量与字段数量相等。类型数组与字段数组的元素按下标相对应。一个类型入口表明它对应字段的数据类型和宽度。类型入口的可能取值及其含义在表</span><span
>9-1</span><span >中列出。</span></p>
  <p><span >表</span><span>9-1 </span><span
>字段类型值</span></p>
  <table border=1 cellspacing=0 cellpadding=0>
    <tr>
      <td width=182 valign=top><p align=center style='text-align:center'><span
  >类型值</span></p></td>
      <td width=189 valign=top><p align=center style='text-align:center'><span
  >含义</span></p></td>
      <td width=168 valign=top><p align=center style='text-align:center'><span
  >数据宽度</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>0</span></p></td>
      <td width=189 valign=top><p><span>NULL</span></p></td>
      <td width=168 valign=top><p><span>0</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>N in 1..4</span></p></td>
      <td width=189 valign=top><p><span >有符号整数</span></p></td>
      <td width=168 valign=top><p><span>N</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>5</span></p></td>
      <td width=189 valign=top><p><span >有符号整数</span></p></td>
      <td width=168 valign=top><p><span>6</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>6</span></p></td>
      <td width=189 valign=top><p><span >有符号整数</span></p></td>
      <td width=168 valign=top><p><span>8</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>7</span></p></td>
      <td width=189 valign=top><p><span>IEEE</span><span >符点数</span></p></td>
      <td width=168 valign=top><p><span>8</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>8-11</span></p></td>
      <td width=189 valign=top><p><span >未使用</span></p></td>
      <td width=168 valign=top><p><span>N/A</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>N&gt;12</span><span style='font-family:
  宋体'>的偶数</span></p></td>
      <td width=189 valign=top><p><span>BLOB</span></p></td>
      <td width=168 valign=top><p><span>(N-12)/2</span></p></td>
    </tr>
    <tr>
      <td width=182 valign=top><p><span>N&gt;13</span><span style='font-family:
  宋体'>的奇数</span></p></td>
      <td width=189 valign=top><p><span>TEXT</span></p></td>
      <td width=168 valign=top><p><span>(N-13)/2</span></p></td>
    </tr>
  </table>
  <p><span >例如，取</span><span>episodes</span><span
>表的第</span><span>1</span><span
>条记录：</span></p>
  <p><span>sqlite&gt; SELECT * FROM episodes ORDER BY
    id LIMIT 1; </span></p>
  <p><span>id&nbsp;&nbsp;&nbsp; season&nbsp;&nbsp;&nbsp;&nbsp; name </span></p>
  <p><span>0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Good
    News Bad News </span></p>
  <p><span >这条记录的内部记录格式如图</span><span
>9-5</span><span >所示。</span></p>
  <p><span><img width=317 height=32
src="Definitive Guide/image018.jpg"></span></p>
  <p><span >表</span><span>9-5 episodes</span><span
>表的第</span><span>1</span><span
>条记录</span></p>
  <p><span >记录头长</span><span>4</span><span
>字节。头的大小反映头内各要素都是单字节编码。第一个类型，对应</span><span>id</span><span
>字段，是一个</span><span>1</span><span
>字节有符号整数。第二个类型，对应</span><span>season</span><span
>字段，也是一个</span><span>1</span><span
>字节有符号整数。</span><span>Name</span><span
>字段的类型入口是一个大于</span><span>13</span><span
>的奇数，表示它是一个</span><span>text</span><span
>值，该值占</span><span>(49-13)/2=18</span><span
>个字节。通过这些信息，</span><span>VDBE</span><span
>可以解析记录的数据段并取出独立的字段值。</span></p>
  <h4><span style='font-family:黑体'>层次数据组织</span></h4>
  <p><span>SQLite</span><span >的层次数据组织模型如图</span><span
>9-6</span><span >所示。在模型中，每层处理特定的数据单元。从下向上，数据越来越结构化；从上往下，数据越来越无序。</span><span
>C-API</span><span >处理字段值，</span><span
>VDBE</span><span >处理记录，</span><span
>B-tree</span><span >处理健值的数据，</span><span
>pager</span><span >处理页，</span><span
>OS</span><span >接口处理二进制的数据和原始存储器。</span></p>
  <p><span><img width=332 height=399
src="Definitive Guide/image019.jpg"></span></p>
  <p><span >图</span><span>9-6 </span><span
>模型和各层所对应的数据</span></p>
  <p><span>Each module takes part in managing its own
    specific portion of the data in the database, and relies on the layer below it
    to supply it with a more crude form from which to extract its respective
    pieces. </span></p>
  <h4><span style='font-family:黑体'>溢出页</span></h4>
  <p><span >如前所述，</span><span>B-tree</span><span
>记录具有可变的大小，而页的大小是固定的。这就有可能一个</span><span>B-tree</span><span
>记录比一个单独的页还要大。这时，超大的</span><span>B-tree</span><span
>记录就溢出到由溢出页组成的链表上，如图</span><span>9-7</span><span
>所示。</span></p>
  <p><span >在图中，第</span><span>4</span><span
>个页太大，</span><span>B-tree</span><span
>模块就创建一个溢出页来容纳它。如果一个溢出页还不够，就再链接第</span><span>2</span><span
>个。这实际上也是二进制大对象的处理方法。请记住：当你使用大的</span><span>BLOB</span><span
>时，它实际上是存储在页链表中的。如果</span><span>BLOB</span><span
>实在太大，链表就会很长，操作就会很低效。这种情况下，将</span><span>BLOB</span><span
>存储在一个外部文件中而在数据库中只保存其文件名也许更好一些。</span></p>
  <p><span><img width=291 height=306
src="Definitive Guide/image020.jpg"></span></p>
  <p><span >图</span><span>9-7 </span><span
>溢出页</span></p>
  <h3><a name="_Toc245565888"><span>B-Tree API</span></a></h3>
  <p><span>B-Tree</span><span >模块有它自己的</span><span
>API</span><span >，它可以独立于</span><span
>C API</span><span >使用。也就是说，如果你愿意，你可以把它当作一个独立的运行库来使用，或在</span><span
>SQLite</span><span >中直接存取库表。</span><span
>SQLite B-tree</span><span >模块的另一个好处就是它本身支持事务。由</span><span
>pager</span><span >处理的事务、锁和日志都是为</span><span
>B-tree</span><span >服务的。根据功能，可将</span><span
>B-Tree API</span><span >分为以下几类：</span></p>
  <h4><span style='font-family:黑体'>访问和事务函数</span></h4>
  <p><span >包括：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeOpen: </span><span style='font-family:
宋体'>打开一个新的数据库文件，返回一个</span><span>B-tree</span><span
>对象。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeClose: </span><span
>关闭一个数据库。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeBeginTrans: </span><span
>开始一个新的事务。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeCommit: </span><span
>提交当前事务。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeRollback: </span><span
>回卷当前事务。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeBeginStmt: </span><span
>开始一个</span><span>statement</span><span
>事务。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeCommitStmt: </span><span
>提交一个</span><span>statement</span><span
>事务。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeRollbackStmt: </span><span
>回卷一个</span><span>statement</span><span
>事务。</span></p>
  <h4><span style='font-family:黑体'>表函数</span></h4>
  <p><span >包括：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeCreateTable: </span><span
>在数据库文件中创建一个新的、空的</span><span>B-tree</span><span
>。其参数决定是采用表格式</span><span>(B+tree)</span><span
>还是索引格式</span><span>(B-tree)</span><span
>。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeDropTable: </span><span
>从数据库中删除一个</span><span>B-tree</span><span
>。</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeClearTable: </span><span
>从</span><span>B-tree</span><span
>中删除所有数据，但保持</span><span>B-tree</span><span
>的结构。</span></p>
  <h4><span style='font-family:黑体'>游标函数</span></h4>
  <p><span >包括：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeCursor: Creates a new cursor
    pointing to a particular B-tree. Cursors can be either a read cursor or a write
    cursor. Read and write cursors may not exist in the same B-tree at the same
    time. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeCloseCursor: Closes the B-tree
    cursor. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeFirst: Moves the cursor to the first
    element in a B-tree. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeLast: Moves the cursor to the last
    element in a B-tree. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeNext: Moves the cursor to the next
    element after the one it is currently pointing to. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreePrevious: Moves the cursor to the
    previous element before the one it is currently pointing to. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeMoveto: Moves the cursor to an
    element that matches the key value passed in as a parameter. If there is no
    match, leaves the cursor pointing to an element that would be on either side of
    the matching element, had it existed. </span></p>
  <h4><span style='font-family:黑体'>记录函数</span></h4>
  <p><span >包括：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeDelete: Deletes the record that the
    cursor is pointing to. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeInsert: Inserts a new element in the
    appropriate place of the B-tree. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeKeySize: Returns the number of bytes
    in the key of the record that the cursor is pointing to. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeKey: Returns the key of the record
    the cursor is currently pointing to. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeDataSize: Returns the number of
    bytes in the data record that the cursor is currently pointing to. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeData: Returns the data in the record
    the cursor is currently pointing to. </span></p>
  <h4><span style='font-family:黑体'>配置函数</span></h4>
  <p><span >包括：</span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeSetCacheSize: Controls the page
    cache size as well as the synchronous writes (as defined in the synchronous
    pragma). </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeSetSafetyLevel: Changes the way data
    is synced to disk in order to increase or decrease how well the database
    resists damage due to OS crashes and power failures. Level 1 is the same as
    asynchronous (no syncs() occur and there is a high probability of damage). This
    is the equivalent to pragma synchronous=OFF. Level 2 is the default. There is a
    very low but non-zero probability of damage. This is the equivalent to pragma
    synchronous=NORMAL. Level 3 reduces the probability of damage to near zero but
    with a write performance reduction. This is the equivalent to pragma
    synchronous=FULL. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeSetPageSize: Sets the database page
    size. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeGetPageSize: Returns the database
    page size. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeSetAutoVacuum: Sets the autovacuum
    property of the database. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeGetAutoVacuum: Returns whether the
    database uses autovacuum. </span></p>
  <p><span
 style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sqlite3BtreeSetBusyHandler: Sets the busy
    handler. </span></p>
  <p><span >还有其它的函数，所有这些函数在</span><span
>btree.h</span><span >和</span><span>btree.c</span><span
>中都有很完备的文档，但上面列出的函数可以使你建立一个总体印象。</span></p>
  <h2><a name="_Toc245565889"><span style='font-family:黑体'>编译器</span></a></h2>
  <p><span >前面已经介绍了</span><span>VDBE</span><span
>以下直到</span><span>OS</span><span
>层的各层次。下面介绍</span><span>VDBE</span><span
>程序是怎么来的。编译器的输入是一个单独的</span><span>SQL</span><span
>命令，输出是最终经过优化的</span><span>VDBE</span><span
>程序，这些工作在</span><span>3</span><span
>个阶段上完成：分词器</span><span>(Tokenizer)</span><span
>、分析器</span><span>(Parser)</span><span
>和代码生成器</span><span>(Code Generator)</span><span
>。</span></p>
  <h3><a name="_Toc245565890"><span >分词器</span><span
>(Tokenizer)</span></a></h3>
  <p><span >编译的第一步是对</span><span
>SQL</span><span >命令分词。分词器将一个命令分解成一串单独的词汇</span><span
>(token)</span><span >。词可以是有特定含义的一个字符或一个字符序列。每个词都有其关联的词类</span><span
>(token class)</span><span >，词类是一个数字标识，表明这个词是什么。例如左括号的词类是</span><span
>TK_LP</span><span >，保留字</span><span
>SELECT</span><span >的词类是</span><span
>TK_SELECT</span><span >。所有词类在</span><span
>parse.h</span><span >中定义。例如下面的</span><span
>SQL</span><span >语句：</span></p>
  <p><span>SELECT rowid FROM foo where name='bar'
    LIMIT 1 ORDER BY rowid; </span></p>
  <p><span >经分词器处理之后的部分结果在表</span><span
>9-2</span><span >中给出。</span></p>
  <p><span >表</span><span>9-2 </span><span
>一个分词后</span><span>SELECT</span><span
>语句</span></p>
  <table border=1 cellspacing=0 cellpadding=0>
    <tr>
      <td width=170 valign=top><p><span >文本</span></p></td>
      <td width=154 valign=top><p><span >词类</span></p></td>
      <td width=204 valign=top><p><span >动作</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>SELECT</span></p></td>
      <td width=154 valign=top><p><span>TK_SELECT</span></p></td>
      <td width=204 valign=top><p><span >发给分析器</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>&quot; &quot;</span></p></td>
      <td width=154 valign=top><p><span>TK_SPACE</span></p></td>
      <td width=204 valign=top><p><span >丢弃</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>Rowid</span></p></td>
      <td width=154 valign=top><p><span>TK_ID</span></p></td>
      <td width=204 valign=top><p><span >发给分析器</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>&quot; &quot;</span></p></td>
      <td width=154 valign=top><p><span>TK_SPACE</span></p></td>
      <td width=204 valign=top><p><span >丢弃</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>FROM</span></p></td>
      <td width=154 valign=top><p><span>TK_FROM</span></p></td>
      <td width=204 valign=top><p><span >发给分析器</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>&quot; &quot;</span></p></td>
      <td width=154 valign=top><p><span>TK_SPACE</span></p></td>
      <td width=204 valign=top><p><span >丢弃</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>foo</span></p></td>
      <td width=154 valign=top><p><span>TK_ID</span></p></td>
      <td width=204 valign=top><p><span >发给分析器</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>&quot; &quot;</span></p></td>
      <td width=154 valign=top><p><span>TK_SPACE</span></p></td>
      <td width=204 valign=top><p><span >丢弃</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>WHERE</span></p></td>
      <td width=154 valign=top><p><span>TK_WHERE</span></p></td>
      <td width=204 valign=top><p><span >发给分析器</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>&quot; &quot;</span></p></td>
      <td width=154 valign=top><p><span>TK_SPACE</span></p></td>
      <td width=204 valign=top><p><span >丢弃</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>name</span></p></td>
      <td width=154 valign=top><p><span>TK_ID</span></p></td>
      <td width=204 valign=top><p><span >发给分析器</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>=</span></p></td>
      <td width=154 valign=top><p><span>TK_EQ</span></p></td>
      <td width=204 valign=top><p><span >发给分析器</span></p></td>
    </tr>
    <tr>
      <td width=170 valign=top><p><span>…</span></p></td>
      <td width=154 valign=top>&nbsp;</td>
      <td width=204 valign=top>&nbsp;</td>
    </tr>
  </table>
  <p><span >总之，分词器按照</span><span
>SQL</span><span >的词法定义把它切分为一个一个的词，并传递给分析器</span><span
>(Parser)</span><span >进行语法分析</span><span
>(</span><span >忽略空格</span><span>)</span><span
>。</span></p>
  <h4><span style='font-family:黑体'>保留字</span></h4>
  <p><span >分词器是手工编写的</span><span
>(hand-coded)</span><span >，主要在</span><span
>Tokenize.c</span><span >中实现。因为是手工代码，不是用自动生成的代码来对</span><span
>SQL</span><span >保留字分类。保留字在</span><span
>keywordhash.h</span><span >文件中定义。这个文件是一个最优化的、将所有</span><span
>SQL</span><span >保留字压缩到可能最小的缓冲区，方法是公共的字符序列重叠存放。</span><span
>SQLite</span><span >使用指明了每个保留字偏移量和大小的数组来识别保留字入口。这种方法是一种空间优化的方法，有利于内嵌式的应用程序。一个生成了的缓冲区的例子如下：</span></p>
  <p><span  >static int
    keywordCode(const char *z, int n){</span></p>
  <p><span  >static const char
    zText[537] =</span></p>
  <p><span  >&quot;ABORTABLEFTEMPORARYADDATABASELECTHENDEFAULTRANSACTIONATURALTER&quot;</span></p>
  <p><span  >&quot;AISEACHECKEYAFTEREFERENCESCAPELSEXCEPTRIGGEREGEXPLAINITIALLYANALYZE&quot;</span></p>
  <p><span  >&quot;XCLUSIVEXISTSTATEMENTANDEFERRABLEATTACHAVINGLOBEFOREIGNOREINDEX&quot;</span></p>
  <p><span  >&quot;AUTOINCREMENTBEGINNERENAMEBETWEENOTNULLIKEBYCASCADEFERREDELETE&quot;</span></p>
  <p><span  >&quot;CASECASTCOLLATECOLUMNCOMMITCONFLICTCONSTRAINTERSECTCREATECROSS&quot;</span></p>
  <p><span  >&quot;CURRENT_DATECURRENT_TIMESTAMPLANDESCDETACHDISTINCTDROPRAGMATCH&quot;</span></p>
  <p><span  >&quot;FAILIMITFROMFULLGROUPDATEIFIMMEDIATEINSERTINSTEADINTOFFSETISNULL&quot;</span></p>
  <p><span  >&quot;JOINORDEREPLACEOUTERESTRICTPRIMARYQUERYRIGHTROLLBACKROWHENUNION&quot;</span></p>
  <p><span  >&quot;UNIQUEUSINGVACUUMVALUESVIEWHERE&quot;;</span></p>
  <p><span>The keywordhash.h file includes a routine
    sqlite3KeywordCode(), which allows the tokenizer to quickly match the keyword
    with its appropriate token class with minimal space. So, the tokenizer first
    tries to match a token with what it knows, and failing that, it resorts to
    sqlite3KeywordCode(), which will return either a keyword token class or a
    generic TK_ID. </span></p>
  <p><span>The tokenizer and parser work hand in hand,
    one token at a time. As the tokenizer resolves each token, it passes the token
    to the parser. The parser takes the tokens and builds a parse tree, which is a
    hierarchical representation of the statement. </span></p>
  <h3><a name="_Toc245565891"><span >分析器</span><span
>(Parser)</span></a></h3>
  <p><span>SQLite</span><span >的语法分析器是用</span><span
>Lemon</span><span >生成的</span><span>(Lemon</span><span
>是一个开源的</span><span>LALR(1)</span><span
>语法分析器的生成器，</span><span>SQLite</span><span
>在使用时进行了定制</span><span>)</span><span
>。该分析器用</span><span>parse.c</span><span
>内定义的语法规则将一串词组织成层次结构的分析树</span><span>(parse
    tree)</span><span >。</span></p>
  <p><span>The parse tree is primarily composed of
    expressions and lists of expressions. An expression itself is a recursive
    structure that can contain subexpressions under it. For example, the WHERE clause
    in a SELECT parse tree is represented by a single expression. The SELECT
    clause, on the other hand, is represented as a list of expressions; each
    expression is a column that will be returned in the result set. </span><span
>例如，如下简单的</span><span>SQL</span><span
>语句：</span></p>
  <p><span>SELECT rowid, name, season FROM episodes
    WHERE rowid=1 LIMIT 1</span></p>
  <p><span >可以组织成如图</span><span>9-8</span><span
>所示的分析树。</span></p>
  <p><span><img width=291 height=389
src="Definitive Guide/image021.jpg"></span></p>
  <p><span >图</span><span>9-8 </span><span
>简化了的分析树</span></p>
  <p><span >一旦语句经过分词和分析，分析树作为一种结果会传送给代码生成器。</span></p>
  <h3><a name="_Toc245565892"><span >代码生成器</span><span
>(Code Generator)</span></a></h3>
  <p><span >代码生成器是</span><span>SQLite</span><span
>中最庞大、最复杂的部分。与其它模块不同，代码生成器没有定义明确的接口，但它与分析器关系紧密。代码生成器由多个源文件组成，这些源文件大多针对特定的</span><span
>SQL</span><span >操作。例如，生成</span><span
>SELECT</span><span >语句的代码在</span><span
>select.c</span><span >中，其它的源文件包括</span><span
>update.c</span><span >、</span><span
>insert.c</span><span >、</span><span
>delete.c</span><span >和</span><span
>trigger.c</span><span >等等。</span></p>
  <p><span >代码生成器根据语法分析树生成</span><span
>VDBE</span><span >程序。树的每一部分生成一个</span><span
>VDBE</span><span >指令序列来完成特定的任务。</span><span
>The values for the operands are taken from the data structures
    associated with the parse tree. </span><span >例如，下面是一个读操作中打开表的代码的生成实现：</span></p>
  <p><span>/* Generate code that will open a table for
    reading.*/</span></p>
  <p><span>void sqlite3OpenTableForReading(</span></p>
  <p><span>&nbsp; Vdbe
    *v,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Generate code into this VDBE
    */</span></p>
  <p><span>&nbsp; int
    iCur,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The cursor number of the table */</span></p>
  <p><span>&nbsp; Table *pTab&nbsp;&nbsp;&nbsp;&nbsp;
    /* The table to be opened */</span></p>
  <p><span>){</span></p>
  <p><span>&nbsp; sqlite3VdbeAddOp(v, OP_Integer,
    pTab-&gt;iDb, 0);</span></p>
  <p><span>&nbsp; sqlite3VdbeAddOp(v, OP_OpenRead,
    iCur, pTab-&gt;tnum);</span></p>
  <p><span>&nbsp; VdbeComment((v, &quot;# %s&quot;,
    pTab-&gt;zName));</span></p>
  <p><span>&nbsp; sqlite3VdbeAddOp(v,
    OP_SetNumColumns, iCur, pTab-&gt;nCol);</span></p>
  <p><span>}</span></p>
  <p><span>Sqlite3vdbeAddOp</span><span
>函数有三个参数：</span><span>(1)VDBE</span><span
>实例</span><span>(</span><span
>它将添加指令</span><span>)</span><span
>，</span><span>(2)</span><span
>操作码</span><span>(</span><span
>一条指令</span><span>)</span><span
>，</span><span>(3)</span><span
>两个操作数。它增加一条指令到</span><span>VDBE</span><span
>程序。上例中，</span><span>sqlite3OpenTableForReading</span><span
>增加了</span><span>3</span><span
>条指令，即图</span><span>9-1</span><span
>中的指令</span><span>1~3</span><span
>，功能是打开一个表的</span><span>B-tree</span><span
>用于读。为方便起见，将图</span><span>9-1</span><span
>中的指令序列重列于此：</span></p>
  <p><span>sqlite&gt; explain select * from episodes;</span></p>
  <p><span>addr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; opcode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p1&nbsp;&nbsp;&nbsp; p2&nbsp;&nbsp;&nbsp; p3 </span></p>
  <p><span>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Goto
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 12 </span></p>
  <p><span>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span>2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OpenRead
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 &nbsp;&nbsp;&nbsp; 2
    &nbsp;&nbsp;&nbsp; # episodes </span></p>
  <p><span>3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetNumColumns
    &nbsp; 0 &nbsp;&nbsp;&nbsp; 3 </span></p>
  <p><span>4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rewind
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 10 </span></p>
  <p><span>5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Recno
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span>6 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Column
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 1 </span></p>
  <p><span>7 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Column
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 2 </span></p>
  <p><span>8 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Callback&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3
    &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span>9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 5 </span></p>
  <p><span>10 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Close
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span>11 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Halt
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span>12 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Transaction
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 &nbsp;&nbsp;&nbsp; 0 </span></p>
  <p><span>13 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VerifyCookie
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 &nbsp;&nbsp;&nbsp; 10 </span></p>
  <p><span>14 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Goto
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 1 </span></p>
  <p><span>15 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Noop
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
    &nbsp;&nbsp;&nbsp; 0 </span></p>
  <h3><a name="_Toc245565893"><span >优化</span></a></h3>
  <p><span >代码生成器不仅负责生成代码，也负责进行查询优化。优化是代码生成的一部分，主要的实现位于</span><span
>where.c</span><span >中。生成的</span><span
>WHERE</span><span >子句通常被其它模块共享，比如</span><span
>select.c</span><span >、</span><span
>update.c</span><span >和</span><span
>delete.c</span><span >。这些模块调用</span><span
>sqlite3WhereBegin()</span><span >开始</span><span
>WHERE</span><span >语句块的指令生成，然后将返回的代码加入到它们自己的</span><span
>VDBE</span><span >代码中，最后调用</span><span
>sqlite3WhereEnd()</span><span >，生成结束</span><span
>WHERE</span><span >子句代码的</span><span
>VDBE</span><span >指令。程序的一般结构如图</span><span
>9-9</span><span >所示：</span></p>
  <p><span><img width=451 height=201
src="Definitive Guide/image022.jpg"></span></p>
  <p>图9-9 WHERE子句的VDBE代码的生成
    
    优化发生在sqlite3WhereBegin()阶段。<br>
    它在已完成工作的基础上，寻找可以使用的索引，寻找可以重写的表达式，等等。
    
    为了能对优化先有一个感觉，<br>
    我们从一个不含WHERE子句的简单SELECT语句开始，如图9-10所示： </p>
<p><span><img width=553 height=259
src="Definitive Guide/image023.jpg"></span></p>
  <p><span >图</span><span>9-10 </span><span
>一个不含</span><span>WHERE</span><span
>子句的</span><span>SELECT</span><span
>语句</span></p>
</div>
</body>
</html>
